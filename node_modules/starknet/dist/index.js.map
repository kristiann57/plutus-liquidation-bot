{"version":3,"sources":["../src/index.ts","../src/constants.ts","../src/types/api/index.ts","../src/types/api/jsonrpc/index.ts","../src/types/api/rpcspec_0_6/index.ts","../src/types/api/rpcspec_0_6/errors.ts","../src/types/api/rpcspec_0_6/components.ts","../src/types/api/rpcspec_0_6/nonspec.ts","../src/utils/encode.ts","../src/provider/rpc.ts","../src/channel/rpc_0_6.ts","../src/provider/errors.ts","../src/types/index.ts","../src/types/calldata.ts","../src/types/lib/contract/index.ts","../src/types/lib/index.ts","../src/types/typedData.ts","../src/utils/assert.ts","../src/utils/num.ts","../src/utils/hash/selector.ts","../src/utils/shortString.ts","../src/utils/calldata/byteArray.ts","../src/utils/calldata/cairo.ts","../src/utils/cairoDataTypes/felt.ts","../src/utils/cairoDataTypes/uint256.ts","../src/utils/cairoDataTypes/uint512.ts","../src/utils/calldata/enum/CairoCustomEnum.ts","../src/utils/calldata/enum/CairoOption.ts","../src/utils/calldata/enum/CairoResult.ts","../src/utils/calldata/formatter.ts","../src/utils/calldata/parser/parser-0-1.1.0.ts","../src/utils/calldata/parser/parser-2.0.0.ts","../src/utils/calldata/parser/index.ts","../src/utils/calldata/tuple.ts","../src/utils/calldata/propertyOrder.ts","../src/utils/calldata/requestParser.ts","../src/utils/calldata/responseParser.ts","../src/utils/calldata/validate.ts","../src/utils/calldata/index.ts","../src/utils/hash/index.ts","../src/utils/hash/transactionHash/v2.ts","../src/utils/ec.ts","../src/utils/hash/transactionHash/v3.ts","../src/utils/hash/transactionHash/index.ts","../src/utils/hash/classHash.ts","../src/utils/json.ts","../src/utils/stark.ts","../src/utils/contract.ts","../src/utils/eth.ts","../src/utils/fetchPonyfill.ts","../src/utils/provider.ts","../src/utils/transaction.ts","../src/channel/rpc_0_7.ts","../src/utils/responseParser/rpc.ts","../src/utils/transactionReceipt.ts","../src/provider/extensions/default.ts","../src/utils/starknetId.ts","../src/provider/extensions/starknetId.ts","../src/provider/interface.ts","../src/provider/index.ts","../src/signer/interface.ts","../src/utils/typedData.ts","../src/utils/merkle.ts","../src/signer/default.ts","../src/signer/ethSigner.ts","../src/utils/uint256.ts","../src/utils/events/index.ts","../src/account/default.ts","../src/account/interface.ts","../src/wallet/connect.ts","../src/wallet/account.ts","../src/contract/default.ts","../src/contract/interface.ts","../src/contract/contractFactory.ts","../src/utils/responseParser/interface.ts","../src/utils/address.ts","../src/utils/url.ts"],"sourcesContent":["/**\n * Main\n */\nexport * from './wallet';\nexport * from './account';\nexport * from './contract';\nexport * from './provider';\nexport * from './signer';\nexport * from './channel';\n\n// TODO: decide on final export style\nexport * from './types';\nexport * as types from './types';\n\n/**\n * Utils\n */\nexport * as constants from './constants';\nexport * as encode from './utils/encode';\nexport * as hash from './utils/hash';\nexport * as v3hash from './utils/hash/transactionHash/v3';\nexport * as v2hash from './utils/hash/transactionHash/v2';\nexport * as json from './utils/json';\nexport * as num from './utils/num';\nexport * as transaction from './utils/transaction';\nexport * as stark from './utils/stark';\nexport * as eth from './utils/eth';\nexport * as merkle from './utils/merkle';\nexport * as uint256 from './utils/uint256';\nexport * as shortString from './utils/shortString';\nexport * as typedData from './utils/typedData';\nexport * as ec from './utils/ec';\nexport * as starknetId from './utils/starknetId';\nexport * as provider from './utils/provider';\nexport * as selector from './utils/hash/selector';\nexport * as events from './utils/events';\nexport * from './utils/responseParser';\nexport * from './utils/cairoDataTypes/uint256';\nexport * from './utils/cairoDataTypes/uint512';\nexport * from './utils/address';\nexport * from './utils/url';\nexport * from './utils/calldata';\nexport * from './utils/calldata/enum';\nexport * from './utils/contract';\nexport * from './utils/transactionReceipt';\nexport * as wallet from './wallet/connect';\n\n/**\n * Deprecated\n */\n/* eslint-disable import/first */\nimport * as num from './utils/num';\n\n/** @deprecated prefer the 'num' naming */\nexport const number = num;\n","import { ETransactionVersion } from './types/api';\n\nexport { IS_BROWSER } from './utils/encode';\n\n/**\n * Cairo Felt support storing max 31 character\n */\nexport const TEXT_TO_FELT_MAX_LEN = 31;\n\n/**\n * Alternatively use directly from api specification\n * types.RPC.ETransactionVersion\n * For BN do BigInt(TRANSACTION_VERSION.*)\n */\nexport { ETransactionVersion as TRANSACTION_VERSION };\n\nexport const ZERO = 0n;\nexport const MASK_250 = 2n ** 250n - 1n; // 2 ** 250 - 1\nexport const API_VERSION = ZERO;\nexport const PRIME = 2n ** 251n + 17n * 2n ** 192n + 1n;\n\n// based on: https://github.com/starkware-libs/cairo-lang/blob/v0.12.3/src/starkware/starknet/common/storage.cairo#L3\nexport const MAX_STORAGE_ITEM_SIZE = 256n;\nexport const ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\n\nconst range = (min: bigint, max: bigint) => ({ min, max }) as const;\n\nexport const RANGE_FELT = range(ZERO, PRIME - 1n);\nexport const RANGE_I128 = range(-(2n ** 127n), 2n ** 127n - 1n);\nexport const RANGE_U128 = range(ZERO, 2n ** 128n - 1n);\n\nexport enum BaseUrl {\n  SN_MAIN = 'https://alpha-mainnet.starknet.io',\n  SN_SEPOLIA = 'https://alpha-sepolia.starknet.io',\n}\n\nexport enum NetworkName {\n  SN_MAIN = 'SN_MAIN',\n  SN_SEPOLIA = 'SN_SEPOLIA',\n}\n\nexport enum StarknetChainId {\n  SN_MAIN = '0x534e5f4d41494e', // encodeShortString('SN_MAIN'),\n  SN_SEPOLIA = '0x534e5f5345504f4c4941', // encodeShortString('SN_SEPOLIA')\n}\n\nexport enum TransactionHashPrefix {\n  DECLARE = '0x6465636c617265', // encodeShortString('declare'),\n  DEPLOY = '0x6465706c6f79', // encodeShortString('deploy'),\n  DEPLOY_ACCOUNT = '0x6465706c6f795f6163636f756e74', // encodeShortString('deploy_account'),\n  INVOKE = '0x696e766f6b65', // encodeShortString('invoke'),\n  L1_HANDLER = '0x6c315f68616e646c6572', // encodeShortString('l1_handler'),\n}\n\nexport const enum FeeMarginPercentage {\n  L1_BOUND_MAX_AMOUNT = 50,\n  L1_BOUND_MAX_PRICE_PER_UNIT = 50,\n  MAX_FEE = 50,\n}\n\nexport const UDC = {\n  ADDRESS: '0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf',\n  ENTRYPOINT: 'deployContract',\n} as const;\n\nexport const RPC_DEFAULT_VERSION = 'v0_7';\n\nexport const RPC_NODES = {\n  SN_MAIN: [\n    `https://starknet-mainnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/mainnet-juno/${RPC_DEFAULT_VERSION}`,\n  ],\n  SN_SEPOLIA: [\n    `https://starknet-sepolia.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/sepolia-juno/${RPC_DEFAULT_VERSION}`,\n  ],\n} as const;\n","export * as JRPC from './jsonrpc';\n\nexport * as RPCSPEC06 from './rpcspec_0_6';\nexport * as RPCSPEC07 from 'starknet-types-07';\nexport * from 'starknet-types-07';\n","export type RequestBody = {\n  id: number | string;\n  jsonrpc: '2.0';\n  method: string;\n  params?: {};\n};\n\nexport type ResponseBody = {\n  id: number | string;\n  jsonrpc: '2.0';\n} & (SuccessResponseBody | ErrorResponseBody);\n\nexport type SuccessResponseBody = {\n  result: unknown;\n};\n\nexport type ErrorResponseBody = {\n  error: Error;\n};\n\nexport type Error = {\n  code: number;\n  message: string;\n  data?: unknown;\n};\n","/**\n * version 0.6.0\n */\n\nexport { Methods } from './methods';\nexport { ABI } from './contract';\nexport * as Errors from './errors';\nexport * as SPEC from './components';\nexport * from './nonspec';\n","export interface FAILED_TO_RECEIVE_TXN {\n  code: 1;\n  message: 'Failed to write transaction';\n}\n\nexport interface NO_TRACE_AVAILABLE {\n  code: 10;\n  message: 'No trace available for transaction';\n  data: {\n    status: 'RECEIVED' | 'REJECTED';\n  };\n}\n\nexport interface CONTRACT_NOT_FOUND {\n  code: 20;\n  message: 'Contract not found';\n}\n\nexport interface INVALID_MESSAGE_SELECTOR {\n  code: 21;\n  message: 'Invalid message selector';\n}\n\nexport interface INVALID_CALL_DATA {\n  code: 22;\n  message: 'Invalid call data';\n}\n\nexport interface BLOCK_NOT_FOUND {\n  code: 24;\n  message: 'Block not found';\n}\n\nexport interface INVALID_BLOCK_HASH {\n  code: 26;\n  message: 'Invalid block hash';\n}\n\nexport interface INVALID_TXN_INDEX {\n  code: 27;\n  message: 'Invalid transaction index in a block';\n}\n\nexport interface CLASS_HASH_NOT_FOUND {\n  code: 28;\n  message: 'Class hash not found';\n}\n\nexport interface TXN_HASH_NOT_FOUND {\n  code: 29;\n  message: 'Transaction hash not found';\n}\n\nexport interface PAGE_SIZE_TOO_BIG {\n  code: 31;\n  message: 'Requested page size is too big';\n}\n\nexport interface NO_BLOCKS {\n  code: 32;\n  message: 'There are no blocks';\n}\n\nexport interface INVALID_CONTINUATION_TOKEN {\n  code: 33;\n  message: 'The supplied continuation token is invalid or unknown';\n}\n\nexport interface TOO_MANY_KEYS_IN_FILTER {\n  code: 34;\n  message: 'Too many keys provided in a filter';\n}\n\nexport interface CONTRACT_ERROR {\n  code: 40;\n  message: 'Contract error';\n  data: {\n    revert_error: string;\n  };\n}\n\nexport interface TRANSACTION_EXECUTION_ERROR {\n  code: 41;\n  message: 'Transaction execution error';\n  data: {\n    transaction_index: number;\n    execution_error: string;\n  };\n}\n\nexport interface CLASS_ALREADY_DECLARED {\n  code: 51;\n  message: 'Class already declared';\n}\n\nexport interface INVALID_TRANSACTION_NONCE {\n  code: 52;\n  message: 'Invalid transaction nonce';\n}\n\nexport interface INSUFFICIENT_MAX_FEE {\n  code: 53;\n  message: 'Max fee is smaller than the minimal transaction cost (validation plus fee transfer)';\n}\n\nexport interface INSUFFICIENT_ACCOUNT_BALANCE {\n  code: 54;\n  message: \"Account balance is smaller than the transaction's max_fee\";\n}\n\nexport interface VALIDATION_FAILURE {\n  code: 55;\n  message: 'Account validation failed';\n  data: string;\n}\n\nexport interface COMPILATION_FAILED {\n  code: 56;\n  message: 'Compilation failed';\n}\n\nexport interface CONTRACT_CLASS_SIZE_IS_TOO_LARGE {\n  code: 57;\n  message: 'Contract class size it too large';\n}\n\nexport interface NON_ACCOUNT {\n  code: 58;\n  message: 'Sender address in not an account contract';\n}\n\nexport interface DUPLICATE_TX {\n  code: 59;\n  message: 'A transaction with the same hash already exists in the mempool';\n}\n\nexport interface COMPILED_CLASS_HASH_MISMATCH {\n  code: 60;\n  message: 'the compiled class hash did not match the one supplied in the transaction';\n}\n\nexport interface UNSUPPORTED_TX_VERSION {\n  code: 61;\n  message: 'the transaction version is not supported';\n}\n\nexport interface UNSUPPORTED_CONTRACT_CLASS_VERSION {\n  code: 62;\n  message: 'the contract class version is not supported';\n}\n\nexport interface UNEXPECTED_ERROR {\n  code: 63;\n  message: 'An unexpected error occurred';\n  data: string;\n}\n","/**\n * PRIMITIVES\n */\n\n/**\n * A field element. represented by at most 63 hex digits\n * @pattern ^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,62})$\n */\nexport type FELT = string;\n/**\n * an ethereum address represented as 40 hex digits\n * @pattern ^0x[a-fA-F0-9]{40}$\n */\nexport type ETH_ADDRESS = string;\n/**\n * A storage key. Represented as up to 62 hex digits, 3 bits, and 5 leading zeroes.\n * @pattern ^0x0[0-7]{1}[a-fA-F0-9]{0,62}$\n */\nexport type STORAGE_KEY = string;\nexport type ADDRESS = FELT;\nexport type NUM_AS_HEX = string;\n/**\n * 64 bit integers, represented by hex string of length at most 16\n * \"pattern\": \"^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,15})$\"\n */\nexport type u64 = string;\n/**\n * 64 bit integers, represented by hex string of length at most 32\n * \"pattern\": \"^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,31})$\"\n */\nexport type u128 = string;\nexport type SIGNATURE = Array<FELT>;\nexport type BLOCK_NUMBER = number;\nexport type BLOCK_HASH = FELT;\nexport type TXN_HASH = FELT;\nexport type CHAIN_ID = NUM_AS_HEX;\nexport type STRUCT_ABI_TYPE = 'struct';\nexport type EVENT_ABI_TYPE = 'event';\nexport type FUNCTION_ABI_TYPE = 'function' | 'l1_handler' | 'constructor';\n// Represents the type of an entry point.\nexport type ENTRY_POINT_TYPE = 'EXTERNAL' | 'L1_HANDLER' | 'CONSTRUCTOR';\n// Represents the type of a function call.\nexport type CALL_TYPE = 'DELEGATE' | 'LIBRARY_CALL' | 'CALL';\n// Represents the status of the transaction\nexport type TXN_STATUS = 'RECEIVED' | 'REJECTED' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1';\n// Flags that indicate how to simulate a given transaction. By default, the sequencer behavior is replicated locally (enough funds are expected to be in the account, and the fee will be deducted from the balance before the simulation of the next transaction). To skip the fee charge, use the SKIP_FEE_CHARGE flag.\nexport type SIMULATION_FLAG = 'SKIP_VALIDATE' | 'SKIP_FEE_CHARGE';\n// Data availability mode\nexport type DA_MODE = 'L1' | 'L2';\nexport type TXN_TYPE = 'DECLARE' | 'DEPLOY' | 'DEPLOY_ACCOUNT' | 'INVOKE' | 'L1_HANDLER';\nexport type TXN_FINALITY_STATUS = 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1';\nexport type TXN_EXECUTION_STATUS = 'SUCCEEDED' | 'REVERTED';\nexport type BLOCK_STATUS = 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';\nexport type BLOCK_TAG = 'latest' | 'pending';\n\n/**\n * READ API\n */\n\nexport type EVENTS_CHUNK = {\n  // Returns matching events\n  events: EMITTED_EVENT[];\n  // Use this token in a subsequent query to obtain the next page. Should not appear if there are no more pages.\n  continuation_token?: string;\n};\n\nexport type RESULT_PAGE_REQUEST = {\n  // The token returned from the previous query. If no token is provided the first page is returned.\n  continuation_token?: string;\n  // Chunk size\n  chunk_size: number;\n};\n\nexport type EMITTED_EVENT = EVENT & {\n  block_hash: BLOCK_HASH;\n  block_number: BLOCK_NUMBER;\n  transaction_hash: TXN_HASH;\n};\n\nexport type EVENT = {\n  from_address: ADDRESS;\n} & EVENT_CONTENT;\n\nexport type EVENT_CONTENT = {\n  keys: FELT[];\n  data: FELT[];\n};\n\nexport type EVENT_FILTER = {\n  from_block?: BLOCK_ID;\n  to_block?: BLOCK_ID;\n  address?: ADDRESS;\n  keys?: FELT[][];\n};\n\nexport type BLOCK_ID =\n  | {\n      block_hash?: BLOCK_HASH;\n      block_number?: BLOCK_NUMBER;\n    }\n  | BLOCK_TAG;\n\nexport type SYNC_STATUS = {\n  starting_block_hash: BLOCK_HASH;\n  starting_block_num: BLOCK_NUMBER;\n  current_block_hash: BLOCK_HASH;\n  current_block_num: BLOCK_NUMBER;\n  highest_block_hash: BLOCK_HASH;\n  highest_block_num: BLOCK_NUMBER;\n};\n\nexport type NEW_CLASSES = {\n  class_hash: FELT;\n  compiled_class_hash: FELT;\n};\n\nexport type REPLACED_CLASS = {\n  class_hash: FELT;\n  contract_address: FELT;\n};\n\nexport type NONCE_UPDATE = {\n  contract_address: ADDRESS;\n  nonce: FELT;\n};\n\nexport type STATE_DIFF = {\n  storage_diffs: CONTRACT_STORAGE_DIFF_ITEM[];\n  deprecated_declared_classes: FELT[];\n  declared_classes: NEW_CLASSES[];\n  deployed_contracts: DEPLOYED_CONTRACT_ITEM[];\n  replaced_classes: REPLACED_CLASS[];\n  nonces: NONCE_UPDATE[];\n};\n\nexport type PENDING_STATE_UPDATE = {\n  old_root: FELT;\n  state_diff: STATE_DIFF;\n  block_hash: never; // diverge: this makes it distinct\n};\n\nexport type STATE_UPDATE = {\n  block_hash: BLOCK_HASH;\n  old_root: FELT;\n  new_root: FELT;\n  state_diff: STATE_DIFF;\n};\n\nexport type BLOCK_BODY_WITH_TX_HASHES = {\n  transactions: TXN_HASH[];\n};\n\nexport type BLOCK_BODY_WITH_TXS = {\n  transactions: (TXN & {\n    transaction_hash: TXN_HASH;\n  })[];\n};\n\nexport type BLOCK_HEADER = {\n  block_hash: BLOCK_HASH;\n  parent_hash: BLOCK_HASH;\n  block_number: BLOCK_NUMBER;\n  new_root: FELT;\n  timestamp: number;\n  sequencer_address: FELT;\n  l1_gas_price: RESOURCE_PRICE;\n  starknet_version: string;\n};\n\nexport type PENDING_BLOCK_HEADER = {\n  parent_hash: BLOCK_HASH;\n  timestamp: number;\n  sequencer_address: FELT;\n  l1_gas_price: RESOURCE_PRICE;\n  starknet_version: string;\n};\n\nexport type BLOCK_WITH_TX_HASHES = { status: BLOCK_STATUS } & BLOCK_HEADER &\n  BLOCK_BODY_WITH_TX_HASHES;\n\nexport type BLOCK_WITH_TXS = { status: BLOCK_STATUS } & BLOCK_HEADER & BLOCK_BODY_WITH_TXS;\n\nexport type PENDING_BLOCK_WITH_TX_HASHES = BLOCK_BODY_WITH_TX_HASHES & PENDING_BLOCK_HEADER;\n\nexport type PENDING_BLOCK_WITH_TXS = BLOCK_BODY_WITH_TXS & PENDING_BLOCK_HEADER;\n\nexport type DEPLOYED_CONTRACT_ITEM = {\n  address: FELT;\n  class_hash: FELT;\n};\n\nexport type CONTRACT_STORAGE_DIFF_ITEM = {\n  // The contract address for which the storage changed (in FELT format)\n  address: string;\n  // The changes in the storage of the contract\n  storage_entries: StorageDiffItem[];\n};\n\nexport type StorageDiffItem = {\n  // The key of the changed value (in FELT format)\n  key: string;\n  // The new value applied to the given address (in FELT format)\n  value: string;\n};\n\nexport type TXN = INVOKE_TXN | L1_HANDLER_TXN | DECLARE_TXN | DEPLOY_TXN | DEPLOY_ACCOUNT_TXN;\n\nexport type DECLARE_TXN = DECLARE_TXN_V0 | DECLARE_TXN_V1 | DECLARE_TXN_V2 | DECLARE_TXN_V3;\n\nexport type DECLARE_TXN_V0 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  max_fee: FELT;\n  version: '0x0' | '0x100000000000000000000000000000000';\n  signature: SIGNATURE;\n  class_hash: FELT;\n};\n\nexport type DECLARE_TXN_V1 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  max_fee: FELT;\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n  class_hash: FELT;\n};\n\nexport type DECLARE_TXN_V2 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  max_fee: FELT;\n  version: '0x2' | '0x100000000000000000000000000000002';\n  signature: SIGNATURE;\n  nonce: FELT;\n  class_hash: FELT;\n};\n\nexport type DECLARE_TXN_V3 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  class_hash: FELT;\n  // new...\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  account_deployment_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type BROADCASTED_TXN =\n  | BROADCASTED_INVOKE_TXN\n  | BROADCASTED_DECLARE_TXN\n  | BROADCASTED_DEPLOY_ACCOUNT_TXN;\n\nexport type BROADCASTED_INVOKE_TXN = INVOKE_TXN;\n\nexport type BROADCASTED_DEPLOY_ACCOUNT_TXN = DEPLOY_ACCOUNT_TXN;\n\nexport type BROADCASTED_DECLARE_TXN =\n  | BROADCASTED_DECLARE_TXN_V1\n  | BROADCASTED_DECLARE_TXN_V2\n  | BROADCASTED_DECLARE_TXN_V3;\n\nexport type BROADCASTED_DECLARE_TXN_V1 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  max_fee: FELT;\n  // todo: check if working, prev i fixed it with NUM_AS_HEX\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_class: DEPRECATED_CONTRACT_CLASS;\n};\n\nexport type BROADCASTED_DECLARE_TXN_V2 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  max_fee: FELT;\n  version: '0x2' | '0x100000000000000000000000000000002';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_class: CONTRACT_CLASS;\n};\n\nexport type BROADCASTED_DECLARE_TXN_V3 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_class: CONTRACT_CLASS;\n  // new...\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  account_deployment_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type DEPLOY_ACCOUNT_TXN = DEPLOY_ACCOUNT_TXN_V1 | DEPLOY_ACCOUNT_TXN_V3;\n\nexport type DEPLOY_ACCOUNT_TXN_V1 = {\n  type: 'DEPLOY_ACCOUNT';\n  max_fee: FELT;\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_address_salt: FELT;\n  constructor_calldata: FELT[];\n  class_hash: FELT;\n};\n\nexport type DEPLOY_ACCOUNT_TXN_V3 = {\n  type: 'DEPLOY_ACCOUNT';\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_address_salt: FELT;\n  constructor_calldata: FELT[];\n  class_hash: FELT;\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type DEPLOY_TXN = {\n  type: 'DEPLOY';\n  version: FELT;\n  contract_address_salt: FELT;\n  constructor_calldata: FELT[];\n  class_hash: FELT;\n};\n\nexport type INVOKE_TXN = INVOKE_TXN_V0 | INVOKE_TXN_V1 | INVOKE_TXN_V3;\n\nexport type INVOKE_TXN_V0 = {\n  type: 'INVOKE';\n  max_fee: FELT;\n  version: '0x0' | '0x100000000000000000000000000000000';\n  signature: SIGNATURE;\n  contract_address: ADDRESS;\n  entry_point_selector: FELT;\n  calldata: FELT[];\n};\n\nexport type INVOKE_TXN_V1 = {\n  type: 'INVOKE';\n  sender_address: ADDRESS;\n  calldata: FELT[];\n  max_fee: FELT;\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n};\n\nexport type INVOKE_TXN_V3 = {\n  type: 'INVOKE';\n  sender_address: ADDRESS;\n  calldata: FELT[];\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  account_deployment_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type L1_HANDLER_TXN = {\n  version: FELT;\n  type: 'L1_HANDLER';\n  nonce: NUM_AS_HEX;\n} & FUNCTION_CALL;\n\nexport type COMMON_RECEIPT_PROPERTIES = {\n  transaction_hash: TXN_HASH;\n  actual_fee: FEE_PAYMENT;\n  execution_status: TXN_EXECUTION_STATUS;\n  finality_status: TXN_FINALITY_STATUS;\n  block_hash: BLOCK_HASH;\n  block_number: BLOCK_NUMBER;\n  messages_sent: MSG_TO_L1[];\n  revert_reason?: string;\n  events: EVENT[];\n  execution_resources: EXECUTION_RESOURCES;\n};\n\nexport type PENDING_COMMON_RECEIPT_PROPERTIES = {\n  transaction_hash: TXN_HASH;\n  actual_fee: FEE_PAYMENT;\n  messages_sent: MSG_TO_L1[];\n  events: EVENT[];\n  revert_reason?: string;\n  finality_status: 'ACCEPTED_ON_L2';\n  execution_status: TXN_EXECUTION_STATUS;\n  execution_resources: EXECUTION_RESOURCES;\n};\n\nexport type INVOKE_TXN_RECEIPT = {\n  type: 'INVOKE';\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type PENDING_INVOKE_TXN_RECEIPT = {\n  type: 'INVOKE';\n} & PENDING_COMMON_RECEIPT_PROPERTIES;\n\nexport type DECLARE_TXN_RECEIPT = {\n  type: 'DECLARE';\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type PENDING_DECLARE_TXN_RECEIPT = {\n  type: 'DECLARE';\n} & PENDING_COMMON_RECEIPT_PROPERTIES;\n\nexport type DEPLOY_ACCOUNT_TXN_RECEIPT = {\n  type: 'DEPLOY_ACCOUNT';\n  contract_address: FELT;\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT = {\n  type: 'DEPLOY_ACCOUNT';\n  contract_address: FELT;\n} & PENDING_COMMON_RECEIPT_PROPERTIES;\n\nexport type DEPLOY_TXN_RECEIPT = {\n  type: 'DEPLOY';\n  contract_address: FELT;\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type L1_HANDLER_TXN_RECEIPT = {\n  type: 'L1_HANDLER';\n  message_hash: NUM_AS_HEX;\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type PENDING_L1_HANDLER_TXN_RECEIPT = {\n  type: 'L1_HANDLER';\n  message_hash: NUM_AS_HEX;\n} & PENDING_COMMON_RECEIPT_PROPERTIES;\n\nexport type TXN_RECEIPT =\n  | INVOKE_TXN_RECEIPT\n  | L1_HANDLER_TXN_RECEIPT\n  | DECLARE_TXN_RECEIPT\n  | DEPLOY_TXN_RECEIPT\n  | DEPLOY_ACCOUNT_TXN_RECEIPT;\n\nexport type PENDING_TXN_RECEIPT =\n  | PENDING_INVOKE_TXN_RECEIPT\n  | PENDING_L1_HANDLER_TXN_RECEIPT\n  | PENDING_DECLARE_TXN_RECEIPT\n  | PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT;\n\nexport type MSG_TO_L1 = {\n  from_address: FELT;\n  to_address: FELT;\n  payload: FELT[];\n};\n\nexport type MSG_FROM_L1 = {\n  from_address: ETH_ADDRESS;\n  to_address: ADDRESS;\n  entry_point_selector: FELT;\n  payload: FELT[];\n};\n\nexport type FUNCTION_CALL = {\n  contract_address: ADDRESS;\n  entry_point_selector: FELT;\n  calldata: FELT[];\n};\n\nexport type CONTRACT_CLASS = {\n  sierra_program: FELT[];\n  contract_class_version: string;\n  entry_points_by_type: {\n    CONSTRUCTOR: SIERRA_ENTRY_POINT[];\n    EXTERNAL: SIERRA_ENTRY_POINT[];\n    L1_HANDLER: SIERRA_ENTRY_POINT[];\n  };\n  abi: string;\n};\n\nexport type DEPRECATED_CONTRACT_CLASS = {\n  program: string;\n  entry_points_by_type: {\n    CONSTRUCTOR: DEPRECATED_CAIRO_ENTRY_POINT[];\n    EXTERNAL: DEPRECATED_CAIRO_ENTRY_POINT[];\n    L1_HANDLER: DEPRECATED_CAIRO_ENTRY_POINT[];\n  };\n  abi: CONTRACT_ABI;\n};\n\nexport type DEPRECATED_CAIRO_ENTRY_POINT = {\n  offset: NUM_AS_HEX | number;\n  selector: FELT;\n};\n\nexport type SIERRA_ENTRY_POINT = {\n  selector: FELT;\n  function_idx: number;\n};\n\nexport type CONTRACT_ABI = readonly CONTRACT_ABI_ENTRY[];\n\nexport type CONTRACT_ABI_ENTRY = {\n  selector: FELT;\n  input: string;\n  output: string;\n};\n\nexport type STRUCT_ABI_ENTRY = {\n  type: STRUCT_ABI_TYPE;\n  name: string;\n  size: number;\n  members: STRUCT_MEMBER[];\n};\n\nexport type STRUCT_MEMBER = TYPED_PARAMETER & {\n  offset: number;\n};\n\nexport type EVENT_ABI_ENTRY = {\n  type: EVENT_ABI_TYPE;\n  name: string;\n  keys: TYPED_PARAMETER[];\n  data: TYPED_PARAMETER[];\n};\n\nexport type FUNCTION_STATE_MUTABILITY = 'view';\n\nexport type FUNCTION_ABI_ENTRY = {\n  type: FUNCTION_ABI_TYPE;\n  name: string;\n  inputs: TYPED_PARAMETER[];\n  outputs: TYPED_PARAMETER[];\n  stateMutability: FUNCTION_STATE_MUTABILITY;\n};\n\nexport type TYPED_PARAMETER = {\n  name: string;\n  type: string;\n};\n\nexport type SIMULATION_FLAG_FOR_ESTIMATE_FEE = 'SKIP_VALIDATE';\nexport type PRICE_UNIT = 'WEI' | 'FRI';\n\nexport type FEE_ESTIMATE = {\n  gas_consumed: FELT;\n  gas_price: FELT;\n  overall_fee: FELT;\n  unit: PRICE_UNIT;\n};\n\nexport type FEE_PAYMENT = {\n  amount: FELT;\n  unit: PRICE_UNIT;\n};\n\nexport type RESOURCE_BOUNDS_MAPPING = {\n  l1_gas: RESOURCE_BOUNDS;\n  l2_gas: RESOURCE_BOUNDS;\n};\n\nexport type RESOURCE_BOUNDS = {\n  max_amount: u64;\n  max_price_per_unit: u128;\n};\n\nexport type RESOURCE_PRICE = {\n  price_in_fri: FELT;\n  price_in_wei: FELT;\n};\n\nexport type EXECUTION_RESOURCES = {\n  steps: number;\n  memory_holes?: number;\n  range_check_builtin_applications?: number;\n  pedersen_builtin_applications?: number;\n  poseidon_builtin_applications?: number;\n  ec_op_builtin_applications?: number;\n  ecdsa_builtin_applications?: number;\n  bitwise_builtin_applications?: number;\n  keccak_builtin_applications?: number;\n  segment_arena_builtin?: number;\n};\n\n/**\n * TRACE API\n */\n\n// Represents a transaction trace including the execution details.\nexport type TRANSACTION_TRACE = {\n  invoke_tx_trace?: INVOKE_TXN_TRACE;\n  declare_tx_trace?: DECLARE_TXN_TRACE;\n  deploy_account_tx_trace?: DEPLOY_ACCOUNT_TXN_TRACE;\n  l1_handler_tx_trace?: L1_HANDLER_TXN_TRACE;\n};\n\n// Represents a transaction trace for an invoke transaction.\nexport type INVOKE_TXN_TRACE = {\n  type: 'INVOKE';\n  execute_invocation: FUNCTION_INVOCATION | { revert_reason: string };\n  validate_invocation?: FUNCTION_INVOCATION;\n  fee_transfer_invocation?: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a transaction trace for a declare transaction.\nexport type DECLARE_TXN_TRACE = {\n  type: 'DECLARE';\n  validate_invocation?: FUNCTION_INVOCATION;\n  fee_transfer_invocation?: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a transaction trace for a deploy account transaction.\nexport type DEPLOY_ACCOUNT_TXN_TRACE = {\n  type: 'DEPLOY_ACCOUNT';\n  constructor_invocation: FUNCTION_INVOCATION;\n  validate_invocation?: FUNCTION_INVOCATION;\n  fee_transfer_invocation?: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a transaction trace for an L1 handler transaction.\nexport type L1_HANDLER_TXN_TRACE = {\n  type: 'L1_HANDLER';\n  function_invocation: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a nested function call.\nexport type NESTED_CALL = FUNCTION_INVOCATION;\n\n// Represents a function invocation along with its execution details.\nexport type FUNCTION_INVOCATION = FUNCTION_CALL & {\n  caller_address: string;\n  class_hash: string;\n  entry_point_type: ENTRY_POINT_TYPE;\n  call_type: CALL_TYPE;\n  result: string[];\n  calls: NESTED_CALL[];\n  events: ORDERED_EVENT[];\n  messages: ORDERED_MESSAGE[];\n  execution_resources: EXECUTION_RESOURCES;\n};\n\n// Represents an ordered event alongside its order within the transaction.\nexport type ORDERED_EVENT = {\n  order: number;\n  event: EVENT;\n};\n\n// Represents an ordered message alongside its order within the transaction.\nexport type ORDERED_MESSAGE = {\n  order: number;\n  message: MSG_TO_L1;\n};\n","/**\n * Types that are not in spec but required for UX\n */\nimport {\n  ADDRESS,\n  BLOCK_HASH,\n  BLOCK_NUMBER,\n  BLOCK_WITH_TXS,\n  BLOCK_WITH_TX_HASHES,\n  BROADCASTED_TXN,\n  CHAIN_ID,\n  CONTRACT_CLASS,\n  CONTRACT_STORAGE_DIFF_ITEM,\n  DEPRECATED_CONTRACT_CLASS,\n  EMITTED_EVENT,\n  EVENT,\n  EVENTS_CHUNK,\n  EVENT_FILTER,\n  FEE_ESTIMATE,\n  FEE_PAYMENT,\n  FELT,\n  MSG_FROM_L1,\n  NONCE_UPDATE,\n  PENDING_BLOCK_WITH_TXS,\n  PENDING_BLOCK_WITH_TX_HASHES,\n  PENDING_STATE_UPDATE,\n  PENDING_TXN_RECEIPT,\n  PRICE_UNIT,\n  REPLACED_CLASS,\n  RESOURCE_BOUNDS_MAPPING,\n  RESULT_PAGE_REQUEST,\n  SIMULATION_FLAG,\n  STATE_UPDATE,\n  SYNC_STATUS,\n  TRANSACTION_TRACE,\n  TXN,\n  TXN_EXECUTION_STATUS,\n  TXN_HASH,\n  TXN_RECEIPT,\n  TXN_STATUS,\n} from './components';\n\n// METHOD RESPONSES\n// response starknet_getClass\nexport type ContractClass = CONTRACT_CLASS | DEPRECATED_CONTRACT_CLASS;\n// response starknet_simulateTransactions\nexport type SimulateTransaction = {\n  transaction_trace: TRANSACTION_TRACE;\n  fee_estimation: FEE_ESTIMATE;\n};\nexport type SimulateTransactionResponse = SimulateTransaction[];\n// response starknet_estimateFee\nexport type FeeEstimate = FEE_ESTIMATE;\n// response starknet_getTransactionByHash, starknet_getTransactionByBlockIdAndIndex\nexport type TransactionWithHash = TXN & { transaction_hash: TXN_HASH };\n// response starknet_blockHashAndNumber\nexport type BlockHashAndNumber = { block_hash: BLOCK_HASH; block_number: BLOCK_NUMBER };\n// response starknet_getBlockWithTxs\nexport type BlockWithTxs = BLOCK_WITH_TXS | PENDING_BLOCK_WITH_TXS;\n// response starknet_getBlockWithTxHashes\nexport type BlockWithTxHashes = BLOCK_WITH_TX_HASHES | PENDING_BLOCK_WITH_TX_HASHES;\n// response starknet_getStateUpdate\nexport type StateUpdate = STATE_UPDATE | PENDING_STATE_UPDATE;\n// response starknet_traceBlockTransactions\nexport type BlockTransactionsTraces = { transaction_hash: FELT; trace_root: TRANSACTION_TRACE }[];\n// response starknet_syncing\nexport type Syncing = false | SYNC_STATUS;\n// response starknet_getEvents\nexport type Events = EVENTS_CHUNK;\nexport type EmittedEvent = EMITTED_EVENT;\nexport type Event = EVENT;\n// response starknet_addInvokeTransaction\nexport type InvokedTransaction = { transaction_hash: TXN_HASH };\n// response starknet_addDeclareTransaction\nexport type DeclaredTransaction = { transaction_hash: TXN_HASH; class_hash: FELT };\n// response starknet_addDeployAccountTransaction\nexport type DeployedAccountTransaction = { transaction_hash: TXN_HASH; contract_address: FELT };\n\n// Nice Components names\nexport type ContractAddress = ADDRESS;\nexport type Felt = FELT;\nexport type Nonce = FELT;\nexport type TransactionHash = TXN_HASH;\nexport type TransactionTrace = TRANSACTION_TRACE;\nexport type BlockHash = BLOCK_HASH;\nexport type TransactionReceipt = TXN_RECEIPT | PENDING_TXN_RECEIPT;\nexport type Receipt = TXN_RECEIPT;\nexport type PendingReceipt = PENDING_TXN_RECEIPT;\nexport type EventFilter = EVENT_FILTER & RESULT_PAGE_REQUEST;\nexport type SimulationFlags = Array<SIMULATION_FLAG>;\nexport type L1Message = MSG_FROM_L1;\nexport type BaseTransaction = BROADCASTED_TXN;\nexport type ChainId = CHAIN_ID;\nexport type Transaction = TXN;\nexport type TransactionStatus = {\n  finality_status: TXN_STATUS;\n  execution_status?: TXN_EXECUTION_STATUS;\n};\nexport type ResourceBounds = RESOURCE_BOUNDS_MAPPING;\nexport type FeePayment = FEE_PAYMENT;\nexport type PriceUnit = PRICE_UNIT;\n\n// Diff Than Seq\nexport type StorageDiffs = Array<CONTRACT_STORAGE_DIFF_ITEM>;\nexport type DeprecatedDeclaredClasses = Array<FELT>;\nexport type NonceUpdates = NONCE_UPDATE[];\nexport type ReplacedClasses = REPLACED_CLASS[];\n\n// Enums Derived From Spec Types (require manual check for changes)\nexport enum ETransactionType {\n  DECLARE = 'DECLARE',\n  DEPLOY = 'DEPLOY',\n  DEPLOY_ACCOUNT = 'DEPLOY_ACCOUNT',\n  INVOKE = 'INVOKE',\n  L1_HANDLER = 'L1_HANDLER',\n}\n\nexport enum ESimulationFlag {\n  SKIP_VALIDATE = 'SKIP_VALIDATE',\n  SKIP_FEE_CHARGE = 'SKIP_FEE_CHARGE',\n}\n\nexport enum ETransactionStatus {\n  RECEIVED = 'RECEIVED',\n  REJECTED = 'REJECTED',\n  ACCEPTED_ON_L2 = 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1 = 'ACCEPTED_ON_L1',\n}\n\nexport enum ETransactionFinalityStatus {\n  ACCEPTED_ON_L2 = 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1 = 'ACCEPTED_ON_L1',\n}\n\nexport enum ETransactionExecutionStatus {\n  SUCCEEDED = 'SUCCEEDED',\n  REVERTED = 'REVERTED',\n}\n\nexport enum EBlockTag {\n  PENDING = 'pending',\n  LATEST = 'latest',\n}\n\n// 'L1' | 'L2'\nexport enum EDataAvailabilityMode {\n  L1 = 'L1',\n  L2 = 'L2',\n}\n\n// 0 | 1\nexport enum EDAMode {\n  L1,\n  L2,\n}\n\n/**\n * V_ Transaction versions HexString\n * F_ Fee Transaction Versions HexString (2 ** 128 + TRANSACTION_VERSION)\n */\nexport enum ETransactionVersion {\n  V0 = '0x0',\n  V1 = '0x1',\n  V2 = '0x2',\n  V3 = '0x3',\n  F0 = '0x100000000000000000000000000000000',\n  F1 = '0x100000000000000000000000000000001',\n  F2 = '0x100000000000000000000000000000002',\n  F3 = '0x100000000000000000000000000000003',\n}\n\n/**\n * Old Transaction Versions\n */\nexport enum ETransactionVersion2 {\n  V0 = '0x0',\n  V1 = '0x1',\n  V2 = '0x2',\n  F0 = '0x100000000000000000000000000000000',\n  F1 = '0x100000000000000000000000000000001',\n  F2 = '0x100000000000000000000000000000002',\n}\n\n/**\n * V3 Transaction Versions\n */\nexport enum ETransactionVersion3 {\n  V3 = '0x3',\n  F3 = '0x100000000000000000000000000000003',\n}\n","import { base64 } from '@scure/base';\n\n/* eslint-disable no-param-reassign */\nexport const IS_BROWSER = typeof window !== 'undefined';\n\nconst STRING_ZERO = '0';\n\n/**\n * Some functions recreated from https://github.com/pedrouid/enc-utils/blob/master/src/index.ts\n * enc-utils is not a dependency to avoid using `Buffer` which only works in node and not browsers\n */\n\n/**\n * Convert array buffer to string\n *\n * *[internal usage]*\n *\n * @param {ArrayBuffer} array The ArrayBuffer to convert to string.\n * @returns {string} The converted string.\n *\n * @example\n * ```typescript\n * const buffer = new ArrayBuffer(5);\n * const view = new Uint8Array(buffer);\n * [72, 101, 108, 108, 111].forEach((x, idx) => view[idx] = x);\n * const result = encode.arrayBufferToString(buffer);\n * // result = \"Hello\"\n * ```\n */\nexport function arrayBufferToString(array: ArrayBuffer): string {\n  return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), '');\n}\n\n/**\n * Convert utf8-string to Uint8Array\n *\n * *[internal usage]*\n *\n * @param {string} str The UTF-8 string to convert.\n * @returns {Uint8Array} The encoded Uint8Array.\n *\n * @example\n * ```typescript\n * const myString = 'Hi';\n * const result = encode.utf8ToArray(myString);\n * // result = Uint8Array(2) [ 72, 105 ]\n * ```\n */\nexport function utf8ToArray(str: string): Uint8Array {\n  return new TextEncoder().encode(str);\n}\n\n/**\n * Convert utf8-string to Uint8Array\n *\n * @deprecated equivalent to 'utf8ToArray', alias will be removed\n */\nexport function stringToArrayBuffer(str: string): Uint8Array {\n  return utf8ToArray(str);\n}\n\n/**\n * Convert string to array buffer (browser and node compatible)\n *\n * @param {string} a The Base64 encoded string to convert.\n * @returns {Uint8Array} The decoded Uint8Array.\n *\n * @example\n * ```typescript\n * const base64String = 'SGVsbG8='; // 'Hello' in Base64\n * const result = encode.atobUniversal(base64String);\n * // result = Uint8Array(5) [ 72, 101, 108, 108, 111 ]\n * ```\n */\nexport function atobUniversal(a: string): Uint8Array {\n  return base64.decode(a);\n}\n\n/**\n * Convert array buffer to string (browser and node compatible)\n *\n * @param {ArrayBuffer} b The Array buffer.\n * @returns {string} The Base64 encoded string.\n *\n * @example\n * ```typescript\n * const buffer = new Uint8Array([72, 101, 108, 108, 111]); // Array with ASCII values for 'Hello'\n * const result = encode.btoaUniversal(buffer);\n * // result = \"SGVsbG8=\"\n * ```\n */\nexport function btoaUniversal(b: ArrayBuffer): string {\n  return base64.encode(new Uint8Array(b));\n}\n\n/**\n * Convert array buffer to hex-string\n *\n * @param {Uint8Array} buffer The encoded Uint8Array.\n * @returns {string} The hex-string\n *\n * @example\n * ```typescript\n * const buffer = new Uint8Array([72, 101, 108, 108, 111]); // Array with ASCII values for 'Hello'\n * const result = encode.buf2hex(buffer);\n * // result = \"48656c6c6f\"\n * ```\n */\nexport function buf2hex(buffer: Uint8Array) {\n  return buffer.reduce((r, x) => r + x.toString(16).padStart(2, '0'), '');\n}\n\n/**\n * Remove hex prefix '0x' from hex-string\n * @param hex hex-string\n * @returns {string} The hex-string\n *\n * @example\n * ```typescript\n * const hexStringWithPrefix = '0x48656c6c6f';\n * const result = encode.removeHexPrefix(hexStringWithPrefix);\n * // result: \"48656c6c6f\"\n * ```\n */\nexport function removeHexPrefix(hex: string): string {\n  return hex.replace(/^0x/i, '');\n}\n\n/**\n * Add hex prefix '0x' to base16-string\n * @param hex base16-string\n * @returns {string} The hex-string\n *\n * @example\n * ```typescript\n * const plainHexString = '48656c6c6f';\n * const result = encode.addHexPrefix(plainHexString);\n * // result: \"0x48656c6c6f\"\n * ```\n */\nexport function addHexPrefix(hex: string): string {\n  return `0x${removeHexPrefix(hex)}`;\n}\n\n/**\n * Prepend or append to string\n *\n * *[internal usage]*\n *\n * Pads a string to a certain length with a specific string.\n * The padding can be applied either to the left or the right of the input string.\n *\n * @param {string} str The string to pad.\n * @param {number} length The target length for the padded string.\n * @param {boolean} left Set to true to add padding to the left, false to add it to the right.\n * @param {string} [padding='0'] The string to use for padding. Defaults to '0'.\n * @returns {string} The padded string.\n *\n * @example\n * ```typescript\n * const myString = 'hello';\n * const result = padString(myString, 10, true);\n * // result = '00000hello'\n * ```\n */\nfunction padString(str: string, length: number, left: boolean, padding = STRING_ZERO): string {\n  const diff = length - str.length;\n  let result = str;\n  if (diff > 0) {\n    const pad = padding.repeat(diff);\n    result = left ? pad + str : str + pad;\n  }\n  return result;\n}\n\n/**\n * Prepend string (default with '0')\n *\n * Pads a string to a certain length with a specific string.\n * The padding can be applied only to the left of the input string.\n *\n * @param {string} str The string to pad.\n * @param {number} length The target length for the padded string.\n * @param {string} [padding='0'] The string to use for padding. Defaults to '0'.\n * @returns {string} The padded string.\n *\n * @example\n * ```typescript\n * const myString = '1A3F';\n * const result = encode.padLeft(myString, 10);\n * // result: '0000001A3F'\n * ```\n */\nexport function padLeft(str: string, length: number, padding = STRING_ZERO): string {\n  return padString(str, length, true, padding);\n}\n\n/**\n * Calculate byte length of string\n *\n * *[no internal usage]*\n *\n * Calculates the byte length of a string based on a specified byte size.\n * The function rounds up the byte count to the nearest multiple of the specified byte size.\n *\n * @param {string} str The string whose byte length is to be calculated.\n * @param {number} [byteSize='8'] The size of the byte block to round up to. Defaults to 8.\n * @returns {number} The calculated byte length, rounded to the nearest multiple of byteSize.\n *\n * @example\n * ```typescript\n * const myString = 'Hello';\n * const result = encode.calcByteLength(myString, 4);\n * // result = 8 (rounded up to the nearest multiple of 4)\n *\n * ```\n */\nexport function calcByteLength(str: string, byteSize = 8): number {\n  const { length } = str;\n  const remainder = length % byteSize;\n  return remainder ? ((length - remainder) / byteSize) * byteSize + byteSize : length;\n}\n\n/**\n * Prepend '0' to string bytes\n *\n * *[no internal usage]*\n *\n *\n * * Prepends padding to the left of a string to ensure it matches a specific byte length.\n * The function uses a specified padding character and rounds up the string length to the nearest multiple of `byteSize`.\n *\n * @param {string} str The string to be padded.\n * @param {number} [byteSize='8'] The byte block size to which the string length should be rounded up. Defaults to 8.\n * @param {string} [padding='0'] The character to use for padding. Defaults to '0'.\n * @returns {string} The padded string.\n *\n * @example\n * ```typescript\n * const myString = '123';\n * const result = encode.sanitizeBytes(myString);\n * // result: '00000123' (padded to 8 characters)\n * ```\n */\nexport function sanitizeBytes(str: string, byteSize = 8, padding = STRING_ZERO): string {\n  return padLeft(str, calcByteLength(str, byteSize), padding);\n}\n\n/**\n * Sanitizes a hex-string by removing any existing '0x' prefix, padding the string with '0' to ensure it has even length,\n * and then re-adding the '0x' prefix.\n *\n * *[no internal usage]*\n * @param hex hex-string\n * @returns format: hex-string\n *\n * @example\n * ```typescript\n * const unevenHex = '0x23abc';\n * const result = encode.sanitizeHex(unevenHex);\n * // result = '0x023abc' (padded to ensure even length)\n * ```\n */\nexport function sanitizeHex(hex: string): string {\n  hex = removeHexPrefix(hex);\n  hex = sanitizeBytes(hex, 2);\n  if (hex) {\n    hex = addHexPrefix(hex);\n  }\n  return hex;\n}\n\n/**\n * String transformation util\n *\n * Pascal case to screaming snake case\n *\n * @param {string} text The PascalCase string to convert.\n * @returns {string} The converted snake_case string in uppercase.\n *\n * @example\n * ```typescript\n * const pascalString = 'PascalCaseExample';\n * const result = encode.pascalToSnake(pascalString);\n * // result: 'PASCAL_CASE_EXAMPLE'\n * ```\n */\nexport const pascalToSnake = (text: string) =>\n  /[a-z]/.test(text)\n    ? text\n        .split(/(?=[A-Z])/)\n        .join('_')\n        .toUpperCase()\n    : text;\n","import { bytesToHex } from '@noble/curves/abstract/utils';\nimport { keccak_256 } from '@noble/hashes/sha3';\nimport type { SPEC } from 'starknet-types-07';\n\nimport { RPC06, RPC07, RpcChannel } from '../channel';\nimport {\n  AccountInvocations,\n  BigNumberish,\n  Block,\n  BlockIdentifier,\n  BlockTag,\n  Call,\n  ContractClassResponse,\n  ContractVersion,\n  DeclareContractTransaction,\n  DeployAccountContractTransaction,\n  GetBlockResponse,\n  GetTxReceiptResponseWithoutHelper,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  PendingBlock,\n  PendingStateUpdate,\n  RPC,\n  RpcProviderOptions,\n  StateUpdate,\n  StateUpdateResponse,\n  TransactionType,\n  getContractVersionOptions,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  waitForTransactionOptions,\n} from '../types';\nimport type { TransactionWithHash } from '../types/provider/spec';\nimport assert from '../utils/assert';\nimport { getAbiContractVersion } from '../utils/calldata/cairo';\nimport { isSierra } from '../utils/contract';\nimport { addHexPrefix, removeHexPrefix } from '../utils/encode';\nimport { hexToBytes, toHex } from '../utils/num';\nimport { wait } from '../utils/provider';\nimport { RPCResponseParser } from '../utils/responseParser/rpc';\nimport { GetTransactionReceiptResponse, ReceiptTx } from '../utils/transactionReceipt';\nimport { LibraryError } from './errors';\nimport { ProviderInterface } from './interface';\n\nexport class RpcProvider implements ProviderInterface {\n  public responseParser: RPCResponseParser;\n\n  public channel: RPC07.RpcChannel | RPC06.RpcChannel;\n\n  constructor(optionsOrProvider?: RpcProviderOptions | ProviderInterface | RpcProvider) {\n    if (optionsOrProvider && 'channel' in optionsOrProvider) {\n      this.channel = optionsOrProvider.channel;\n      this.responseParser =\n        'responseParser' in optionsOrProvider\n          ? optionsOrProvider.responseParser\n          : new RPCResponseParser();\n    } else {\n      this.channel = new RpcChannel({ ...optionsOrProvider, waitMode: false });\n      this.responseParser = new RPCResponseParser(optionsOrProvider?.feeMarginPercentage);\n    }\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    return this.channel.fetch(method, params, id);\n  }\n\n  public async getChainId() {\n    return this.channel.getChainId();\n  }\n\n  public async getSpecVersion() {\n    return this.channel.getSpecVersion();\n  }\n\n  public async getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ) {\n    return this.channel.getNonceForAddress(contractAddress, blockIdentifier);\n  }\n\n  public async getBlock(): Promise<PendingBlock>;\n  public async getBlock(blockIdentifier: 'pending'): Promise<PendingBlock>;\n  public async getBlock(blockIdentifier: 'latest'): Promise<Block>;\n  public async getBlock(blockIdentifier?: BlockIdentifier): Promise<GetBlockResponse>;\n  public async getBlock(blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getBlockWithTxHashes(blockIdentifier)\n      .then(this.responseParser.parseGetBlockResponse);\n  }\n\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  public async getBlockLatestAccepted() {\n    return this.channel.getBlockLatestAccepted();\n  }\n\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  public async getBlockNumber() {\n    return this.channel.getBlockNumber();\n  }\n\n  public async getBlockWithTxHashes(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier);\n  }\n\n  public async getBlockWithTxs(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockWithTxs(blockIdentifier);\n  }\n\n  /**\n   * Pause the execution of the script until a specified block is created.\n   * @param {BlockIdentifier} blockIdentifier bloc number (BigNumberisk) or 'pending' or 'latest'.\n   * Use of 'latest\" or of a block already created will generate no pause.\n   * @param {number} [retryInterval] number of milliseconds between 2 requests to the node\n   * @example\n   * ```typescript\n   * await myProvider.waitForBlock();\n   * // wait the creation of the pending block\n   * ```\n   */\n  public async waitForBlock(\n    blockIdentifier: BlockIdentifier = 'pending',\n    retryInterval: number = 5000\n  ) {\n    if (blockIdentifier === BlockTag.LATEST) return;\n    const currentBlock = await this.getBlockNumber();\n    const targetBlock =\n      blockIdentifier === BlockTag.PENDING\n        ? currentBlock + 1\n        : Number(toHex(blockIdentifier as BigNumberish));\n    if (targetBlock <= currentBlock) return;\n    const { retries } = this.channel;\n    let retriesCount = retries;\n    let isTargetBlock: boolean = false;\n    while (!isTargetBlock) {\n      // eslint-disable-next-line no-await-in-loop\n      const currBlock = await this.getBlockNumber();\n      if (currBlock === targetBlock) {\n        isTargetBlock = true;\n      } else {\n        // eslint-disable-next-line no-await-in-loop\n        await wait(retryInterval);\n      }\n      retriesCount -= 1;\n      if (retriesCount <= 0) {\n        throw new Error(`waitForBlock() timed-out after ${retries} tries.`);\n      }\n    }\n  }\n\n  public async getL1GasPrice(blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getBlockWithTxHashes(blockIdentifier)\n      .then(this.responseParser.parseL1GasPriceResponse);\n  }\n\n  public async getL1MessageHash(l2TxHash: BigNumberish) {\n    const transaction = (await this.channel.getTransactionByHash(l2TxHash)) as TransactionWithHash;\n    assert(transaction.type === 'L1_HANDLER', 'This L2 transaction is not a L1 message.');\n    const { calldata, contract_address, entry_point_selector, nonce } =\n      transaction as SPEC.L1_HANDLER_TXN;\n    const params = [\n      calldata[0],\n      contract_address,\n      nonce,\n      entry_point_selector,\n      calldata.length - 1,\n      ...calldata.slice(1),\n    ];\n    const myEncode = addHexPrefix(\n      params.reduce(\n        (res: string, par: BigNumberish) => res + removeHexPrefix(toHex(par)).padStart(64, '0'),\n        ''\n      )\n    );\n    return addHexPrefix(bytesToHex(keccak_256(hexToBytes(myEncode))));\n  }\n\n  public async getBlockWithReceipts(blockIdentifier?: BlockIdentifier) {\n    if (this.channel instanceof RPC06.RpcChannel)\n      throw new LibraryError('Unsupported method for RPC version');\n\n    return this.channel.getBlockWithReceipts(blockIdentifier);\n  }\n\n  public getStateUpdate = this.getBlockStateUpdate;\n\n  public async getBlockStateUpdate(): Promise<PendingStateUpdate>;\n  public async getBlockStateUpdate(blockIdentifier: 'pending'): Promise<PendingStateUpdate>;\n  public async getBlockStateUpdate(blockIdentifier: 'latest'): Promise<StateUpdate>;\n  public async getBlockStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;\n  public async getBlockStateUpdate(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockStateUpdate(blockIdentifier);\n  }\n\n  public async getBlockTransactionsTraces(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockTransactionsTraces(blockIdentifier);\n  }\n\n  public async getBlockTransactionCount(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockTransactionCount(blockIdentifier);\n  }\n\n  /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.PENDING); (will be removed in next minor version)\n   * Utility method, same result can be achieved using getBlockWithTxHashes(BlockTag.pending);\n   */\n  public async getPendingTransactions() {\n    const { transactions } = await this.getBlockWithTxHashes(BlockTag.PENDING).then(\n      this.responseParser.parseGetBlockResponse\n    );\n    return Promise.all(transactions.map((it: any) => this.getTransactionByHash(it)));\n  }\n\n  public async getTransaction(txHash: BigNumberish) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n\n  public async getTransactionByHash(txHash: BigNumberish) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n\n  public async getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number) {\n    return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index);\n  }\n\n  public async getTransactionReceipt(txHash: BigNumberish): Promise<GetTransactionReceiptResponse> {\n    const txReceiptWoHelper = await this.channel.getTransactionReceipt(txHash);\n    const txReceiptWoHelperModified: GetTxReceiptResponseWithoutHelper =\n      this.responseParser.parseTransactionReceipt(txReceiptWoHelper);\n    return new ReceiptTx(txReceiptWoHelperModified) as GetTransactionReceiptResponse;\n  }\n\n  public async getTransactionTrace(txHash: BigNumberish) {\n    return this.channel.getTransactionTrace(txHash);\n  }\n\n  /**\n   * Get the status of a transaction\n   */\n  public async getTransactionStatus(transactionHash: BigNumberish) {\n    return this.channel.getTransactionStatus(transactionHash);\n  }\n\n  /**\n   * @param invocations AccountInvocations\n   * @param options blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  public async getSimulateTransaction(\n    invocations: AccountInvocations,\n    options?: getSimulateTransactionOptions\n  ) {\n    // can't be named simulateTransaction because of argument conflict with account\n    return this.channel\n      .simulateTransaction(invocations, options)\n      .then((r) => this.responseParser.parseSimulateTransactionResponse(r));\n  }\n\n  public async waitForTransaction(\n    txHash: BigNumberish,\n    options?: waitForTransactionOptions\n  ): Promise<GetTransactionReceiptResponse> {\n    const receiptWoHelper = (await this.channel.waitForTransaction(\n      txHash,\n      options\n    )) as GetTxReceiptResponseWithoutHelper;\n\n    return new ReceiptTx(receiptWoHelper) as GetTransactionReceiptResponse;\n  }\n\n  public async getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ) {\n    return this.channel.getStorageAt(contractAddress, key, blockIdentifier);\n  }\n\n  public async getClassHashAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier) {\n    return this.channel.getClassHashAt(contractAddress, blockIdentifier);\n  }\n\n  public async getClassByHash(classHash: BigNumberish) {\n    return this.getClass(classHash);\n  }\n\n  public async getClass(classHash: BigNumberish, blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getClass(classHash, blockIdentifier)\n      .then(this.responseParser.parseContractClassResponse);\n  }\n\n  public async getClassAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getClassAt(contractAddress, blockIdentifier)\n      .then(this.responseParser.parseContractClassResponse);\n  }\n\n  public async getContractVersion(\n    contractAddress: BigNumberish,\n    classHash?: undefined,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n  public async getContractVersion(\n    contractAddress: undefined,\n    classHash: BigNumberish,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n\n  public async getContractVersion(\n    contractAddress?: BigNumberish,\n    classHash?: BigNumberish,\n    {\n      blockIdentifier = this.channel.blockIdentifier,\n      compiler = true,\n    }: getContractVersionOptions = {}\n  ): Promise<ContractVersion> {\n    let contractClass: ContractClassResponse;\n    if (contractAddress) {\n      contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n    } else if (classHash) {\n      contractClass = await this.getClass(classHash, blockIdentifier);\n    } else {\n      throw Error('getContractVersion require contractAddress or classHash');\n    }\n\n    if (isSierra(contractClass)) {\n      if (compiler) {\n        const abiTest = getAbiContractVersion(contractClass.abi);\n        return { cairo: '1', compiler: abiTest.compiler };\n      }\n      return { cairo: '1', compiler: undefined };\n    }\n    return { cairo: '0', compiler: '0' };\n  }\n\n  /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */\n  public async getEstimateFee(\n    invocation: Invocation,\n    invocationDetails: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n  }\n\n  public async getInvokeEstimateFee(\n    invocation: Invocation,\n    invocationDetails: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return this.channel\n      .getEstimateFee(\n        [\n          {\n            type: TransactionType.INVOKE,\n            ...invocation,\n            ...invocationDetails,\n          },\n        ],\n        { blockIdentifier, skipValidate }\n      )\n      .then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n\n  public async getDeclareEstimateFee(\n    invocation: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return this.channel\n      .getEstimateFee(\n        [\n          {\n            type: TransactionType.DECLARE,\n            ...invocation,\n            ...details,\n          },\n        ],\n        { blockIdentifier, skipValidate }\n      )\n      .then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n\n  public async getDeployAccountEstimateFee(\n    invocation: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return this.channel\n      .getEstimateFee(\n        [\n          {\n            type: TransactionType.DEPLOY_ACCOUNT,\n            ...invocation,\n            ...details,\n          },\n        ],\n        { blockIdentifier, skipValidate }\n      )\n      .then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n\n  public async getEstimateFeeBulk(\n    invocations: AccountInvocations,\n    options: getEstimateFeeBulkOptions\n  ) {\n    return this.channel\n      .getEstimateFee(invocations, options)\n      .then((r) => this.responseParser.parseFeeEstimateBulkResponse(r));\n  }\n\n  public async invokeFunction(\n    functionInvocation: Invocation,\n    details: InvocationsDetailsWithNonce\n  ) {\n    return this.channel.invoke(functionInvocation, details) as Promise<RPC.InvokedTransaction>;\n  }\n\n  public async declareContract(\n    transaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    return this.channel.declare(transaction, details) as Promise<RPC.DeclaredTransaction>;\n  }\n\n  public async deployAccountContract(\n    transaction: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    return this.channel.deployAccount(\n      transaction,\n      details\n    ) as Promise<RPC.DeployedAccountTransaction>;\n  }\n\n  public async callContract(call: Call, blockIdentifier?: BlockIdentifier) {\n    return this.channel.callContract(call, blockIdentifier);\n  }\n\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  public async estimateMessageFee(message: RPC.L1Message, blockIdentifier?: BlockIdentifier) {\n    return this.channel.estimateMessageFee(message, blockIdentifier);\n  }\n\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  public async getSyncingStats() {\n    return this.channel.getSyncingStats();\n  }\n\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  public async getEvents(eventFilter: RPC.EventFilter) {\n    return this.channel.getEvents(eventFilter);\n  }\n}\n","import { NetworkName, StarknetChainId } from '../constants';\nimport { LibraryError } from '../provider/errors';\nimport {\n  AccountInvocationItem,\n  AccountInvocations,\n  BigNumberish,\n  BlockIdentifier,\n  BlockTag,\n  Call,\n  DeclareContractTransaction,\n  DeployAccountContractTransaction,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  RpcProviderOptions,\n  TransactionType,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  waitForTransactionOptions,\n} from '../types';\nimport { JRPC, RPCSPEC06 as RPC } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { isSierra } from '../utils/contract';\nimport { validateAndParseEthAddress } from '../utils/eth';\nimport fetch from '../utils/fetchPonyfill';\nimport { getSelector, getSelectorFromName } from '../utils/hash';\nimport { stringify } from '../utils/json';\nimport { getHexStringArray, toHex, toStorageKey } from '../utils/num';\nimport { Block, getDefaultNodeUrl, isV3Tx, isVersion, wait } from '../utils/provider';\nimport { decompressProgram, signatureToHexArray } from '../utils/stark';\nimport { getVersionsByType } from '../utils/transaction';\n\nconst defaultOptions = {\n  headers: { 'Content-Type': 'application/json' },\n  blockIdentifier: BlockTag.PENDING,\n  retries: 200,\n};\n\nexport class RpcChannel {\n  public nodeUrl: string;\n\n  public headers: object;\n\n  readonly retries: number;\n\n  public requestId: number;\n\n  readonly blockIdentifier: BlockIdentifier;\n\n  private chainId?: StarknetChainId;\n\n  private specVersion?: string;\n\n  readonly waitMode: Boolean; // behave like web2 rpc and return when tx is processed\n\n  constructor(optionsOrProvider?: RpcProviderOptions) {\n    const { nodeUrl, retries, headers, blockIdentifier, chainId, specVersion, waitMode } =\n      optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl as NetworkName)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl as NetworkName, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(undefined, optionsOrProvider?.default);\n    }\n    this.retries = retries || defaultOptions.retries;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n    this.specVersion = specVersion;\n    this.waitMode = waitMode || false;\n    this.requestId = 0;\n  }\n\n  public setChainId(chainId: StarknetChainId) {\n    this.chainId = chainId;\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    const rpcRequestBody: JRPC.RequestBody = {\n      id,\n      jsonrpc: '2.0',\n      method,\n      ...(params && { params }),\n    };\n    return fetch(this.nodeUrl, {\n      method: 'POST',\n      body: stringify(rpcRequestBody),\n      headers: this.headers as Record<string, string>,\n    });\n  }\n\n  protected errorHandler(method: string, params: any, rpcError?: JRPC.Error, otherError?: any) {\n    if (rpcError) {\n      const { code, message, data } = rpcError;\n      throw new LibraryError(\n        `RPC: ${method} with params ${stringify(params, null, 2)}\\n\n        ${code}: ${message}: ${stringify(data)}`\n      );\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n\n  protected async fetchEndpoint<T extends keyof RPC.Methods>(\n    method: T,\n    params?: RPC.Methods[T]['params']\n  ): Promise<RPC.Methods[T]['result']> {\n    try {\n      const rawResult = await this.fetch(method, params, (this.requestId += 1));\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result as RPC.Methods[T]['result'];\n    } catch (error: any) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n\n  public async getChainId() {\n    this.chainId ??= (await this.fetchEndpoint('starknet_chainId')) as StarknetChainId;\n    return this.chainId;\n  }\n\n  public async getSpecVersion() {\n    this.specVersion ??= (await this.fetchEndpoint('starknet_specVersion')) as StarknetChainId;\n    return this.specVersion;\n  }\n\n  public getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getNonce', {\n      contract_address,\n      block_id,\n    });\n  }\n\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  public getBlockLatestAccepted() {\n    return this.fetchEndpoint('starknet_blockHashAndNumber');\n  }\n\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  public getBlockNumber() {\n    return this.fetchEndpoint('starknet_blockNumber');\n  }\n\n  public getBlockWithTxHashes(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxHashes', { block_id });\n  }\n\n  public getBlockWithTxs(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxs', { block_id });\n  }\n\n  public getBlockStateUpdate(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStateUpdate', { block_id });\n  }\n\n  public getBlockTransactionsTraces(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_traceBlockTransactions', { block_id });\n  }\n\n  public getBlockTransactionCount(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockTransactionCount', { block_id });\n  }\n\n  public getTransactionByHash(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionByHash', {\n      transaction_hash,\n    });\n  }\n\n  public getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getTransactionByBlockIdAndIndex', { block_id, index });\n  }\n\n  public getTransactionReceipt(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionReceipt', { transaction_hash });\n  }\n\n  public getTransactionTrace(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_traceTransaction', { transaction_hash });\n  }\n\n  /**\n   * Get the status of a transaction\n   */\n  public getTransactionStatus(transactionHash: BigNumberish) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint('starknet_getTransactionStatus', { transaction_hash });\n  }\n\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  public simulateTransaction(\n    invocations: AccountInvocations,\n    simulateTransactionOptions: getSimulateTransactionOptions = {}\n  ) {\n    const {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true,\n    } = simulateTransactionOptions;\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags: RPC.ESimulationFlag[] = [];\n    if (skipValidate) simulationFlags.push(RPC.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge) simulationFlags.push(RPC.ESimulationFlag.SKIP_FEE_CHARGE);\n\n    return this.fetchEndpoint('starknet_simulateTransactions', {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags,\n    });\n  }\n\n  public async waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? 5000;\n    const errorStates: any = options?.errorStates ?? [\n      RPC.ETransactionStatus.REJECTED,\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates: any = options?.successStates ?? [\n      RPC.ETransactionExecutionStatus.SUCCEEDED,\n      RPC.ETransactionStatus.ACCEPTED_ON_L2,\n      RPC.ETransactionStatus.ACCEPTED_ON_L1,\n    ];\n\n    let txStatus: RPC.TransactionStatus;\n    while (!onchain) {\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txStatus = await this.getTransactionStatus(transactionHash);\n\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n\n        if (!finalityStatus) {\n          // Transaction is potentially NOT_RECEIVED or RPC not Synced yet\n          // so we will retry '{ retries }' times\n          const error = new Error('waiting for transaction status');\n          throw error;\n        }\n\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message) as Error & { response: RPC.TransactionStatus };\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (\n          successStates.includes(executionStatus) ||\n          successStates.includes(finalityStatus)\n        ) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n\n      retries -= 1;\n    }\n\n    /**\n     * For some nodes even though the transaction has executionStatus SUCCEEDED finalityStatus ACCEPTED_ON_L2, getTransactionReceipt returns \"Transaction hash not found\"\n     * Retry until rpc is actually ready to work with txHash\n     */\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n    }\n    return txReceipt as RPC.SPEC.TXN_RECEIPT;\n  }\n\n  public getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStorageAt', {\n      contract_address,\n      key: parsedKey,\n      block_id,\n    });\n  }\n\n  public getClassHashAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassHashAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public getClass(\n    classHash: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClass', {\n      class_hash,\n      block_id,\n    });\n  }\n\n  public getClassAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public async getEstimateFee(\n    invocations: AccountInvocations,\n    { blockIdentifier = this.blockIdentifier, skipValidate = true }: getEstimateFeeBulkOptions\n  ) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion('0.5', await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [RPC.ESimulationFlag.SKIP_VALIDATE] : [],\n      };\n    } // else v(0.5) no flags\n\n    return this.fetchEndpoint('starknet_estimateFee', {\n      request: invocations.map((it) => this.buildTransaction(it, 'fee')),\n      block_id,\n      ...flags,\n    });\n  }\n\n  public async invoke(functionInvocation: Invocation, details: InvocationsDetailsWithNonce) {\n    let promise;\n    if (!isV3Tx(details)) {\n      // V1\n      promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: RPC.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: RPC.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else {\n      // V3\n      promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n        invoke_transaction: {\n          type: RPC.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async declare(\n    { contract, signature, senderAddress, compiledClassHash }: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      // V1 Cairo 0\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          version: RPC.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      // V2 Cairo1\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          compiled_class_hash: compiledClassHash || '',\n          version: RPC.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      // V3 Cairo1\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || '',\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    } else {\n      throw Error('declare unspotted parameters');\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async deployAccount(\n    { classHash, constructorCalldata, addressSalt, signature }: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (!isV3Tx(details)) {\n      // v1\n      promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: RPC.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else {\n      // v3\n      promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n        deploy_account_transaction: {\n          type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public callContract(call: Call, blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_call', {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata),\n      },\n      block_id,\n    });\n  }\n\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  public estimateMessageFee(\n    message: RPC.L1Message,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload),\n    };\n\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_estimateMessageFee', {\n      message: formattedMessage,\n      block_id,\n    });\n  }\n\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  public getSyncingStats() {\n    return this.fetchEndpoint('starknet_syncing');\n  }\n\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  public getEvents(eventFilter: RPC.EventFilter) {\n    return this.fetchEndpoint('starknet_getEvents', { filter: eventFilter });\n  }\n\n  public buildTransaction(\n    invocation: AccountInvocationItem,\n    versionType?: 'fee' | 'transaction'\n  ): RPC.BaseTransaction {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n\n    if (!isV3Tx(invocation)) {\n      // V0,V1,V2\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0),\n      };\n    } else {\n      // V3\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it)),\n      };\n    }\n\n    if (invocation.type === TransactionType.INVOKE) {\n      return {\n        // v0 v1 v3\n        type: RPC.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details,\n      } as RPC.SPEC.BROADCASTED_INVOKE_TXN;\n    }\n    if (invocation.type === TransactionType.DECLARE) {\n      if (!isSierra(invocation.contract)) {\n        // Cairo 0 - v1\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details,\n        } as RPC.SPEC.BROADCASTED_DECLARE_TXN_V1;\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program),\n        },\n        compiled_class_hash: invocation.compiledClassHash || '',\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details,\n      } as RPC.SPEC.BROADCASTED_DECLARE_TXN;\n    }\n    if (invocation.type === TransactionType.DEPLOY_ACCOUNT) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { account_deployment_data, ...restDetails } = details;\n      // v1 v3\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3) as RPC.SPEC.INVOKE_TXN['version'],\n        ...restDetails,\n      } as RPC.SPEC.BROADCASTED_DEPLOY_ACCOUNT_TXN;\n    }\n    throw Error('RPC buildTransaction received unknown TransactionType');\n  }\n}\n","// eslint-disable-next-line max-classes-per-file\nexport function fixStack(target: Error, fn: Function = target.constructor) {\n  const { captureStackTrace } = Error as any;\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n  captureStackTrace && captureStackTrace(target, fn);\n}\n\nexport function fixProto(target: Error, prototype: {}) {\n  const { setPrototypeOf } = Object as any;\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions, no-proto, no-param-reassign\n  setPrototypeOf ? setPrototypeOf(target, prototype) : ((target as any).__proto__ = prototype);\n}\n\n/* eslint-disable max-classes-per-file */\nexport class CustomError extends Error {\n  name!: string;\n\n  constructor(message?: string) {\n    super(message);\n    // set error name as constructor name, make it not enumerable to keep native Error behavior\n    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors\n    // see https://github.com/adriengibrat/ts-custom-error/issues/30\n    Object.defineProperty(this, 'name', {\n      value: new.target.name,\n      enumerable: false,\n      configurable: true,\n    });\n    // fix the extended error prototype chain\n    // because typescript __extends implementation can't\n    // see https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    fixProto(this, new.target.prototype);\n    // try to remove constructor from stack trace\n    fixStack(this);\n  }\n}\n\nexport class LibraryError extends CustomError {}\n\nexport class GatewayError extends LibraryError {\n  constructor(\n    message: string,\n    public errorCode: string\n  ) {\n    super(message);\n  }\n}\n\nexport class HttpError extends LibraryError {\n  constructor(\n    message: string,\n    public errorCode: number\n  ) {\n    super(message);\n  }\n}\n","export * from './account';\nexport * from './calldata';\nexport * from './contract';\nexport * from './lib';\nexport * from './provider';\nexport * from './signer';\nexport * from './typedData';\nexport * from './cairoEnum';\nexport * from './transactionReceipt';\n\nexport * as RPC from './api';\n","export enum ValidateType {\n  DEPLOY = 'DEPLOY',\n  CALL = 'CALL',\n  INVOKE = 'INVOKE',\n}\n\nexport enum Uint {\n  u8 = 'core::integer::u8',\n  u16 = 'core::integer::u16',\n  u32 = 'core::integer::u32',\n  u64 = 'core::integer::u64',\n  u128 = 'core::integer::u128',\n  u256 = 'core::integer::u256', // This one is struct\n  u512 = 'core::integer::u512', // This one is struct\n}\n\nexport enum Literal {\n  ClassHash = 'core::starknet::class_hash::ClassHash',\n  ContractAddress = 'core::starknet::contract_address::ContractAddress',\n  Secp256k1Point = 'core::starknet::secp256k1::Secp256k1Point',\n}\n","import { LegacyCompiledContract, LegacyContractClass } from './legacy';\nimport { CompiledSierra, SierraContractClass } from './sierra';\n\n// Final types\n/**\n * format produced after compressing compiled contract\n *\n * CompressedCompiledContract\n */\nexport type ContractClass = LegacyContractClass | SierraContractClass;\n\n/**\n * format produced after compile .cairo to .json\n */\nexport type CompiledContract = LegacyCompiledContract | CompiledSierra;\n\n/**\n * Compressed or decompressed Cairo0 or Cairo1 Contract\n */\nexport type CairoContract = ContractClass | CompiledContract;\n\n// Basic elements\nexport enum EntryPointType {\n  EXTERNAL = 'EXTERNAL',\n  L1_HANDLER = 'L1_HANDLER',\n  CONSTRUCTOR = 'CONSTRUCTOR',\n}\n\nexport * from './abi';\nexport * from './legacy';\nexport * from './sierra';\n","import { StarknetChainId } from '../../constants';\nimport { weierstrass } from '../../utils/ec';\nimport { EDataAvailabilityMode, ResourceBounds } from '../api';\nimport { CairoEnum } from '../cairoEnum';\nimport { CompiledContract, CompiledSierraCasm, ContractClass } from './contract';\n\nexport type WeierstrassSignatureType = weierstrass.SignatureType;\nexport type ArraySignatureType = string[];\nexport type Signature = ArraySignatureType | WeierstrassSignatureType;\n\nexport type BigNumberish = string | number | bigint;\n\nexport type ByteArray = {\n  data: BigNumberish[];\n  pending_word: BigNumberish;\n  pending_word_len: BigNumberish;\n};\n\n/**\n * Compiled calldata ready to be sent\n *\n * decimal-string array\n */\nexport type Calldata = string[] & { readonly __compiled__?: true };\n\n/**\n * Represents an integer in the range [0, 2^256)\n */\nexport interface Uint256 {\n  // The low 128 bits of the value\n  low: BigNumberish;\n  // The high 128 bits of the value\n  high: BigNumberish;\n}\n\n/**\n * Represents an integer in the range [0, 2^256)\n */\nexport interface Uint512 {\n  // The lowest 128 bits of the value\n  limb0: BigNumberish;\n  limb1: BigNumberish;\n  limb2: BigNumberish;\n  // The higher 128 bits of the value\n  limb3: BigNumberish;\n}\n\n/**\n * BigNumberish array\n *\n * use CallData.compile() to convert to Calldata\n */\nexport type RawCalldata = BigNumberish[];\n\n/**\n * Hexadecimal-string array\n */\nexport type HexCalldata = string[];\n\nexport type AllowArray<T> = T | T[];\n\nexport type OptionalPayload<T> = { payload: T } | T;\n\nexport type RawArgs = RawArgsObject | RawArgsArray;\n\nexport type RawArgsObject = {\n  [inputName: string]: MultiType | MultiType[] | RawArgs;\n};\n\nexport type RawArgsArray = Array<MultiType | MultiType[] | RawArgs>;\n\nexport type MultiType = BigNumberish | Uint256 | object | boolean | CairoEnum;\n\nexport type UniversalDeployerContractPayload = {\n  classHash: BigNumberish;\n  salt?: string;\n  unique?: boolean;\n  constructorCalldata?: RawArgs;\n};\n\nexport type DeployAccountContractPayload = {\n  classHash: string;\n  constructorCalldata?: RawArgs;\n  addressSalt?: BigNumberish;\n  contractAddress?: string;\n};\n\nexport type DeployAccountContractTransaction = Omit<\n  DeployAccountContractPayload,\n  'contractAddress'\n> & {\n  signature?: Signature;\n};\n\nexport type DeclareContractPayload = {\n  contract: CompiledContract | string;\n  classHash?: string;\n  casm?: CompiledSierraCasm;\n  compiledClassHash?: string;\n};\n\nexport type CompleteDeclareContractPayload = {\n  contract: CompiledContract | string;\n  classHash: string;\n  casm?: CompiledSierraCasm;\n  compiledClassHash?: string;\n};\n\nexport type DeclareAndDeployContractPayload = Omit<UniversalDeployerContractPayload, 'classHash'> &\n  DeclareContractPayload;\n\nexport type DeclareContractTransaction = {\n  contract: ContractClass;\n  senderAddress: string;\n  signature?: Signature;\n  compiledClassHash?: string;\n};\n\nexport type CallDetails = {\n  contractAddress: string;\n  calldata?: RawArgs | Calldata;\n  entrypoint?: string;\n};\n\nexport type Invocation = CallDetails & { signature?: Signature };\n\nexport type Call = CallDetails & { entrypoint: string };\n\nexport type CairoVersion = '0' | '1' | undefined;\nexport type CompilerVersion = '0' | '1' | '2' | undefined;\n\nexport type InvocationsDetails = {\n  nonce?: BigNumberish;\n  maxFee?: BigNumberish;\n  version?: BigNumberish;\n} & Partial<V3TransactionDetails>;\n\nexport type V3TransactionDetails = {\n  nonce: BigNumberish;\n  version: BigNumberish;\n  resourceBounds: ResourceBounds;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n  accountDeploymentData: BigNumberish[];\n  nonceDataAvailabilityMode: EDataAvailabilityMode;\n  feeDataAvailabilityMode: EDataAvailabilityMode;\n};\n\n/**\n * Contain all additional details params\n */\nexport type Details = {\n  nonce: BigNumberish;\n  maxFee: BigNumberish;\n  version: BigNumberish;\n  chainId: StarknetChainId;\n};\n\nexport type InvocationsDetailsWithNonce =\n  | (InvocationsDetails & { nonce: BigNumberish })\n  | V3TransactionDetails;\n\nexport enum TransactionType {\n  DECLARE = 'DECLARE',\n  DEPLOY = 'DEPLOY',\n  DEPLOY_ACCOUNT = 'DEPLOY_ACCOUNT',\n  INVOKE = 'INVOKE_FUNCTION',\n}\n\n/**\n * new statuses are defined by props: finality_status and execution_status\n * to be #deprecated\n */\nexport enum TransactionStatus {\n  NOT_RECEIVED = 'NOT_RECEIVED',\n  RECEIVED = 'RECEIVED',\n  ACCEPTED_ON_L2 = 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1 = 'ACCEPTED_ON_L1',\n  REJECTED = 'REJECTED',\n  REVERTED = 'REVERTED',\n}\n\nexport enum TransactionFinalityStatus {\n  NOT_RECEIVED = 'NOT_RECEIVED',\n  RECEIVED = 'RECEIVED',\n  ACCEPTED_ON_L2 = 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1 = 'ACCEPTED_ON_L1',\n}\n\nexport enum TransactionExecutionStatus {\n  REJECTED = 'REJECTED',\n  REVERTED = 'REVERTED',\n  SUCCEEDED = 'SUCCEEDED',\n}\n\nexport enum BlockStatus {\n  PENDING = 'PENDING',\n  ACCEPTED_ON_L1 = 'ACCEPTED_ON_L1',\n  ACCEPTED_ON_L2 = 'ACCEPTED_ON_L2',\n  REJECTED = 'REJECTED',\n}\n\nexport enum BlockTag {\n  PENDING = 'pending',\n  LATEST = 'latest',\n}\n\nexport type BlockNumber = BlockTag | null | number;\n\n/**\n * hex string and BigInt are detected as block hashes\n *\n * decimal string and number are detected as block numbers\n *\n * text string are detected as block tag\n *\n * null return 'pending' block tag\n */\nexport type BlockIdentifier = BlockNumber | BigNumberish;\n\n/**\n * items used by AccountInvocations\n */\nexport type AccountInvocationItem = (\n  | ({ type: typeof TransactionType.DECLARE } & DeclareContractTransaction)\n  | ({ type: typeof TransactionType.DEPLOY_ACCOUNT } & DeployAccountContractTransaction)\n  | ({ type: typeof TransactionType.INVOKE } & Invocation)\n) &\n  InvocationsDetailsWithNonce;\n\n/**\n * Complete invocations array with account details (internal type from account -> provider)\n */\nexport type AccountInvocations = AccountInvocationItem[];\n\n/**\n * Invocations array user provide to bulk method (simulate)\n */\nexport type Invocations = Array<\n  | ({ type: typeof TransactionType.DECLARE } & OptionalPayload<DeclareContractPayload>)\n  | ({ type: typeof TransactionType.DEPLOY } & OptionalPayload<\n      AllowArray<UniversalDeployerContractPayload>\n    >)\n  | ({\n      type: typeof TransactionType.DEPLOY_ACCOUNT;\n    } & OptionalPayload<DeployAccountContractPayload>)\n  | ({ type: typeof TransactionType.INVOKE } & OptionalPayload<AllowArray<Call>>)\n>;\n\nexport type Tupled = { element: any; type: string };\n\nexport type Args = {\n  [inputName: string]: BigNumberish | BigNumberish[] | ParsedStruct | ParsedStruct[];\n};\nexport type ParsedStruct = {\n  [key: string]: BigNumberish | BigNumberish[] | ParsedStruct | Uint256;\n};\n\nexport type waitForTransactionOptions = {\n  retryInterval?: number;\n  successStates?: Array<TransactionFinalityStatus | TransactionExecutionStatus>;\n  errorStates?: Array<TransactionFinalityStatus | TransactionExecutionStatus>;\n};\n\nexport type getSimulateTransactionOptions = {\n  blockIdentifier?: BlockIdentifier;\n  skipValidate?: boolean;\n  skipExecute?: boolean;\n  skipFeeCharge?: boolean;\n};\n\nexport type getContractVersionOptions = {\n  blockIdentifier?: BlockIdentifier;\n  compiler?: boolean;\n};\n\nexport type getEstimateFeeBulkOptions = {\n  blockIdentifier?: BlockIdentifier;\n  skipValidate?: boolean;\n};\n\nexport interface CallStruct {\n  to: string;\n  selector: string;\n  calldata: string[];\n}\n\n/**\n * Represent Contract version\n */\nexport type ContractVersion = {\n  /** version of the cairo language */\n  cairo: CairoVersion;\n  /** version of the cairo compiler used to compile the contract */\n  compiler: CompilerVersion;\n};\n\nexport * from './contract';\n","// Reexport types from package\nexport {\n  TypedDataRevision,\n  type StarknetEnumType,\n  type StarknetMerkleType,\n  type StarknetType,\n  type StarknetDomain,\n  type TypedData,\n} from 'starknet-types-07';\n","/**\n * Asserts that the given condition is true, otherwise throws an error with an optional message.\n * @param {any} condition - The condition to check.\n * @param {string} [message] - The optional message to include in the error.\n * @throws {Error} Throws an error if the condition is false.\n * @example\n * ```typescript\n * const address = '0xa7ee790591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf';\n * assert(/^(0x)?[0-9a-fA-F]{64}$/.test(address), 'Invalid address format');\n * ```\n */\nexport default function assert(condition: boolean, message?: string): asserts condition {\n  if (!condition) {\n    throw new Error(message || 'Assertion failure');\n  }\n}\n","import { hexToBytes as hexToBytesNoble } from '@noble/curves/abstract/utils';\n\nimport { BigNumberish } from '../types';\nimport assert from './assert';\nimport { addHexPrefix, removeHexPrefix } from './encode';\n\n/** @deprecated prefer importing from 'types' over 'num' */\nexport type { BigNumberish };\n\n/**\n * Test if string is hex-string\n *\n * @param hex hex-string\n * @returns {boolean} true if the input string is a hexadecimal string, false otherwise\n * @example\n * ```typescript\n * const hexString1 = \"0x2fd23d9182193775423497fc0c472e156c57c69e4089a1967fb288a2d84e914\";\n * const result1 = isHex(hexString1);\n * // result1 = true\n *\n * const hexString2 = \"2fd23d9182193775423497fc0c472e156c57c69e4089a1967fb288a2d84e914\";\n * const result2 = isHex(hexString2);\n * // result2 = false\n * ```\n */\nexport function isHex(hex: string): boolean {\n  return /^0x[0-9a-f]*$/i.test(hex);\n}\n\n/**\n * Convert BigNumberish to bigint\n *\n * @param {BigNumberish} value value to convert\n * @returns {BigInt} converted value\n * @example\n * ```typescript\n * const str = '123';\n * const result = toBigInt(str);\n * // result = 123n\n * ```\n */\nexport function toBigInt(value: BigNumberish): bigint {\n  return BigInt(value);\n}\n\n/**\n * Test if value is bigint\n *\n * @param value value to test\n * @returns {boolean} true if value is bigint, false otherwise\n * @example\n * ```typescript\n * isBigInt(10n); // true\n * isBigInt(BigInt('10')); // true\n * isBigInt(10); // false\n * isBigInt('10'); // false\n * isBigInt(null); // false\n * ```\n */\nexport function isBigInt(value: any): value is bigint {\n  return typeof value === 'bigint';\n}\n\n/**\n * Convert BigNumberish to hex-string\n *\n * @param {BigNumberish} value value to convert\n * @returns {string} converted number in hex-string format\n * @example\n * ```typescript\n * toHex(100); // '0x64'\n * toHex('200'); // '0xc8'\n * ```\n */\nexport function toHex(value: BigNumberish): string {\n  return addHexPrefix(toBigInt(value).toString(16));\n}\n\n/**\n * Alias of ToHex\n */\nexport const toHexString = toHex;\n\n/**\n * Convert BigNumberish to storage-key-string\n *\n * Same as toHex but conforming to the STORAGE_KEY pattern `^0x0[0-7]{1}[a-fA-F0-9]{0,62}$`.\n *\n * A storage key is represented as up to 62 hex digits, 3 bits, and 5 leading zeroes:\n * `0x0 + [0-7] + 62 hex = 0x + 64 hex`\n * @returns format: storage-key-string\n */\nexport function toStorageKey(number: BigNumberish): string {\n  return addHexPrefix(toBigInt(number).toString(16).padStart(64, '0'));\n}\n\n/**\n * Convert hexadecimal string to decimal string\n *\n * @param {string} hex hex-string to convert\n * @returns {string} converted number in decimal string format\n * @example\n * ```typescript\n * hexToDecimalString('64'); // '100'\n * hexToDecimalString('c8'); // '200'\n * ```\n */\nexport function hexToDecimalString(hex: string): string {\n  return BigInt(addHexPrefix(hex)).toString(10);\n}\n\n/**\n * Remove hex-string leading zeroes and lowercase it\n *\n * @param {string} hex hex-string\n * @returns {string} updated string in hex-string format\n * @example\n * ```typescript\n * cleanHex('0x00023AB'); // '0x23ab'\n * ```\n */\nexport function cleanHex(hex: string): string {\n  return hex.toLowerCase().replace(/^(0x)0+/, '$1');\n}\n\n/**\n * Asserts input is equal to or greater then lowerBound and lower then upperBound.\n *\n * The `inputName` parameter is used in the assertion message.\n * @param input Value to check\n * @param lowerBound Lower bound value\n * @param upperBound Upper bound value\n * @param inputName Name of the input for error message\n * @throws Error if input is out of range\n * @example\n * ```typescript\n * const input1:BigNumberish = 10;\n * assertInRange(input1, 5, 20, 'value')\n *\n * const input2: BigNumberish = 25;\n * assertInRange(input2, 5, 20, 'value');\n * // throws Error: Message not signable, invalid value length.\n * ```\n */\nexport function assertInRange(\n  input: BigNumberish,\n  lowerBound: BigNumberish,\n  upperBound: BigNumberish,\n  inputName = ''\n) {\n  const messageSuffix = inputName === '' ? 'invalid length' : `invalid ${inputName} length`;\n  const inputBigInt = BigInt(input);\n  const lowerBoundBigInt = BigInt(lowerBound);\n  const upperBoundBigInt = BigInt(upperBound);\n\n  assert(\n    inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt,\n    `Message not signable, ${messageSuffix}.`\n  );\n}\n\n/**\n * Convert BigNumberish array to decimal string array\n *\n * @param {BigNumberish[]} data array of big-numberish elements\n * @returns {string[]} array of decimal strings\n * @example\n * ```typescript\n * const data = [100, 200n];\n * const result = bigNumberishArrayToDecimalStringArray(data);\n * // result = ['100', '200']\n * ```\n */\nexport function bigNumberishArrayToDecimalStringArray(data: BigNumberish[]): string[] {\n  return data.map((x) => toBigInt(x).toString(10));\n}\n\n/**\n * Convert BigNumberish array to hexadecimal string array\n *\n * @param {BigNumberish[]} data array of big-numberish elements\n * @returns array of hex-strings\n * @example\n * ```typescript\n * const data = [100, 200n];\n * const result = bigNumberishArrayToHexadecimalStringArray(data);\n * // result = ['0x64', '0xc8']\n * ```\n */\nexport function bigNumberishArrayToHexadecimalStringArray(data: BigNumberish[]): string[] {\n  return data.map((x) => toHex(x));\n}\n\n/**\n * Test if string is a whole number (0, 1, 2, 3...)\n *\n * @param {string} str string to test\n * @returns {boolean}: true if string is a whole number, false otherwise\n * @example\n * ```typescript\n * isStringWholeNumber('100'); // true\n * isStringWholeNumber('10.0'); // false\n * isStringWholeNumber('test'); // false\n * ```\n */\nexport function isStringWholeNumber(str: string): boolean {\n  return /^\\d+$/.test(str);\n}\n\n/**\n * Convert string to decimal string\n *\n * @param {string} str string to convert\n * @returns converted string in decimal format\n * @throws str needs to be a number string in hex or whole number format\n * @example\n * ```typescript\n * const result = getDecimalString(\"0x1a\");\n * // result = \"26\"\n *\n * const result2 = getDecimalString(\"Hello\");\n * // throws Error: \"Hello needs to be a hex-string or whole-number-string\"\n * ```\n */\nexport function getDecimalString(str: string) {\n  if (isHex(str)) {\n    return hexToDecimalString(str);\n  }\n  if (isStringWholeNumber(str)) {\n    return str;\n  }\n  throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\n\n/**\n * Convert string to hexadecimal string\n *\n * @param {string} str string to convert\n * @returns converted hex-string\n * @throws str needs to be a number string in hex or whole number format\n * @example\n * ```typescript\n * const result = getHexString(\"123\");\n * // result = \"0x7b\"\n *\n * const result2 = getHexString(\"Hello\");\n * // throws Error: Hello needs to be a hex-string or whole-number-string\n * ```\n */\nexport function getHexString(str: string) {\n  if (isHex(str)) {\n    return str;\n  }\n  if (isStringWholeNumber(str)) {\n    return toHexString(str);\n  }\n  throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\n\n/**\n * Convert string array to hex-string array\n *\n * @param {Array<string>} array array of string elements\n * @returns array of converted elements in hex-string format\n * @example\n * ```typescript\n * const data = ['100', '200', '0xaa'];\n * const result = getHexStringArray(data);\n * // result = ['0x64', '0xc8', '0xaa']\n * ```\n */\nexport function getHexStringArray(array: Array<string>) {\n  return array.map(getHexString);\n}\n\n/**\n * Convert boolean to \"0\" or \"1\"\n *\n * @param value The boolean value to be converted.\n * @returns {boolean} Returns true if the value is a number, otherwise returns false.\n * @example\n * ```typescript\n * const result = toCairoBool(true);\n * // result =\"1\"\n *\n * const result2 = toCairoBool(false);\n * // result2 = \"0\"\n * ```\n */\nexport function toCairoBool(value: boolean): string {\n  return (+value).toString();\n}\n\n/**\n * Convert hex-string to an array of Bytes (Uint8Array)\n *\n * @param {string} str hex-string\n * @returns {Uint8Array} array containing the converted elements\n * @throws str must be a hex-string\n * @example\n * ```typescript\n * let result;\n *\n * result = hexToBytes('0x64');\n * // result = [100]\n *\n * result = hexToBytes('test');\n * // throws Error: test needs to be a hex-string\n * ```\n */\nexport function hexToBytes(str: string): Uint8Array {\n  if (!isHex(str)) throw new Error(`${str} needs to be a hex-string`);\n\n  let adaptedValue: string = removeHexPrefix(str);\n  if (adaptedValue.length % 2 !== 0) {\n    adaptedValue = `0${adaptedValue}`;\n  }\n  return hexToBytesNoble(adaptedValue);\n}\n\n/**\n * Adds a percentage amount to the value\n *\n * @param number value to be modified\n * @param percent integer as percent ex. 50 for 50%\n * @returns {BigInt} modified value\n * @example\n * ```typescript\n * addPercent(100, 50); // 150n\n * addPercent(100, 100); // 200n\n * addPercent(200, 50); // 300n\n * addPercent(200, -50); // 100n\n * addPercent(200, -100); // 0n\n * addPercent(200, -150); // -100n\n * ```\n */\nexport function addPercent(number: BigNumberish, percent: number) {\n  const bigIntNum = BigInt(number);\n  return bigIntNum + (bigIntNum * BigInt(percent)) / 100n;\n}\n\n/**\n * Check if a value is a number.\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} Returns true if the value is a number, otherwise returns false.\n * @example\n * ```typescript\n * const result = isNumber(123);\n * // result = true\n *\n * const result2 = isNumber(\"123\");\n * // result2 = false\n * ```\n * @return {boolean} Returns true if the value is a number, otherwise returns false.\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number';\n}\n\n/**\n * Checks if a given value is of boolean type.\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} - True if the value is of boolean type, false otherwise.\n * @example\n * ```typescript\n * const result = isBoolean(true);\n * // result = true\n *\n * const result2 = isBoolean(false);\n * // result2 = false\n * ```\n * @return {boolean} - True if the value is of boolean type, false otherwise.\n */\nexport function isBoolean(value: unknown): value is boolean {\n  return typeof value === 'boolean';\n}\n","import { keccak } from '@scure/starknet';\n\nimport { MASK_250 } from '../../constants';\nimport { BigNumberish } from '../../types';\nimport { addHexPrefix, removeHexPrefix, utf8ToArray } from '../encode';\nimport { hexToBytes, isHex, isStringWholeNumber, toHex, toHexString } from '../num';\n\n/**\n * Calculate the hex-string Keccak hash for a given BigNumberish\n *\n * @param value value to hash\n * @returns hex-string Keccak hash\n * @example\n * ```typescript\n * const result = keccakBn('0xabc');\n * // result = '0x11cf08aac85935e32397f410e48217a127b6855d41b1e3877eb4179c0904b77'\n * ```\n */\nexport function keccakBn(value: BigNumberish): string {\n  const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n  const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n  return addHexPrefix(keccak(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\n\n/**\n * [internal]\n * Calculate hex-string Keccak hash for a given string\n *\n * String -> hex-string Keccak hash\n * @returns format: hex-string\n */\nfunction keccakHex(str: string): string {\n  return addHexPrefix(keccak(utf8ToArray(str)).toString(16));\n}\n\n/**\n * Calculate the BigInt Starknet Keccak hash for a given string\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L38)\n *\n * @param str value to hash\n * @returns BigInt Keccak hash\n * @example\n * ```typescript\n * const result = starknetKeccak('test').toString();\n * // result = '61835310290161785288773114225739080147441215596947647498723774891619563096'\n * ```\n */\nexport function starknetKeccak(str: string): bigint {\n  const hash = BigInt(keccakHex(str));\n  // eslint-disable-next-line no-bitwise\n  return hash & MASK_250;\n}\n\n/**\n * Calculate the hex-string selector for a given abi function name\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L46)\n *\n * @param funcName abi function name\n * @returns hex-string selector\n * @example\n * ```typescript\n * const result = getSelectorFromName('myFunction');\n * // result = '0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8'\n * ```\n */\nexport function getSelectorFromName(funcName: string) {\n  // sometimes BigInteger pads the hex string with zeros, which is not allowed in the starknet api\n  return toHex(starknetKeccak(funcName));\n}\n\n/**\n * Calculate the hex-string selector from a given abi function name, decimal string or hex string\n *\n * @param value hex-string | dec-string | ascii-string\n * @returns hex-string selector\n * @example\n * ```typescript\n * const selector1: string = getSelector(\"myFunction\");\n * // selector1 = \"0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8\"\n *\n * const selector2: string = getSelector(\"0x123abc\");\n * // selector2 = \"0x123abc\"\n *\n * const selector3: string = getSelector(\"123456\");\n * // selector3 = \"0x1e240\"\n * ```\n */\nexport function getSelector(value: string) {\n  if (isHex(value)) {\n    return value;\n  }\n  if (isStringWholeNumber(value)) {\n    return toHexString(value);\n  }\n  return getSelectorFromName(value);\n}\n","import { TEXT_TO_FELT_MAX_LEN } from '../constants';\nimport { addHexPrefix, removeHexPrefix } from './encode';\nimport { isHex, isStringWholeNumber } from './num';\n\n/**\n * Test if string contains only ASCII characters (string can be ascii text)\n * @param {string} str The string to test\n * @returns {boolean} Returns true if the string contains only ASCII characters, otherwise false\n * @example\n * ```typescript\n * const result = shortString.isASCII(\"Hello, world!\");\n * // result = true\n * const result = shortString.isASCII(\"Hello, 世界!\");\n * // result = false\n * ```\n */\nexport function isASCII(str: string): boolean {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\n\n/**\n * Test if a string is a Cairo short string (string with less or equal 31 characters)\n * @param {string} str the string to test\n * @returns {boolean} Returns true if the string has less than or equal to 31 characters, otherwise false.\n * @example\n * ```typescript\n * const result = shortString.isShortString(\"Hello, world!\");\n * // result = true\n * ```\n */\nexport function isShortString(str: string): boolean {\n  return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\n\n/**\n * Test if string contains only numbers (string can be converted to decimal integer number)\n * @param {string} str the string to test.\n * @returns {boolean} Returns true if the string contains only numbers, otherwise false.\n * @example\n * ```typescript\n * const result = shortString.isDecimalString(\"12345\");\n * // result = true\n * const result = shortString.isDecimalString(\"12a45\");\n * // result = false\n * ```\n */\nexport function isDecimalString(str: string): boolean {\n  return /^[0-9]*$/i.test(str);\n}\n\n/**\n * Checks if a given value is a string.\n * @param {unknown} value the value to be checked.\n * @return {boolean} returns true if the value is a string, false otherwise.\n * @example\n * ```typescript\n * const result = shortString.isString(\"12345\");\n * // result = true\n * ```\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Test if value is a pure string text, and not a hex string or number string\n * @param {any} val the value to test\n * @returns {boolean} returns true if the value is a free-form string text, otherwise false\n * @example\n * ```typescript\n * const result = shortString.isText(\"Hello, world!\");\n * // result = true\n * const result = shortString.isText(\"0x7aec92f706\");\n * // result = false\n * ```\n */\nexport function isText(val: any) {\n  return isString(val) && !isHex(val) && !isStringWholeNumber(val);\n}\n\n/**\n * Test if value is short text\n * @param {any} val - The item to test\n * @returns {boolean} Returns true if the value is a short text (string has less or equal 31 characters), otherwise false\n * @example\n * ```typescript\n * const result = shortString.isShortText(\"Hello, world!\");\n * // result = true\n * ```\n */\nexport const isShortText = (val: any) => isText(val) && isShortString(val);\n\n/**\n * Test if value is long text\n * @param {any} val the value to test\n * @returns {boolean} returns true if the value is a long text(string has more than 31 characters), otherwise false.\n * @example\n * ```typescript\n * const result = shortString.isLongText(\"Hello, world! this is some random long string to enable you test isLongText function.\");\n * // result = true\n * ```\n */\nexport const isLongText = (val: any) => isText(val) && !isShortString(val);\n\n/**\n * Split long text (string greater than 31 characters) into short strings (string lesser or equal 31 characters)\n * @param {string} longStr the long text (string greater than 31 characters) to split\n * @returns {string[]} an array of short strings (string lesser or equal 31 characters).\n * @example\n * ```typescript\n * const result = shortString.splitLongString(\"Hello, world! we just testing splitLongString function.\");\n * // result = [ 'Hello, world! we just testing s', 'plitLongString function.' ]\n * ```\n */\nexport function splitLongString(longStr: string): string[] {\n  const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, 'g');\n  return longStr.match(regex) || [];\n}\n\n/**\n * Convert an ASCII short string to a hexadecimal string.\n * @param {string} str short string (ASCII string, 31 characters max)\n * @returns {string} hex-string with 248 bits max\n * @example\n * ```typescript\n * const result = shortString.encodeShortString(\"uri/pict/t38.jpg\");\n * // result = \"0x7572692f706963742f7433382e6a7067\"\n * ```\n */\nexport function encodeShortString(str: string): string {\n  if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n  if (!isShortString(str)) throw new Error(`${str} is too long`);\n  return addHexPrefix(str.replace(/./g, (char) => char.charCodeAt(0).toString(16)));\n}\n\n/**\n * Convert a hexadecimal or decimal string to an ASCII string.\n * @param {string} str representing a 248 bit max number (ex. \"0x1A4F64EA56\" or \"236942575435676423\")\n * @returns {string} short string; 31 characters max\n * @example\n * ```typescript\n * const result = shortString.decodeShortString(\"0x7572692f706963742f7433382e6a7067\");\n * // result = \"uri/pict/t38.jpg\"\n * ```\n */\nexport function decodeShortString(str: string): string {\n  if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n  if (isHex(str)) {\n    return removeHexPrefix(str).replace(/.{2}/g, (hex) => String.fromCharCode(parseInt(hex, 16)));\n  }\n  if (isDecimalString(str)) {\n    return decodeShortString('0X'.concat(BigInt(str).toString(16)));\n  }\n  throw new Error(`${str} is not Hex or decimal`);\n}\n","import { BigNumberish, ByteArray } from '../../types/lib';\nimport { toHex } from '../num';\nimport { decodeShortString, encodeShortString, splitLongString } from '../shortString';\n\n/**\n * convert a Cairo ByteArray to a JS string\n * @param myByteArray Cairo representation of a LongString\n * @returns a JS string\n * @example\n * ```typescript\n * const myByteArray = {\n *    data: [],\n *    pending_word: '0x414243444546474849',\n *    pending_word_len: 9\n * }\n * const result: String = stringFromByteArray(myByteArray); // ABCDEFGHI\n * ```\n */\nexport function stringFromByteArray(myByteArray: ByteArray): string {\n  const pending_word: string =\n    BigInt(myByteArray.pending_word) === 0n\n      ? ''\n      : decodeShortString(toHex(myByteArray.pending_word));\n  return (\n    myByteArray.data.reduce<string>((cumuledString, encodedString: BigNumberish) => {\n      const add: string =\n        BigInt(encodedString) === 0n ? '' : decodeShortString(toHex(encodedString));\n      return cumuledString + add;\n    }, '') + pending_word\n  );\n}\n\n/**\n * convert a JS string to a Cairo ByteArray\n * @param targetString a JS string\n * @returns Cairo representation of a LongString\n * @example\n * ```typescript\n * const myByteArray: ByteArray = byteArrayFromString(\"ABCDEFGHI\");\n * ```\n * Result is :\n * {\n *    data: [],\n *    pending_word: '0x414243444546474849',\n *    pending_word_len: 9\n * }\n */\nexport function byteArrayFromString(targetString: string): ByteArray {\n  const shortStrings: string[] = splitLongString(targetString);\n  const remainder: string = shortStrings[shortStrings.length - 1];\n  const shortStringsEncoded: BigNumberish[] = shortStrings.map(encodeShortString);\n\n  const [pendingWord, pendingWordLength] =\n    remainder === undefined || remainder.length === 31\n      ? ['0x00', 0]\n      : [shortStringsEncoded.pop()!, remainder.length];\n\n  return {\n    data: shortStringsEncoded.length === 0 ? [] : shortStringsEncoded,\n    pending_word: pendingWord,\n    pending_word_len: pendingWordLength,\n  };\n}\n","import {\n  Abi,\n  AbiEnums,\n  AbiStructs,\n  BigNumberish,\n  ContractVersion,\n  Literal,\n  Uint,\n  Uint256,\n  Uint512,\n} from '../../types';\nimport { CairoFelt } from '../cairoDataTypes/felt';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\n\n// Intended for internal usage, maybe should be exported somewhere else and not exported to utils\n/**\n * Checks if the given name ends with \"_len\".\n *\n * @param {string} name - The name to be checked.\n * @returns - True if the name ends with \"_len\", false otherwise.\n */\nexport const isLen = (name: string) => /_len$/.test(name);\n/**\n * Checks if a given type is felt.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type is felt, false otherwise.\n */\nexport const isTypeFelt = (type: string) => type === 'felt' || type === 'core::felt252';\n/**\n * Checks if the given type is an array type.\n *\n * @param {string} type - The type to check.\n * @returns - `true` if the type is an array type, `false` otherwise.\n */\nexport const isTypeArray = (type: string) =>\n  /\\*/.test(type) ||\n  type.startsWith('core::array::Array::') ||\n  type.startsWith('core::array::Span::');\n/**\n * Checks if the given type is a tuple type.\n *\n * @param {string} type - The type to be checked.\n * @returns - `true` if the type is a tuple type, otherwise `false`.\n */\nexport const isTypeTuple = (type: string) => /^\\(.*\\)$/i.test(type);\n/**\n * Checks whether a given type is a named tuple.\n *\n * @param {string} type - The type to be checked.\n * @returns - True if the type is a named tuple, false otherwise.\n */\nexport const isTypeNamedTuple = (type: string) => /\\(.*\\)/i.test(type) && type.includes(':');\n/**\n * Checks if a given type is a struct.\n *\n * @param {string} type - The type to check for existence.\n * @param {AbiStructs} structs - The collection of structs to search in.\n * @returns - True if the type exists in the structs, false otherwise.\n */\nexport const isTypeStruct = (type: string, structs: AbiStructs) => type in structs;\n/**\n * Checks if a given type is an enum.\n *\n * @param {string} type - The type to check.\n * @param {AbiEnums} enums - The enumeration to search in.\n * @returns - True if the type exists in the enumeration, otherwise false.\n */\nexport const isTypeEnum = (type: string, enums: AbiEnums) => type in enums;\n/**\n * Determines if the given type is an Option type.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type is an Option type, false otherwise.\n */\nexport const isTypeOption = (type: string) => type.startsWith('core::option::Option::');\n/**\n * Checks whether a given type starts with 'core::result::Result::'.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type starts with 'core::result::Result::', false otherwise.\n */\nexport const isTypeResult = (type: string) => type.startsWith('core::result::Result::');\n/**\n * Checks if the given value is a valid Uint type.\n *\n * @param {string} type - The value to check.\n * @returns - Returns true if the value is a valid Uint type, otherwise false.\n */\nexport const isTypeUint = (type: string) => Object.values(Uint).includes(type as Uint);\n// Legacy Export\n/**\n * Checks if the given type is `uint256`.\n *\n * @param {string} type - The type to be checked.\n * @returns - Returns true if the type is `uint256`, otherwise false.\n */\nexport const isTypeUint256 = (type: string) => CairoUint256.isAbiType(type);\n/**\n * Checks if the given type is a literal type.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type is a literal type, false otherwise.\n */\nexport const isTypeLiteral = (type: string) => Object.values(Literal).includes(type as Literal);\n/**\n * Checks if the given type is a boolean type.\n *\n * @param {string} type - The type to be checked.\n * @returns - Returns true if the type is a boolean type, otherwise false.\n */\nexport const isTypeBool = (type: string) => type === 'core::bool';\n/**\n * Checks if the provided type is equal to 'core::starknet::contract_address::ContractAddress'.\n * @param {string} type - The type to be checked.\n * @returns - true if the type matches 'core::starknet::contract_address::ContractAddress', false otherwise.\n */\nexport const isTypeContractAddress = (type: string) =>\n  type === 'core::starknet::contract_address::ContractAddress';\n/**\n * Determines if the given type is an Ethereum address type.\n *\n * @param {string} type - The type to check.\n * @returns - Returns true if the given type is 'core::starknet::eth_address::EthAddress', otherwise false.\n */\nexport const isTypeEthAddress = (type: string) =>\n  type === 'core::starknet::eth_address::EthAddress';\n/**\n * Checks if the given type is 'core::bytes_31::bytes31'.\n *\n * @param {string} type - The type to check.\n * @returns - True if the type is 'core::bytes_31::bytes31', false otherwise.\n */\nexport const isTypeBytes31 = (type: string) => type === 'core::bytes_31::bytes31';\n/**\n * Checks if the given type is equal to the 'core::byte_array::ByteArray'.\n *\n * @param {string} type - The type to check.\n * @returns - True if the given type is equal to 'core::byte_array::ByteArray', false otherwise.\n */\nexport const isTypeByteArray = (type: string) => type === 'core::byte_array::ByteArray';\nexport const isTypeSecp256k1Point = (type: string) =>\n  type === 'core::starknet::secp256k1::Secp256k1Point';\nexport const isCairo1Type = (type: string) => type.includes('::');\n/**\n * Retrieves the array type from the given type string.\n *\n * Works also for core::zeroable::NonZero type.\n * @param {string} type - The type string.\n * @returns - The array type.\n */\nexport const getArrayType = (type: string) => {\n  if (isCairo1Type(type)) {\n    return type.substring(type.indexOf('<') + 1, type.lastIndexOf('>'));\n  }\n  return type.replace('*', '');\n};\n\n/**\n * Test if an ABI comes from a Cairo 1 contract\n * @param abi representing the interface of a Cairo contract\n * @returns TRUE if it is an ABI from a Cairo1 contract\n * @example\n * ```typescript\n * const isCairo1: boolean = isCairo1Abi(myAbi: Abi);\n * ```\n */\nexport function isCairo1Abi(abi: Abi): boolean {\n  const { cairo } = getAbiContractVersion(abi);\n  if (cairo === undefined) {\n    throw Error('Unable to determine Cairo version');\n  }\n  return cairo === '1';\n}\n\n/**\n * Checks if the given type is a NonZero type.\n *\n * @param {string} type The type to check.\n * @returns `true` if the type is NonZero type, `false` otherwise.\n * @example\n * ```typescript\n * const result = cairo.isTypeNonZero(\"core::zeroable::NonZero::<u8>\");\n * //result = true\n * ```\n */\nexport function isTypeNonZero(type: string): boolean {\n  return type.startsWith('core::zeroable::NonZero::');\n}\n\n/**\n * Return ContractVersion (Abi version) based on Abi\n * or undefined for unknown version\n * @param abi\n * @returns string\n */\nexport function getAbiContractVersion(abi: Abi): ContractVersion {\n  // determine by interface for \"Cairo 1.2\"\n  if (abi.find((it) => it.type === 'interface')) {\n    return { cairo: '1', compiler: '2' };\n  }\n\n  // determine by function io types \"Cairo 1.1\" or \"Cairo 0.0\"\n  // find first function with inputs or outputs\n  const testFunction = abi.find(\n    (it) => it.type === 'function' && (it.inputs.length || it.outputs.length)\n  );\n  if (!testFunction) {\n    return { cairo: undefined, compiler: undefined };\n  }\n  const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;\n  if (isCairo1Type(io[0].type)) {\n    return { cairo: '1', compiler: '1' };\n  }\n  return { cairo: '0', compiler: '0' };\n}\n\n/**\n * named tuple cairo type is described as js object {}\n * struct cairo type are described as js object {}\n * array cairo type are described as js array []\n */\n\n/**\n * Create Uint256 Cairo type (helper for common struct type)\n * @example\n * ```typescript\n * uint256('892349863487563453485768723498');\n * ```\n */\nexport const uint256 = (it: BigNumberish): Uint256 => {\n  return new CairoUint256(it).toUint256DecimalString();\n};\n\n/**\n * Create Uint512 Cairo type (helper for common struct type)\n * @param it BigNumberish representation of a 512 bits unsigned number\n * @returns Uint512 struct\n * @example\n * ```typescript\n * uint512('345745685892349863487563453485768723498');\n * ```\n */\nexport const uint512 = (it: BigNumberish): Uint512 => {\n  return new CairoUint512(it).toUint512DecimalString();\n};\n\n/**\n * Create unnamed tuple Cairo type (helper same as common struct type)\n * @example\n * ```typescript\n * tuple(1, '0x101', 16);\n * ```\n */\nexport const tuple = (\n  ...args: (BigNumberish | object | boolean)[]\n): Record<number, BigNumberish | object | boolean> => ({ ...args });\n\n/**\n * Create felt Cairo type (cairo type helper)\n * @returns format: felt-string\n */\nexport function felt(it: BigNumberish): string {\n  return CairoFelt(it);\n}\n","// TODO Convert to CairoFelt base on CairoUint256 and implement it in the codebase in the backward compatible manner\n\nimport { BigNumberish, isBigInt, isBoolean, isHex, isStringWholeNumber } from '../num';\nimport { encodeShortString, isShortString, isString, isText } from '../shortString';\n\n/**\n * Create felt Cairo type (cairo type helper)\n * @returns format: felt-string\n */\nexport function CairoFelt(it: BigNumberish): string {\n  // BN or number\n  if (isBigInt(it) || Number.isInteger(it)) {\n    return it.toString();\n  }\n\n  // Handling strings\n  if (isString(it)) {\n    // Hex strings\n    if (isHex(it)) {\n      return BigInt(it).toString();\n    }\n    // Text strings that must be short\n    if (isText(it)) {\n      if (!isShortString(it)) {\n        throw new Error(\n          `${it} is a long string > 31 chars. Please split it into an array of short strings.`\n        );\n      }\n      // Assuming encodeShortString returns a hex representation of the string\n      return BigInt(encodeShortString(it)).toString();\n    }\n    // Whole numeric strings\n    if (isStringWholeNumber(it)) {\n      return it;\n    }\n  }\n  // bool to felt\n  if (isBoolean(it)) {\n    return `${+it}`;\n  }\n\n  throw new Error(`${it} can't be computed by felt()`);\n}\n","/* eslint-disable no-bitwise */\n/**\n * Singular class handling cairo u256 data type\n */\n\nimport { BigNumberish, Uint256 } from '../../types';\nimport { addHexPrefix } from '../encode';\nimport { CairoFelt } from './felt';\n\nexport const UINT_128_MAX = (1n << 128n) - 1n;\nexport const UINT_256_MAX = (1n << 256n) - 1n;\nexport const UINT_256_MIN = 0n;\nexport const UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;\nexport const UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;\nexport const UINT_256_LOW_MIN = 0n;\nexport const UINT_256_HIGH_MIN = 0n;\n\nexport class CairoUint256 {\n  public low: bigint;\n\n  public high: bigint;\n\n  static abiSelector = 'core::integer::u256';\n\n  /**\n   * Default constructor (Lib usage)\n   * @param bigNumberish BigNumberish value representing uin256\n   */\n  public constructor(bigNumberish: BigNumberish);\n  /**\n   * Direct props initialization (Api response)\n   */\n  public constructor(low: BigNumberish, high: BigNumberish);\n  /**\n   * Initialization from Uint256 object\n   */\n  public constructor(uint256: Uint256);\n\n  public constructor(...arr: any[]) {\n    if (typeof arr[0] === 'object' && arr.length === 1 && 'low' in arr[0] && 'high' in arr[0]) {\n      const props = CairoUint256.validateProps(arr[0].low, arr[0].high);\n      this.low = props.low;\n      this.high = props.high;\n    } else if (arr.length === 1) {\n      const bigInt = CairoUint256.validate(arr[0]);\n      this.low = bigInt & UINT_128_MAX;\n      this.high = bigInt >> 128n;\n    } else if (arr.length === 2) {\n      const props = CairoUint256.validateProps(arr[0], arr[1]);\n      this.low = props.low;\n      this.high = props.high;\n    } else {\n      throw Error('Incorrect constructor parameters');\n    }\n  }\n\n  /**\n   * Validate if BigNumberish can be represented as Unit256\n   */\n  static validate(bigNumberish: BigNumberish) {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_256_MIN) throw Error('bigNumberish is smaller than UINT_256_MIN');\n    if (bigInt > UINT_256_MAX) throw new Error('bigNumberish is bigger than UINT_256_MAX');\n    return bigInt;\n  }\n\n  /**\n   * Validate if low and high can be represented as Unit256\n   */\n  static validateProps(low: BigNumberish, high: BigNumberish) {\n    const bigIntLow = BigInt(low);\n    const bigIntHigh = BigInt(high);\n    if (bigIntLow < UINT_256_LOW_MIN || bigIntLow > UINT_256_LOW_MAX) {\n      throw new Error('low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX');\n    }\n    if (bigIntHigh < UINT_256_HIGH_MIN || bigIntHigh > UINT_256_HIGH_MAX) {\n      throw new Error('high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX');\n    }\n    return { low: bigIntLow, high: bigIntHigh };\n  }\n\n  /**\n   * Check if BigNumberish can be represented as Unit256\n   */\n  static is(bigNumberish: BigNumberish) {\n    try {\n      CairoUint256.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string) {\n    return abiType === CairoUint256.abiSelector;\n  }\n\n  /**\n   * Return bigint representation\n   */\n  toBigInt() {\n    return (this.high << 128n) + this.low;\n  }\n\n  /**\n   * Return Uint256 structure with HexString props\n   * {low: HexString, high: HexString}\n   */\n  toUint256HexString() {\n    return {\n      low: addHexPrefix(this.low.toString(16)),\n      high: addHexPrefix(this.high.toString(16)),\n    };\n  }\n\n  /**\n   * Return Uint256 structure with DecimalString props\n   * {low: DecString, high: DecString}\n   */\n  toUint256DecimalString() {\n    return {\n      low: this.low.toString(10),\n      high: this.high.toString(10),\n    };\n  }\n\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest() {\n    return [CairoFelt(this.low), CairoFelt(this.high)];\n  }\n}\n","/* eslint-disable no-bitwise */\n/**\n * Singular class handling cairo u512 data type\n */\n\nimport { BigNumberish, type Uint512 } from '../../types';\nimport { addHexPrefix } from '../encode';\nimport { CairoFelt } from './felt';\nimport { UINT_128_MAX } from './uint256';\n\nexport const UINT_512_MAX = (1n << 512n) - 1n;\nexport const UINT_512_MIN = 0n;\nexport const UINT_128_MIN = 0n;\n\nexport class CairoUint512 {\n  public limb0: bigint;\n\n  public limb1: bigint;\n\n  public limb2: bigint;\n\n  public limb3: bigint;\n\n  static abiSelector = 'core::integer::u512';\n\n  /**\n   * Default constructor (Lib usage)\n   * @param bigNumberish BigNumberish value representing u512\n   */\n  public constructor(bigNumberish: BigNumberish);\n  /**\n   * Direct props initialization (Api response)\n   */\n  public constructor(\n    limb0: BigNumberish,\n    limb1: BigNumberish,\n    limb2: BigNumberish,\n    limb3: BigNumberish\n  );\n  /**\n   * Initialization from Uint512 object\n   */\n  public constructor(uint512: Uint512);\n\n  public constructor(...arr: any[]) {\n    if (\n      typeof arr[0] === 'object' &&\n      arr.length === 1 &&\n      'limb0' in arr[0] &&\n      'limb1' in arr[0] &&\n      'limb2' in arr[0] &&\n      'limb3' in arr[0]\n    ) {\n      const props = CairoUint512.validateProps(\n        arr[0].limb0,\n        arr[0].limb1,\n        arr[0].limb2,\n        arr[0].limb3\n      );\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else if (arr.length === 1) {\n      const bigInt = CairoUint512.validate(arr[0]);\n      this.limb0 = bigInt & UINT_128_MAX;\n      this.limb1 = (bigInt & (UINT_128_MAX << 128n)) >> 128n;\n      this.limb2 = (bigInt & (UINT_128_MAX << 256n)) >> 256n;\n      this.limb3 = bigInt >> 384n;\n    } else if (arr.length === 4) {\n      const props = CairoUint512.validateProps(arr[0], arr[1], arr[2], arr[3]);\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else {\n      throw Error('Incorrect Uint512 constructor parameters');\n    }\n  }\n\n  /**\n   * Validate if BigNumberish can be represented as Uint512\n   */\n  static validate(bigNumberish: BigNumberish): bigint {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_512_MIN) throw Error('bigNumberish is smaller than UINT_512_MIN.');\n    if (bigInt > UINT_512_MAX) throw Error('bigNumberish is bigger than UINT_512_MAX.');\n    return bigInt;\n  }\n\n  /**\n   * Validate if limbs can be represented as Uint512\n   */\n  static validateProps(\n    limb0: BigNumberish,\n    limb1: BigNumberish,\n    limb2: BigNumberish,\n    limb3: BigNumberish\n  ): { limb0: bigint; limb1: bigint; limb2: bigint; limb3: bigint } {\n    const l0 = BigInt(limb0);\n    const l1 = BigInt(limb1);\n    const l2 = BigInt(limb2);\n    const l3 = BigInt(limb3);\n    [l0, l1, l2, l3].forEach((value: bigint, index) => {\n      if (value < UINT_128_MIN || value > UINT_128_MAX) {\n        throw Error(`limb${index} is not in the range of a u128 number`);\n      }\n    });\n    return { limb0: l0, limb1: l1, limb2: l2, limb3: l3 };\n  }\n\n  /**\n   * Check if BigNumberish can be represented as Uint512\n   */\n  static is(bigNumberish: BigNumberish): boolean {\n    try {\n      CairoUint512.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string): boolean {\n    return abiType === CairoUint512.abiSelector;\n  }\n\n  /**\n   * Return bigint representation\n   */\n  toBigInt(): bigint {\n    return (this.limb3 << 384n) + (this.limb2 << 256n) + (this.limb1 << 128n) + this.limb0;\n  }\n\n  /**\n   * Return Uint512 structure with HexString props\n   * limbx: HexString\n   */\n  toUint512HexString() {\n    return {\n      limb0: addHexPrefix(this.limb0.toString(16)),\n      limb1: addHexPrefix(this.limb1.toString(16)),\n      limb2: addHexPrefix(this.limb2.toString(16)),\n      limb3: addHexPrefix(this.limb3.toString(16)),\n    };\n  }\n\n  /**\n   * Return Uint512 structure with DecimalString props\n   * limbx DecString\n   */\n  toUint512DecimalString() {\n    return {\n      limb0: this.limb0.toString(10),\n      limb1: this.limb1.toString(10),\n      limb2: this.limb2.toString(10),\n      limb3: this.limb3.toString(10),\n    };\n  }\n\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest(): string[] {\n    // lower limb first : https://github.com/starkware-libs/cairo/blob/07484c52791b76abcc18fd86265756904557d0d2/corelib/src/test/integer_test.cairo#L767\n    return [\n      CairoFelt(this.limb0),\n      CairoFelt(this.limb1),\n      CairoFelt(this.limb2),\n      CairoFelt(this.limb3),\n    ];\n  }\n}\n","export type CairoEnumRaw = {\n  [key: string]: any;\n};\n\n/**\n * Class to handle Cairo custom Enum\n * @param enumContent object containing the variants and its content. Example :\n *  {Success: 234, Warning: undefined, Error: undefined}.\n *  Only one variant with a value, object, array.\n * @returns an instance representing a Cairo custom Enum.\n * @example\n * ```typescript\n * const myCairoEnum = new CairoCustomEnum( {Success: undefined, Warning: \"0x7f32ea\", Error: undefined})\n * ```\n */\nexport class CairoCustomEnum {\n  /**\n   * direct readonly access to variants of the Cairo Custom Enum.\n   * @returns a value of type any\n   * @example\n   * ```typescript\n   * const successValue = myCairoEnum.variant.Success;\n   */\n  readonly variant: CairoEnumRaw;\n\n  /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */\n  constructor(enumContent: CairoEnumRaw) {\n    const variantsList = Object.values(enumContent);\n    if (variantsList.length === 0) {\n      throw new Error('This Enum must have at least 1 variant');\n    }\n    const nbActiveVariants = variantsList.filter(\n      (content) => typeof content !== 'undefined'\n    ).length;\n    if (nbActiveVariants !== 1) {\n      throw new Error('This Enum must have exactly one active variant');\n    }\n    this.variant = enumContent;\n  }\n\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */\n  public unwrap(): any {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => typeof item[1] !== 'undefined');\n    if (typeof activeVariant === 'undefined') {\n      return undefined;\n    }\n    return activeVariant[1];\n  }\n\n  /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */\n  public activeVariant(): string {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => typeof item[1] !== 'undefined');\n    if (typeof activeVariant === 'undefined') {\n      return '';\n    }\n    return activeVariant[0];\n  }\n}\n","export enum CairoOptionVariant {\n  Some = 0,\n  None = 1,\n}\n\n/**\n * Class to handle Cairo Option\n * @param variant CairoOptionVariant.Some or CairoOptionVariant.None\n * @param someContent value of type T.\n * @returns an instance representing a Cairo Option.\n * @example\n * ```typescript\n * const myOption = new CairoOption<BigNumberish>(CairoOptionVariant.Some, \"0x54dda8\");\n * ```\n */\nexport class CairoOption<T> {\n  readonly Some?: T;\n\n  readonly None?: boolean;\n\n  constructor(variant: CairoOptionVariant, someContent?: T) {\n    if (!(variant in CairoOptionVariant)) {\n      throw new Error('Wrong variant : should be CairoOptionVariant.Some or .None.');\n    }\n    if (variant === CairoOptionVariant.Some) {\n      if (typeof someContent === 'undefined') {\n        throw new Error(\n          'The creation of a Cairo Option with \"Some\" variant needs a content as input.'\n        );\n      }\n      this.Some = someContent;\n      this.None = undefined;\n    } else {\n      this.Some = undefined;\n      this.None = true;\n    }\n  }\n\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */\n  public unwrap(): T | undefined {\n    if (this.None) {\n      return undefined;\n    }\n    return this.Some;\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */\n  public isSome(): boolean {\n    return !(typeof this.Some === 'undefined');\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */\n  public isNone(): boolean {\n    return this.None === true;\n  }\n}\n","export enum CairoResultVariant {\n  Ok = 0,\n  Err = 1,\n}\n\n/**\n * Class to handle Cairo Result\n * @param variant CairoResultVariant.Ok or CairoResultVariant.Err\n * @param resultContent value of type T or U.\n * @returns an instance representing a Cairo Result.\n * @example\n * ```typescript\n * const myOption = new CairoResult<BigNumberish, CustomError>(CairoResultVariant.Ok, \"0x54dda8\");\n * ```\n */\nexport class CairoResult<T, U> {\n  readonly Ok?: T;\n\n  readonly Err?: U;\n\n  constructor(variant: CairoResultVariant, resultContent: T | U) {\n    if (!(variant in CairoResultVariant)) {\n      throw new Error('Wrong variant : should be CairoResultVariant.Ok or .Err.');\n    }\n    if (variant === CairoResultVariant.Ok) {\n      this.Ok = resultContent as T;\n      this.Err = undefined;\n    } else {\n      this.Ok = undefined;\n      this.Err = resultContent as U;\n    }\n  }\n\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */\n  public unwrap(): T | U {\n    if (typeof this.Ok !== 'undefined') {\n      return this.Ok;\n    }\n    if (typeof this.Err !== 'undefined') {\n      return this.Err;\n    }\n    throw new Error('Both Result.Ok and .Err are undefined. Not authorized.');\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */\n  public isOk(): boolean {\n    return !(typeof this.Ok === 'undefined');\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */\n  public isErr(): boolean {\n    return !(typeof this.Err === 'undefined');\n  }\n}\n","import { isBigInt } from '../num';\nimport { decodeShortString } from '../shortString';\n\nconst guard = {\n  isBN: (data: Record<string, any>, type: Record<string, any>, key: string) => {\n    if (!isBigInt(data[key]))\n      throw new Error(\n        `Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${\n          data[key]\n        } to be BN instead it is ${typeof data[key]}`\n      );\n  },\n  unknown: (data: Record<string, any>, type: Record<string, any>, key: string) => {\n    throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n  },\n};\n\n/**\n * Formats the given data based on the provided type definition.\n *\n * @param {any} data - The data to be formatted.\n * @param {any} type - The type definition for the data.\n * @param {any} [sameType] - The same type definition to be used (optional).\n * @returns - The formatted data.\n */\nexport default function formatter(\n  data: Record<string, any>,\n  type: Record<string, any>,\n  sameType?: any\n) {\n  // match data element with type element\n  return Object.entries(data).reduce(\n    (acc, [key, value]: [any, any]) => {\n      const elType = sameType ?? type[key];\n\n      if (!(key in type) && !sameType) {\n        // no type definition for element return original element\n        acc[key] = value;\n        return acc;\n      }\n\n      if (elType === 'string') {\n        if (Array.isArray(data[key])) {\n          // long string (felt*)\n          const arrayStr = formatter(\n            data[key],\n            data[key].map((_: any) => elType)\n          );\n          acc[key] = Object.values(arrayStr).join('');\n          return acc;\n        }\n        guard.isBN(data, type, key);\n        acc[key] = decodeShortString(value);\n        return acc;\n      }\n      if (elType === 'number') {\n        guard.isBN(data, type, key);\n        acc[key] = Number(value);\n        return acc;\n      }\n      if (typeof elType === 'function') {\n        acc[key] = elType(value);\n        return acc;\n      }\n      if (Array.isArray(elType)) {\n        const arrayObj = formatter(data[key], elType, elType[0]);\n        acc[key] = Object.values(arrayObj);\n        return acc;\n      }\n      if (typeof elType === 'object') {\n        acc[key] = formatter(data[key], elType);\n        return acc;\n      }\n\n      guard.unknown(data, type, key);\n      return acc;\n    },\n    {} as Record<string, any>\n  );\n}\n","import { Abi, FunctionAbi } from '../../../types';\nimport { isLen } from '../cairo';\nimport { AbiParserInterface } from './interface';\n\nexport class AbiParser1 implements AbiParserInterface {\n  abi: Abi;\n\n  constructor(abi: Abi) {\n    this.abi = abi;\n  }\n\n  /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  public methodInputsLength(abiMethod: FunctionAbi) {\n    return abiMethod.inputs.reduce((acc, input) => (!isLen(input.name) ? acc + 1 : acc), 0);\n  }\n\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  public getMethod(name: string): FunctionAbi | undefined {\n    return this.abi.find((it) => it.name === name);\n  }\n\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  public getLegacyFormat() {\n    return this.abi;\n  }\n}\n","import {\n  Abi,\n  FunctionAbi,\n  AbiEvent,\n  AbiStruct,\n  InterfaceAbi,\n  type LegacyEvent,\n} from '../../../types';\nimport { AbiParserInterface } from './interface';\n\nexport class AbiParser2 implements AbiParserInterface {\n  abi: Abi;\n\n  constructor(abi: Abi) {\n    this.abi = abi;\n  }\n\n  /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  public methodInputsLength(abiMethod: FunctionAbi) {\n    return abiMethod.inputs.length;\n  }\n\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  public getMethod(name: string): FunctionAbi | undefined {\n    const intf = this.abi.find(\n      (it: FunctionAbi | AbiEvent | AbiStruct | InterfaceAbi) => it.type === 'interface'\n    ) as InterfaceAbi;\n    return intf.items.find((it) => it.name === name);\n  }\n\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  public getLegacyFormat(): Abi {\n    return this.abi.flatMap((e: FunctionAbi | LegacyEvent | AbiStruct | InterfaceAbi) => {\n      if (e.type === 'interface') {\n        return e.items;\n      }\n      return e;\n    });\n  }\n}\n","import { Abi, FunctionAbi, RawArgs } from '../../../types';\nimport { isCairo1Abi } from '../cairo';\nimport { AbiParserInterface } from './interface';\nimport { AbiParser1 } from './parser-0-1.1.0';\nimport { AbiParser2 } from './parser-2.0.0';\n\nexport function createAbiParser(abi: Abi): AbiParserInterface {\n  const version = getAbiVersion(abi);\n  if (version === 0 || version === 1) {\n    return new AbiParser1(abi);\n  }\n  if (version === 2) {\n    return new AbiParser2(abi);\n  }\n  throw Error(`Unsupported ABI version ${version}`);\n}\n\nexport function getAbiVersion(abi: Abi) {\n  if (abi.find((it) => it.type === 'interface')) return 2;\n  if (isCairo1Abi(abi)) return 1;\n  return 0;\n}\n\nexport function isNoConstructorValid(\n  method: string,\n  argsCalldata: RawArgs,\n  abiMethod?: FunctionAbi\n) {\n  // No constructor in abi and validly empty args\n  return method === 'constructor' && !abiMethod && !argsCalldata.length;\n}\n","/* eslint-disable no-plusplus */\nimport { isCairo1Type, isTypeNamedTuple } from './cairo';\n\nfunction parseNamedTuple(namedTuple: string): any {\n  const name = namedTuple.substring(0, namedTuple.indexOf(':'));\n  const type = namedTuple.substring(name.length + ':'.length);\n  return { name, type };\n}\n\nfunction parseSubTuple(s: string) {\n  if (!s.includes('(')) return { subTuple: [], result: s };\n  const subTuple: string[] = [];\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === '(') {\n      let counter = 1;\n      const lBracket = i;\n      i++;\n      while (counter) {\n        if (s[i] === ')') counter--;\n        if (s[i] === '(') counter++;\n        i++;\n      }\n      subTuple.push(s.substring(lBracket, i));\n      result += ' ';\n      i--;\n    } else {\n      result += s[i];\n    }\n    i++;\n  }\n\n  return {\n    subTuple,\n    result,\n  };\n}\n\nfunction extractCairo0Tuple(type: string) {\n  const cleanType = type.replace(/\\s/g, '').slice(1, -1); // remove first lvl () and spaces\n\n  // Decompose subTuple\n  const { subTuple, result } = parseSubTuple(cleanType);\n\n  // Recompose subTuple\n  let recomposed = result.split(',').map((it) => {\n    return subTuple.length ? it.replace(' ', subTuple.shift() as string) : it;\n  });\n\n  // Parse named tuple\n  if (isTypeNamedTuple(type)) {\n    recomposed = recomposed.reduce((acc, it) => {\n      return acc.concat(parseNamedTuple(it));\n    }, []);\n  }\n\n  return recomposed;\n}\n\nfunction getClosureOffset(input: string, open: string, close: string): number {\n  for (let i = 0, counter = 0; i < input.length; i++) {\n    if (input[i] === open) {\n      counter++;\n    } else if (input[i] === close && --counter === 0) {\n      return i;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n}\n\nfunction extractCairo1Tuple(type: string): string[] {\n  // un-named tuples support\n  const input = type.slice(1, -1); // remove first lvl ()\n  const result: string[] = [];\n\n  let currentIndex: number = 0;\n  let limitIndex: number;\n\n  while (currentIndex < input.length) {\n    switch (true) {\n      // Tuple\n      case input[currentIndex] === '(': {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), '(', ')') + 1;\n        break;\n      }\n      case input.startsWith('core::result::Result::<', currentIndex) ||\n        input.startsWith('core::array::Array::<', currentIndex) ||\n        input.startsWith('core::option::Option::<', currentIndex): {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), '<', '>') + 1;\n        break;\n      }\n      default: {\n        const commaIndex = input.indexOf(',', currentIndex);\n        limitIndex = commaIndex !== -1 ? commaIndex : Number.POSITIVE_INFINITY;\n      }\n    }\n\n    result.push(input.slice(currentIndex, limitIndex));\n    currentIndex = limitIndex + 2; // +2 to skip ', '\n  }\n\n  return result;\n}\n\n/**\n * Convert tuple string definition into object like definition\n * @param type tuple string definition\n * @returns object like tuple\n */\nexport default function extractTupleMemberTypes(type: string): (string | object)[] {\n  if (isCairo1Type(type)) {\n    return extractCairo1Tuple(type);\n  }\n  return extractCairo0Tuple(type);\n}\n","import { AbiEntry, AbiEnums, AbiStructs, CairoEnum, RawArgsObject } from '../../types';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\nimport {\n  getArrayType,\n  isCairo1Type,\n  isLen,\n  isTypeArray,\n  isTypeByteArray,\n  isTypeEnum,\n  isTypeEthAddress,\n  isTypeNonZero,\n  isTypeOption,\n  isTypeResult,\n  isTypeSecp256k1Point,\n  isTypeStruct,\n  isTypeTuple,\n} from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport extractTupleMemberTypes from './tuple';\n\nimport { isString } from '../shortString';\n\nfunction errorU256(key: string) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`\n  );\n}\n\nfunction errorU512(key: string) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint512 object without the 'limb0' to 'limb3' keys.`\n  );\n}\n\nexport default function orderPropsByAbi(\n  unorderedObject: RawArgsObject,\n  abiOfObject: AbiEntry[],\n  structs: AbiStructs,\n  enums: AbiEnums\n): object {\n  const orderInput = (unorderedItem: any, abiType: string): any => {\n    if (isTypeArray(abiType)) {\n      return orderArray(unorderedItem, abiType);\n    }\n    if (isTypeEnum(abiType, enums)) {\n      const abiObj = enums[abiType];\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return orderEnum(unorderedItem, abiObj);\n    }\n    if (isTypeTuple(abiType)) {\n      return orderTuple(unorderedItem, abiType);\n    }\n    if (isTypeEthAddress(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeNonZero(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeByteArray(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeSecp256k1Point(abiType)) {\n      return unorderedItem;\n    }\n    if (CairoUint256.isAbiType(abiType)) {\n      const u256 = unorderedItem;\n      if (typeof u256 !== 'object') {\n        // BigNumberish --> just copy\n        return u256;\n      }\n      if (!('low' in u256 && 'high' in u256)) {\n        throw errorU256(abiType);\n      }\n      return { low: u256.low, high: u256.high };\n    }\n    if (CairoUint512.isAbiType(abiType)) {\n      const u512 = unorderedItem;\n      if (typeof u512 !== 'object') {\n        // BigNumberish --> just copy\n        return u512;\n      }\n      if (!['limb0', 'limb1', 'limb2', 'limb3'].every((key) => key in u512)) {\n        throw errorU512(abiType);\n      }\n      return { limb0: u512.limb0, limb1: u512.limb1, limb2: u512.limb2, limb3: u512.limb3 };\n    }\n    if (isTypeStruct(abiType, structs)) {\n      const abiOfStruct = structs[abiType].members;\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return orderStruct(unorderedItem, abiOfStruct);\n    }\n    // literals\n    return unorderedItem;\n  };\n\n  const orderStruct = (unorderedObject2: RawArgsObject, abiObject: AbiEntry[]): object => {\n    const orderedObject2 = abiObject.reduce((orderedObject, abiParam) => {\n      const setProperty = (value?: any) =>\n        Object.defineProperty(orderedObject, abiParam.name, {\n          enumerable: true,\n          value: value ?? unorderedObject2[abiParam.name],\n        });\n\n      if (unorderedObject2[abiParam.name] === 'undefined') {\n        if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n          throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n        }\n      }\n      setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  };\n\n  function orderArray(myArray: Array<any> | string, abiParam: string): Array<any> | string {\n    const typeInArray = getArrayType(abiParam);\n    if (isString(myArray)) {\n      return myArray; // longstring\n    }\n    return myArray.map((myElem) => orderInput(myElem, typeInArray));\n  }\n\n  function orderTuple(unorderedObject2: RawArgsObject, abiParam: string): object {\n    const typeList = extractTupleMemberTypes(abiParam);\n    const orderedObject2 = typeList.reduce((orderedObject: object, abiTypeCairoX: any, index) => {\n      const myObjKeys: string[] = Object.keys(unorderedObject2);\n      const setProperty = (value?: any) =>\n        Object.defineProperty(orderedObject, index.toString(), {\n          enumerable: true,\n          value: value ?? unorderedObject2[myObjKeys[index]],\n        });\n      const abiType: string = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX; // Named tuple, or tuple\n      setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  }\n\n  const orderEnum = (unorderedObject2: CairoEnum, abiObject: AbiEntry): CairoEnum => {\n    if (isTypeResult(abiObject.name)) {\n      const unorderedResult = unorderedObject2 as CairoResult<any, any>;\n      const resultOkType: string = abiObject.name.substring(\n        abiObject.name.indexOf('<') + 1,\n        abiObject.name.lastIndexOf(',')\n      );\n      const resultErrType: string = abiObject.name.substring(\n        abiObject.name.indexOf(',') + 1,\n        abiObject.name.lastIndexOf('>')\n      );\n      if (unorderedResult.isOk()) {\n        return new CairoResult<any, any>(\n          CairoResultVariant.Ok,\n          orderInput(unorderedObject2.unwrap(), resultOkType)\n        );\n      }\n      return new CairoResult<any, any>(\n        CairoResultVariant.Err,\n        orderInput(unorderedObject2.unwrap(), resultErrType)\n      );\n    }\n    if (isTypeOption(abiObject.name)) {\n      const unorderedOption = unorderedObject2 as CairoOption<any>;\n      const resultSomeType: string = abiObject.name.substring(\n        abiObject.name.indexOf('<') + 1,\n        abiObject.name.lastIndexOf('>')\n      );\n      if (unorderedOption.isSome()) {\n        return new CairoOption<any>(\n          CairoOptionVariant.Some,\n          orderInput(unorderedOption.unwrap(), resultSomeType)\n        );\n      }\n      // none(())\n      return new CairoOption<any>(CairoOptionVariant.None, {});\n    }\n    // custom Enum\n    const unorderedCustomEnum = unorderedObject2 as CairoCustomEnum;\n    const variants = Object.entries(unorderedCustomEnum.variant);\n    const newEntries = variants.map((variant) => {\n      if (typeof variant[1] === 'undefined') {\n        return variant;\n      }\n      const variantType: string = abiObject.type.substring(\n        abiObject.type.lastIndexOf('<') + 1,\n        abiObject.type.lastIndexOf('>')\n      );\n      if (variantType === '()') {\n        return variant;\n      }\n      return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];\n    });\n    return new CairoCustomEnum(Object.fromEntries(newEntries));\n  };\n\n  // Order Call Parameters\n  const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam) => {\n    const setProperty = (value: any) =>\n      Object.defineProperty(orderedObject, abiParam.name, {\n        enumerable: true,\n        value,\n      });\n    if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n      return orderedObject;\n    }\n    setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n    return orderedObject;\n  }, {});\n  return finalOrderedObject;\n}\n","import {\n  AbiEntry,\n  AbiEnums,\n  AbiStructs,\n  AllowArray,\n  BigNumberish,\n  ByteArray,\n  CairoEnum,\n  ParsedStruct,\n  Tupled,\n} from '../../types';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\nimport { addHexPrefix, removeHexPrefix } from '../encode';\nimport { toHex } from '../num';\nimport { encodeShortString, isString, isText, splitLongString } from '../shortString';\nimport { byteArrayFromString } from './byteArray';\nimport {\n  felt,\n  getArrayType,\n  isTypeArray,\n  isTypeBytes31,\n  isTypeEnum,\n  isTypeNonZero,\n  isTypeOption,\n  isTypeResult,\n  isTypeSecp256k1Point,\n  isTypeStruct,\n  isTypeTuple,\n  uint256,\n} from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport extractTupleMemberTypes from './tuple';\n\n/**\n * parse base types\n * @param type type from abi\n * @param val value provided\n * @returns string | string[]\n */\nfunction parseBaseTypes(type: string, val: BigNumberish): AllowArray<string> {\n  switch (true) {\n    case CairoUint256.isAbiType(type):\n      return new CairoUint256(val).toApiRequest();\n    case CairoUint512.isAbiType(type):\n      return new CairoUint512(val).toApiRequest();\n    case isTypeBytes31(type):\n      return encodeShortString(val.toString());\n    case isTypeSecp256k1Point(type): {\n      const pubKeyETH = removeHexPrefix(toHex(val)).padStart(128, '0');\n      const pubKeyETHy = uint256(addHexPrefix(pubKeyETH.slice(-64)));\n      const pubKeyETHx = uint256(addHexPrefix(pubKeyETH.slice(0, -64)));\n      return [\n        felt(pubKeyETHx.low),\n        felt(pubKeyETHx.high),\n        felt(pubKeyETHy.low),\n        felt(pubKeyETHy.high),\n      ];\n    }\n    default:\n      return felt(val);\n  }\n}\n\n/**\n * Parse tuple type string to array of known objects\n * @param element request element\n * @param typeStr tuple type string\n * @returns Tupled[]\n */\nfunction parseTuple(element: object, typeStr: string): Tupled[] {\n  const memberTypes = extractTupleMemberTypes(typeStr);\n  const elements = Object.values(element);\n\n  if (elements.length !== memberTypes.length) {\n    throw Error(\n      `ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`\n    );\n  }\n\n  return memberTypes.map((it: any, dx: number) => {\n    return {\n      element: elements[dx],\n      type: it.type ?? it,\n    };\n  });\n}\n\nfunction parseByteArray(element: string): string[] {\n  const myByteArray: ByteArray = byteArrayFromString(element);\n  return [\n    myByteArray.data.length.toString(),\n    ...myByteArray.data.map((bn) => bn.toString()),\n    myByteArray.pending_word.toString(),\n    myByteArray.pending_word_len.toString(),\n  ];\n}\n\n/**\n * Deep parse of the object that has been passed to the method\n *\n * @param element - element that needs to be parsed\n * @param type  - name of the method\n * @param structs - structs from abi\n * @param enums - enums from abi\n * @return {string | string[]} - parsed arguments in format that contract is expecting\n */\nfunction parseCalldataValue(\n  element:\n    | ParsedStruct\n    | BigNumberish\n    | BigNumberish[]\n    | CairoOption<any>\n    | CairoResult<any, any>\n    | CairoEnum,\n  type: string,\n  structs: AbiStructs,\n  enums: AbiEnums\n): string | string[] {\n  if (element === undefined) {\n    throw Error(`Missing parameter for type ${type}`);\n  }\n\n  // value is Array\n  if (Array.isArray(element)) {\n    const result: string[] = [];\n    result.push(felt(element.length)); // Add length to array\n    const arrayType = getArrayType(type);\n\n    return element.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n    }, result);\n  }\n\n  // checking if the passed element is struct\n  if (structs[type] && structs[type].members.length) {\n    if (CairoUint256.isAbiType(type)) {\n      return new CairoUint256(element as any).toApiRequest();\n    }\n    if (CairoUint512.isAbiType(type)) {\n      return new CairoUint512(element as any).toApiRequest();\n    }\n    if (type === 'core::starknet::eth_address::EthAddress')\n      return parseBaseTypes(type, element as BigNumberish);\n\n    if (type === 'core::byte_array::ByteArray') return parseByteArray(element as string);\n\n    const { members } = structs[type];\n    const subElement = element as any;\n\n    return members.reduce((acc, it: AbiEntry) => {\n      return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n    }, [] as string[]);\n  }\n  // check if abi element is tuple\n  if (isTypeTuple(type)) {\n    const tupled = parseTuple(element as object, type);\n\n    return tupled.reduce((acc, it: Tupled) => {\n      const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n      return acc.concat(parsedData);\n    }, [] as string[]);\n  }\n  // check if u256 C1v0\n  if (CairoUint256.isAbiType(type)) {\n    return new CairoUint256(element as any).toApiRequest();\n  }\n  // check if u512\n  if (CairoUint512.isAbiType(type)) {\n    return new CairoUint512(element as any).toApiRequest();\n  }\n  // check if Enum\n  if (isTypeEnum(type, enums)) {\n    const { variants } = enums[type];\n    // Option Enum\n    if (isTypeOption(type)) {\n      const myOption = element as CairoOption<any>;\n      if (myOption.isSome()) {\n        const listTypeVariant = variants.find((variant) => variant.name === 'Some');\n        if (typeof listTypeVariant === 'undefined') {\n          throw Error(`Error in abi : Option has no 'Some' variant.`);\n        }\n        const typeVariantSome = listTypeVariant.type;\n        if (typeVariantSome === '()') {\n          return CairoOptionVariant.Some.toString();\n        }\n        const parsedParameter = parseCalldataValue(\n          myOption.unwrap(),\n          typeVariantSome,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter)) {\n          return [CairoOptionVariant.Some.toString(), ...parsedParameter];\n        }\n        return [CairoOptionVariant.Some.toString(), parsedParameter];\n      }\n      return CairoOptionVariant.None.toString();\n    }\n    // Result Enum\n    if (isTypeResult(type)) {\n      const myResult = element as CairoResult<any, any>;\n      if (myResult.isOk()) {\n        const listTypeVariant = variants.find((variant) => variant.name === 'Ok');\n        if (typeof listTypeVariant === 'undefined') {\n          throw Error(`Error in abi : Result has no 'Ok' variant.`);\n        }\n        const typeVariantOk = listTypeVariant.type;\n        if (typeVariantOk === '()') {\n          return CairoResultVariant.Ok.toString();\n        }\n        const parsedParameter = parseCalldataValue(\n          myResult.unwrap(),\n          typeVariantOk,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter)) {\n          return [CairoResultVariant.Ok.toString(), ...parsedParameter];\n        }\n        return [CairoResultVariant.Ok.toString(), parsedParameter];\n      }\n      // is Result::Err\n      const listTypeVariant = variants.find((variant) => variant.name === 'Err');\n      if (typeof listTypeVariant === 'undefined') {\n        throw Error(`Error in abi : Result has no 'Err' variant.`);\n      }\n      const typeVariantErr = listTypeVariant.type;\n      if (typeVariantErr === '()') {\n        return CairoResultVariant.Err.toString();\n      }\n      const parsedParameter = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n      if (Array.isArray(parsedParameter)) {\n        return [CairoResultVariant.Err.toString(), ...parsedParameter];\n      }\n      return [CairoResultVariant.Err.toString(), parsedParameter];\n    }\n    // Custom Enum\n    const myEnum = element as CairoCustomEnum;\n    const activeVariant: string = myEnum.activeVariant();\n    const listTypeVariant = variants.find((variant) => variant.name === activeVariant);\n    if (typeof listTypeVariant === 'undefined') {\n      throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n    }\n    const typeActiveVariant = listTypeVariant.type;\n    const numActiveVariant = variants.findIndex((variant) => variant.name === activeVariant); // can not fail due to check of listTypeVariant\n    if (typeActiveVariant === '()') {\n      return numActiveVariant.toString();\n    }\n    const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n    if (Array.isArray(parsedParameter)) {\n      return [numActiveVariant.toString(), ...parsedParameter];\n    }\n    return [numActiveVariant.toString(), parsedParameter];\n  }\n\n  if (isTypeNonZero(type)) {\n    return parseBaseTypes(getArrayType(type), element as BigNumberish);\n  }\n\n  if (typeof element === 'object') {\n    throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n  }\n  return parseBaseTypes(type, element);\n}\n\n/**\n * Parse one field of the calldata by using input field from the abi for that method\n *\n * @param argsIterator - Iterator for value of the field\n * @param input  - input(field) information from the abi that will be used to parse the data\n * @param structs - structs from abi\n * @param enums - enums from abi\n * @return {string | string[]} - parsed arguments in format that contract is expecting\n */\nexport function parseCalldataField(\n  argsIterator: Iterator<any>,\n  input: AbiEntry,\n  structs: AbiStructs,\n  enums: AbiEnums\n): string | string[] {\n  const { name, type } = input;\n  let { value } = argsIterator.next();\n\n  switch (true) {\n    // Array\n    case isTypeArray(type):\n      if (!Array.isArray(value) && !isText(value)) {\n        throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n      }\n      if (isString(value)) {\n        // long string match cairo felt*\n        value = splitLongString(value);\n      }\n      return parseCalldataValue(value, input.type, structs, enums);\n    case isTypeNonZero(type):\n      return parseBaseTypes(getArrayType(type), value);\n    case type === 'core::starknet::eth_address::EthAddress':\n      return parseBaseTypes(type, value);\n    // Struct or Tuple\n    case isTypeStruct(type, structs) ||\n      isTypeTuple(type) ||\n      CairoUint256.isAbiType(type) ||\n      CairoUint256.isAbiType(type):\n      return parseCalldataValue(value as ParsedStruct | BigNumberish[], type, structs, enums);\n\n    // Enums\n    case isTypeEnum(type, enums):\n      return parseCalldataValue(\n        value as CairoOption<any> | CairoResult<any, any> | CairoEnum,\n        type,\n        structs,\n        enums\n      );\n\n    // Felt or unhandled\n    default:\n      return parseBaseTypes(type, value);\n  }\n}\n","/* eslint-disable no-case-declarations */\nimport {\n  AbiEntry,\n  AbiEnums,\n  AbiStructs,\n  Args,\n  BigNumberish,\n  ByteArray,\n  CairoEnum,\n  EventEntry,\n  ParsedStruct,\n} from '../../types';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\nimport { addHexPrefix, removeHexPrefix } from '../encode';\nimport { toHex } from '../num';\nimport { decodeShortString } from '../shortString';\nimport { stringFromByteArray } from './byteArray';\nimport {\n  getArrayType,\n  isCairo1Type,\n  isLen,\n  isTypeArray,\n  isTypeBool,\n  isTypeByteArray,\n  isTypeEnum,\n  isTypeNonZero,\n  isTypeSecp256k1Point,\n  isTypeTuple,\n} from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoEnumRaw,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport extractTupleMemberTypes from './tuple';\n\n/**\n * Parse base types\n * @param type type of element\n * @param it iterator\n * @returns bigint | boolean\n */\nfunction parseBaseTypes(type: string, it: Iterator<string>) {\n  let temp;\n  switch (true) {\n    case isTypeBool(type):\n      temp = it.next().value;\n      return Boolean(BigInt(temp));\n    case CairoUint256.isAbiType(type):\n      const low = it.next().value;\n      const high = it.next().value;\n      return new CairoUint256(low, high).toBigInt();\n    case CairoUint512.isAbiType(type):\n      const limb0 = it.next().value;\n      const limb1 = it.next().value;\n      const limb2 = it.next().value;\n      const limb3 = it.next().value;\n      return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n    case type === 'core::starknet::eth_address::EthAddress':\n      temp = it.next().value;\n      return BigInt(temp);\n    case type === 'core::bytes_31::bytes31':\n      temp = it.next().value;\n      return decodeShortString(temp);\n    case isTypeSecp256k1Point(type):\n      const xLow = removeHexPrefix(it.next().value).padStart(32, '0');\n      const xHigh = removeHexPrefix(it.next().value).padStart(32, '0');\n      const yLow = removeHexPrefix(it.next().value).padStart(32, '0');\n      const yHigh = removeHexPrefix(it.next().value).padStart(32, '0');\n      const pubK = BigInt(addHexPrefix(xHigh + xLow + yHigh + yLow));\n      return pubK;\n    default:\n      temp = it.next().value;\n      return BigInt(temp);\n  }\n}\n\n/**\n * Parse of the response elements that are converted to Object (Struct) by using the abi\n *\n * @param responseIterator - iterator of the response\n * @param element - element of the field {name: string, type: string}\n * @param structs - structs from abi\n * @param enums\n * @return {any} - parsed arguments in format that contract is expecting\n */\nfunction parseResponseValue(\n  responseIterator: Iterator<string>,\n  element: { name: string; type: string },\n  structs?: AbiStructs,\n  enums?: AbiEnums\n): BigNumberish | ParsedStruct | boolean | any[] | CairoEnum {\n  if (element.type === '()') {\n    return {};\n  }\n  // type uint256 struct (c1v2)\n  if (CairoUint256.isAbiType(element.type)) {\n    const low = responseIterator.next().value;\n    const high = responseIterator.next().value;\n    return new CairoUint256(low, high).toBigInt();\n  }\n  // type uint512 struct\n  if (CairoUint512.isAbiType(element.type)) {\n    const limb0 = responseIterator.next().value;\n    const limb1 = responseIterator.next().value;\n    const limb2 = responseIterator.next().value;\n    const limb3 = responseIterator.next().value;\n    return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n  }\n  // type C1 ByteArray struct, representing a LongString\n  if (isTypeByteArray(element.type)) {\n    const parsedBytes31Arr: BigNumberish[] = [];\n    const bytes31ArrLen = BigInt(responseIterator.next().value);\n    while (parsedBytes31Arr.length < bytes31ArrLen) {\n      parsedBytes31Arr.push(toHex(responseIterator.next().value));\n    }\n    const pending_word = toHex(responseIterator.next().value);\n    const pending_word_len = BigInt(responseIterator.next().value);\n    const myByteArray: ByteArray = {\n      data: parsedBytes31Arr,\n      pending_word,\n      pending_word_len,\n    };\n    return stringFromByteArray(myByteArray);\n  }\n\n  // type c1 array\n  if (isTypeArray(element.type)) {\n    // eslint-disable-next-line no-case-declarations\n    const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el: AbiEntry = { name: '', type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value); // get length\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n\n  // type NonZero\n  if (isTypeNonZero(element.type)) {\n    // eslint-disable-next-line no-case-declarations\n    // const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el: AbiEntry = { name: '', type: getArrayType(element.type) };\n    // parsedDataArr.push();\n    return parseResponseValue(responseIterator, el, structs, enums);\n  }\n\n  // type struct\n  if (structs && element.type in structs && structs[element.type]) {\n    if (element.type === 'core::starknet::eth_address::EthAddress') {\n      return parseBaseTypes(element.type, responseIterator);\n    }\n    return structs[element.type].members.reduce((acc, el) => {\n      acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {} as any);\n  }\n\n  // type Enum (only CustomEnum)\n  if (enums && element.type in enums && enums[element.type]) {\n    const variantNum: number = Number(responseIterator.next().value); // get variant number\n    const rawEnum = enums[element.type].variants.reduce((acc, variant, num) => {\n      if (num === variantNum) {\n        acc[variant.name] = parseResponseValue(\n          responseIterator,\n          { name: '', type: variant.type },\n          structs,\n          enums\n        );\n        return acc;\n      }\n      acc[variant.name] = undefined;\n      return acc;\n    }, {} as CairoEnumRaw);\n    // Option\n    if (element.type.startsWith('core::option::Option')) {\n      const content = variantNum === CairoOptionVariant.Some ? rawEnum.Some : undefined;\n      return new CairoOption<Object>(variantNum, content);\n    }\n    // Result\n    if (element.type.startsWith('core::result::Result')) {\n      let content: Object;\n      if (variantNum === CairoResultVariant.Ok) {\n        content = rawEnum.Ok;\n      } else {\n        content = rawEnum.Err;\n      }\n      return new CairoResult<Object, Object>(variantNum, content);\n    }\n    // Cairo custom Enum\n    const customEnum = new CairoCustomEnum(rawEnum);\n    return customEnum;\n  }\n\n  // type tuple\n  if (isTypeTuple(element.type)) {\n    const memberTypes = extractTupleMemberTypes(element.type);\n    return memberTypes.reduce((acc, it: any, idx) => {\n      const name = it?.name ? it.name : idx;\n      const type = it?.type ? it.type : it;\n      const el = { name, type };\n      acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {} as any);\n  }\n\n  // type c1 array\n  if (isTypeArray(element.type)) {\n    // eslint-disable-next-line no-case-declarations\n    const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el = { name: '', type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value); // get length\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n\n  // base type\n  return parseBaseTypes(element.type, responseIterator);\n}\n\n/**\n * Parse elements of the response and structuring them into one field by using output property from the abi for that method\n *\n * @param responseIterator - iterator of the response\n * @param output - output(field) information from the abi that will be used to parse the data\n * @param structs - structs from abi\n * @param parsedResult\n * @return - parsed response corresponding to the abi structure of the field\n */\nexport default function responseParser(\n  responseIterator: Iterator<string>,\n  output: AbiEntry | EventEntry,\n  structs?: AbiStructs,\n  enums?: AbiEnums,\n  parsedResult?: Args | ParsedStruct\n): any {\n  const { name, type } = output;\n  let temp;\n\n  switch (true) {\n    case isLen(name):\n      temp = responseIterator.next().value;\n      return BigInt(temp);\n\n    case (structs && type in structs) || isTypeTuple(type):\n      return parseResponseValue(responseIterator, output, structs, enums);\n\n    case enums && isTypeEnum(type, enums):\n      return parseResponseValue(responseIterator, output, structs, enums);\n\n    case isTypeArray(type):\n      // C1 Array\n      if (isCairo1Type(type)) {\n        return parseResponseValue(responseIterator, output, structs, enums);\n      }\n      // C0 Array\n      // eslint-disable-next-line no-case-declarations\n      const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n      if (parsedResult && parsedResult[`${name}_len`]) {\n        const arrLen = parsedResult[`${name}_len`] as number;\n        while (parsedDataArr.length < arrLen) {\n          parsedDataArr.push(\n            parseResponseValue(\n              responseIterator,\n              { name, type: output.type.replace('*', '') },\n              structs,\n              enums\n            )\n          );\n        }\n      }\n      return parsedDataArr;\n\n    case isTypeNonZero(type):\n      return parseResponseValue(responseIterator, output, structs, enums);\n\n    default:\n      return parseBaseTypes(type, responseIterator);\n  }\n}\n","/**\n * Validate cairo contract method arguments\n * Flow: Determine type from abi and than validate against parameter\n */\nimport {\n  AbiEntry,\n  AbiEnums,\n  AbiStructs,\n  BigNumberish,\n  FunctionAbi,\n  Literal,\n  Uint,\n} from '../../types';\nimport assert from '../assert';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { CairoUint512 } from '../cairoDataTypes/uint512';\nimport { isBigInt, isBoolean, isHex, isNumber, toBigInt } from '../num';\nimport { isLongText, isString } from '../shortString';\nimport {\n  getArrayType,\n  isLen,\n  isTypeArray,\n  isTypeBool,\n  isTypeByteArray,\n  isTypeBytes31,\n  isTypeEnum,\n  isTypeFelt,\n  isTypeLiteral,\n  isTypeNonZero,\n  isTypeOption,\n  isTypeResult,\n  isTypeStruct,\n  isTypeTuple,\n  isTypeUint,\n} from './cairo';\n\nconst validateFelt = (parameter: any, input: AbiEntry) => {\n  assert(\n    isString(parameter) || isNumber(parameter) || isBigInt(parameter),\n    `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`\n  );\n  if (isString(parameter) && !isHex(parameter)) return; // shortstring\n  const param = BigInt(parameter.toString(10));\n  assert(\n    // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n  );\n};\n\nconst validateBytes31 = (parameter: any, input: AbiEntry) => {\n  assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n  assert(\n    parameter.length < 32,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be a string of less than 32 characters.`\n  );\n};\n\nconst validateByteArray = (parameter: any, input: AbiEntry) => {\n  assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n};\n\nconst validateUint = (parameter: any, input: AbiEntry) => {\n  if (isNumber(parameter)) {\n    assert(\n      parameter <= Number.MAX_SAFE_INTEGER,\n      `Validation: Parameter is to large to be typed as Number use (BigInt or String)`\n    );\n  }\n  assert(\n    isString(parameter) ||\n      isNumber(parameter) ||\n      isBigInt(parameter) ||\n      (typeof parameter === 'object' && 'low' in parameter && 'high' in parameter) ||\n      (typeof parameter === 'object' &&\n        ['limb0', 'limb1', 'limb2', 'limb3'].every((key) => key in parameter)),\n    `Validate: arg ${input.name} of cairo type ${\n      input.type\n    } should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`\n  );\n  let param: bigint;\n  switch (input.type) {\n    case Uint.u256:\n      param = new CairoUint256(parameter).toBigInt();\n      break;\n    case Uint.u512:\n      param = new CairoUint512(parameter).toBigInt();\n      break;\n    default:\n      param = toBigInt(parameter);\n  }\n  switch (input.type) {\n    case Uint.u8:\n      assert(\n        param >= 0n && param <= 255n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`\n      );\n      break;\n\n    case Uint.u16:\n      assert(\n        param >= 0n && param <= 65535n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`\n      );\n      break;\n\n    case Uint.u32:\n      assert(\n        param >= 0n && param <= 4294967295n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`\n      );\n      break;\n\n    case Uint.u64:\n      assert(\n        param >= 0n && param <= 2n ** 64n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`\n      );\n      break;\n\n    case Uint.u128:\n      assert(\n        param >= 0n && param <= 2n ** 128n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`\n      );\n      break;\n\n    case Uint.u256:\n      assert(\n        param >= 0n && param <= 2n ** 256n - 1n,\n        `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`\n      );\n      break;\n\n    case Uint.u512:\n      assert(CairoUint512.is(param), `Validate: arg ${input.name} is ${input.type} 0 - 2^512-1`);\n      break;\n\n    case Literal.ClassHash:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n\n    case Literal.ContractAddress:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    case Literal.Secp256k1Point: {\n      assert(\n        param >= 0n && param <= 2n ** 512n - 1n,\n        `Validate: arg ${input.name} must be ${input.type} : a 512 bits number.`\n      );\n      break;\n    }\n\n    default:\n      break;\n  }\n};\n\nconst validateBool = (parameter: any, input: AbiEntry) => {\n  assert(\n    isBoolean(parameter),\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`\n  );\n};\n\nconst validateStruct = (parameter: any, input: AbiEntry, structs: AbiStructs) => {\n  // c1v2 uint256 or u512 in struct\n  if (input.type === Uint.u256 || input.type === Uint.u512) {\n    validateUint(parameter, input);\n    return;\n  }\n\n  if (input.type === 'core::starknet::eth_address::EthAddress') {\n    assert(\n      typeof parameter !== 'object',\n      `EthAddress type is waiting a BigNumberish. Got ${parameter}`\n    );\n    const param = BigInt(parameter.toString(10));\n    assert(\n      // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n      param >= 0n && param <= 2n ** 160n - 1n,\n      `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`\n    );\n    return;\n  }\n\n  assert(\n    typeof parameter === 'object' && !Array.isArray(parameter),\n    `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`\n  );\n\n  // shallow struct validation, only first depth level\n  structs[input.type].members.forEach(({ name }) => {\n    assert(\n      Object.keys(parameter).includes(name),\n      `Validate: arg ${input.name} should have a property ${name}`\n    );\n  });\n};\n\nconst validateEnum = (parameter: any, input: AbiEntry) => {\n  assert(\n    typeof parameter === 'object' && !Array.isArray(parameter),\n    `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`\n  );\n  const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n  const keys = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];\n  if (isTypeOption(input.type) && keys.includes('isSome') && keys.includes('isNone')) {\n    return; // Option Enum\n  }\n  if (isTypeResult(input.type) && keys.includes('isOk') && keys.includes('isErr')) {\n    return; // Result Enum\n  }\n  if (keys.includes('variant') && keys.includes('activeVariant')) {\n    return; // Custom Enum\n  }\n  throw new Error(\n    `Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`\n  );\n};\n\nconst validateTuple = (parameter: any, input: AbiEntry) => {\n  assert(\n    typeof parameter === 'object' && !Array.isArray(parameter),\n    `Validate: arg ${input.name} should be a tuple (defined as object)`\n  );\n  // todo: skip tuple structural validation for now\n};\n\nconst validateArray = (parameter: any, input: AbiEntry, structs: AbiStructs, enums: AbiEnums) => {\n  const baseType = getArrayType(input.type);\n  // Long text (special case when parameter is not an array but long text)\n  if (isTypeFelt(baseType) && isLongText(parameter)) {\n    return;\n  }\n\n  assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);\n\n  switch (true) {\n    case isTypeFelt(baseType):\n      parameter.forEach((param: BigNumberish) => validateFelt(param, input));\n      break;\n    case isTypeTuple(baseType):\n      parameter.forEach((it: any) => validateTuple(it, { name: input.name, type: baseType }));\n      break;\n\n    case isTypeArray(baseType):\n      parameter.forEach((param: BigNumberish) =>\n        validateArray(param, { name: '', type: baseType }, structs, enums)\n      );\n      break;\n    case isTypeStruct(baseType, structs):\n      parameter.forEach((it: any) =>\n        validateStruct(it, { name: input.name, type: baseType }, structs)\n      );\n      break;\n    case isTypeEnum(baseType, enums):\n      parameter.forEach((it: any) => validateEnum(it, { name: input.name, type: baseType }));\n      break;\n    case isTypeUint(baseType) || isTypeLiteral(baseType):\n      parameter.forEach((param: BigNumberish) => validateUint(param, { name: '', type: baseType }));\n      break;\n    case isTypeBool(baseType):\n      parameter.forEach((param: BigNumberish) => validateBool(param, input));\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n      );\n  }\n};\n\nconst validateNonZero = (parameter: any, input: AbiEntry) => {\n  // Telegram : https://t.me/sncorestars/11902/45433\n  // Author : Ori Ziv (08/apr/2024)\n  // \"NonZero is only supported for purely numeric types (u*, i* and felt252) and EcPoint.\"\n  //\n  // As EcPoint do not includes trait Serde, it can't be seen in an ABI.\n  // u512 is not compatible.\n  // i* are not currently handled by Starknet.js (and core::zeroable::NonZero::<i*> seems not to work in Cairo 2.6.3).\n  // so, are authorized here : u8, u16, u32, u64, u128, u256 and felt252.\n\n  const baseType = getArrayType(input.type);\n  assert(\n    (isTypeUint(baseType) && baseType !== CairoUint512.abiSelector) || isTypeFelt(baseType),\n    `Validate: ${input.name} type is not authorized for NonZero type.`\n  );\n  switch (true) {\n    case isTypeFelt(baseType):\n      validateFelt(parameter, input);\n      assert(\n        BigInt(parameter.toString(10)) > 0,\n        'Validate: value 0 is not authorized in NonZero felt252 type.'\n      );\n      break;\n    case isTypeUint(baseType):\n      validateUint(parameter, { name: '', type: baseType });\n      switch (input.type) {\n        case Uint.u256:\n          assert(\n            new CairoUint256(parameter).toBigInt() > 0,\n            'Validate: value 0 is not authorized in NonZero uint256 type.'\n          );\n          break;\n        default:\n          assert(\n            toBigInt(parameter) > 0,\n            'Validate: value 0 is not authorized in NonZero uint type.'\n          );\n      }\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n      );\n  }\n};\n\nexport default function validateFields(\n  abiMethod: FunctionAbi,\n  args: Array<any>,\n  structs: AbiStructs,\n  enums: AbiEnums\n) {\n  abiMethod.inputs.reduce((acc, input) => {\n    const parameter = args[acc];\n\n    switch (true) {\n      case isLen(input.name):\n        return acc;\n      case isTypeFelt(input.type):\n        validateFelt(parameter, input);\n        break;\n      case isTypeBytes31(input.type):\n        validateBytes31(parameter, input);\n        break;\n      case isTypeUint(input.type) || isTypeLiteral(input.type):\n        validateUint(parameter, input);\n        break;\n      case isTypeBool(input.type):\n        validateBool(parameter, input);\n        break;\n      case isTypeByteArray(input.type):\n        validateByteArray(parameter, input);\n        break;\n      case isTypeArray(input.type):\n        validateArray(parameter, input, structs, enums);\n        break;\n      case isTypeStruct(input.type, structs):\n        validateStruct(parameter, input, structs);\n        break;\n      case isTypeEnum(input.type, enums):\n        validateEnum(parameter, input);\n        break;\n      case isTypeTuple(input.type):\n        validateTuple(parameter, input);\n        break;\n      case isTypeNonZero(input.type):\n        validateNonZero(parameter, input);\n        break;\n      default:\n        throw new Error(\n          `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n        );\n    }\n\n    return acc + 1;\n  }, 0);\n}\n","/* eslint-disable no-plusplus */\nimport {\n  Abi,\n  AbiEnums,\n  AbiStructs,\n  AllowArray,\n  Args,\n  ArgsOrCalldata,\n  Calldata,\n  FunctionAbi,\n  HexCalldata,\n  RawArgs,\n  RawArgsArray,\n  Result,\n  ValidateType,\n} from '../../types';\nimport assert from '../assert';\nimport { isBigInt, toHex } from '../num';\nimport { getSelectorFromName } from '../hash/selector';\nimport { isLongText } from '../shortString';\nimport { byteArrayFromString } from './byteArray';\nimport { felt, isCairo1Type, isLen } from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport formatter from './formatter';\nimport { createAbiParser, isNoConstructorValid } from './parser';\nimport { AbiParserInterface } from './parser/interface';\nimport orderPropsByAbi from './propertyOrder';\nimport { parseCalldataField } from './requestParser';\nimport responseParser from './responseParser';\nimport validateFields from './validate';\n\nexport * as cairo from './cairo';\nexport * as byteArray from './byteArray';\nexport { parseCalldataField } from './requestParser';\n\nexport class CallData {\n  abi: Abi;\n\n  parser: AbiParserInterface;\n\n  protected readonly structs: AbiStructs;\n\n  protected readonly enums: AbiEnums;\n\n  constructor(abi: Abi) {\n    this.structs = CallData.getAbiStruct(abi);\n    this.enums = CallData.getAbiEnum(abi);\n    this.parser = createAbiParser(abi);\n    this.abi = this.parser.getLegacyFormat();\n  }\n\n  /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */\n  public validate(type: ValidateType, method: string, args: ArgsOrCalldata = []) {\n    // ensure provided method of type exists\n    if (type !== ValidateType.DEPLOY) {\n      const invocableFunctionNames = this.abi\n        .filter((abi) => {\n          if (abi.type !== 'function') return false;\n          const isView = abi.stateMutability === 'view' || abi.state_mutability === 'view';\n          return type === ValidateType.INVOKE ? !isView : isView;\n        })\n        .map((abi) => abi.name);\n      assert(\n        invocableFunctionNames.includes(method),\n        `${type === ValidateType.INVOKE ? 'invocable' : 'viewable'} method not found in abi`\n      );\n    }\n\n    // get requested method from abi\n    const abiMethod = this.abi.find((abi) =>\n      type === ValidateType.DEPLOY\n        ? abi.name === method && abi.type === 'constructor'\n        : abi.name === method && abi.type === 'function'\n    ) as FunctionAbi;\n\n    if (isNoConstructorValid(method, args, abiMethod)) {\n      return;\n    }\n\n    // validate arguments length\n    const inputsLength = this.parser.methodInputsLength(abiMethod);\n    if (args.length !== inputsLength) {\n      throw Error(\n        `Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`\n      );\n    }\n\n    // validate parameters\n    validateFields(abiMethod, args, this.structs, this.enums);\n  }\n\n  /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param argsCalldata RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */\n  public compile(method: string, argsCalldata: RawArgs): Calldata {\n    const abiMethod = this.abi.find((abiFunction) => abiFunction.name === method) as FunctionAbi;\n\n    if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n      return [];\n    }\n\n    let args: RawArgsArray;\n    if (Array.isArray(argsCalldata)) {\n      args = argsCalldata;\n    } else {\n      // order the object\n      const orderedObject = orderPropsByAbi(\n        argsCalldata,\n        abiMethod.inputs,\n        this.structs,\n        this.enums\n      );\n      args = Object.values(orderedObject);\n      //   // validate array elements to abi\n      validateFields(abiMethod, args, this.structs, this.enums);\n    }\n\n    const argsIterator = args[Symbol.iterator]();\n\n    const callArray = abiMethod.inputs.reduce(\n      (acc, input) =>\n        isLen(input.name) && !isCairo1Type(input.type)\n          ? acc\n          : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)),\n      [] as Calldata\n    );\n\n    // add compiled property to array object\n    Object.defineProperty(callArray, '__compiled__', {\n      enumerable: false,\n      writable: false,\n      value: true,\n    });\n    return callArray;\n  }\n\n  /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */\n  static compile(rawArgs: RawArgs): Calldata {\n    const createTree = (obj: object) => {\n      const getEntries = (o: object, prefix = '.'): any => {\n        const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;\n        return Object.entries(oe).flatMap(([k, v]) => {\n          let value = v;\n          if (k === 'entrypoint') value = getSelectorFromName(value);\n          else if (isLongText(value)) value = byteArrayFromString(value);\n          const kk = Array.isArray(oe) && k === '0' ? '$$len' : k;\n          if (isBigInt(value)) return [[`${prefix}${kk}`, felt(value)]];\n          if (Object(value) === value) {\n            const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n            const keys = [...Object.getOwnPropertyNames(value), ...methodsKeys];\n            if (keys.includes('isSome') && keys.includes('isNone')) {\n              // Option\n              const myOption = value as CairoOption<any>;\n              const variantNb = myOption.isSome()\n                ? CairoOptionVariant.Some\n                : CairoOptionVariant.None;\n              if (myOption.isSome())\n                return getEntries({ 0: variantNb, 1: myOption.unwrap() }, `${prefix}${kk}.`);\n              return [[`${prefix}${kk}`, felt(variantNb)]];\n            }\n            if (keys.includes('isOk') && keys.includes('isErr')) {\n              // Result\n              const myResult = value as CairoResult<any, any>;\n              const variantNb = myResult.isOk() ? CairoResultVariant.Ok : CairoResultVariant.Err;\n              return getEntries({ 0: variantNb, 1: myResult.unwrap() }, `${prefix}${kk}.`);\n            }\n            if (keys.includes('variant') && keys.includes('activeVariant')) {\n              // CustomEnum\n              const myEnum = value as CairoCustomEnum;\n              const activeVariant: string = myEnum.activeVariant();\n              const listVariants = Object.keys(myEnum.variant);\n              const activeVariantNb = listVariants.findIndex(\n                (variant: any) => variant === activeVariant\n              );\n              if (\n                typeof myEnum.unwrap() === 'object' &&\n                Object.keys(myEnum.unwrap()).length === 0 // empty object : {}\n              ) {\n                return [[`${prefix}${kk}`, felt(activeVariantNb)]];\n              }\n              return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, `${prefix}${kk}.`);\n            }\n            // normal object\n            return getEntries(value, `${prefix}${kk}.`);\n          }\n          return [[`${prefix}${kk}`, felt(value)]];\n        });\n      };\n      const result = Object.fromEntries(getEntries(obj));\n      return result;\n    };\n\n    let callTreeArray;\n    if (!Array.isArray(rawArgs)) {\n      // flatten structs, tuples, add array length. Process leafs as Felt\n      const callTree = createTree(rawArgs);\n      // convert to array\n      callTreeArray = Object.values(callTree);\n    } else {\n      // already compiled data but modified or raw args provided as array, recompile it\n      // recreate tree\n      const callObj = { ...rawArgs };\n      const callTree = createTree(callObj);\n      callTreeArray = Object.values(callTree);\n    }\n\n    // add compiled property to array object\n    Object.defineProperty(callTreeArray, '__compiled__', {\n      enumerable: false,\n      writable: false,\n      value: true,\n    });\n    return callTreeArray;\n  }\n\n  /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */\n  public parse(method: string, response: string[]): Result {\n    const { outputs } = this.abi.find((abi) => abi.name === method) as FunctionAbi;\n    const responseIterator = response.flat()[Symbol.iterator]();\n\n    const parsed = outputs.flat().reduce((acc, output, idx) => {\n      const propName = output.name ?? idx;\n      acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n      if (acc[propName] && acc[`${propName}_len`]) {\n        delete acc[`${propName}_len`];\n      }\n      return acc;\n    }, {} as Args);\n\n    // Cairo1 avoid object.0 structure\n    return Object.keys(parsed).length === 1 && 0 in parsed ? (parsed[0] as Result) : parsed;\n  }\n\n  /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */\n  public format(method: string, response: string[], format: object): Result {\n    const parsed = this.parse(method, response);\n    return formatter(parsed as Record<string, any>, format);\n  }\n\n  /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */\n  static getAbiStruct(abi: Abi): AbiStructs {\n    return abi\n      .filter((abiEntry) => abiEntry.type === 'struct')\n      .reduce(\n        (acc, abiEntry) => ({\n          ...acc,\n          [abiEntry.name]: abiEntry,\n        }),\n        {}\n      );\n  }\n\n  /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */\n  static getAbiEnum(abi: Abi): AbiEnums {\n    const fullEnumList = abi\n      .filter((abiEntry) => abiEntry.type === 'enum')\n      .reduce(\n        (acc, abiEntry) => ({\n          ...acc,\n          [abiEntry.name]: abiEntry,\n        }),\n        {}\n      );\n    delete fullEnumList['core::bool'];\n    return fullEnumList;\n  }\n\n  /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */\n  static toCalldata(rawCalldata: RawArgs = []): Calldata {\n    return CallData.compile(rawCalldata);\n  }\n\n  /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */\n  static toHex(raw: RawArgs = []): HexCalldata {\n    const calldata = CallData.compile(raw);\n    return calldata.map((it) => toHex(it));\n  }\n\n  /**\n   * Parse the elements of a contract response and structure them into one or several Result.\n   * In Cairo 0, arrays are not supported.\n   * @param typeCairo string or string[] - Cairo type name, ex : \"hello::hello::UserData\"\n   * @param response string[] - serialized data corresponding to typeCairo.\n   * @return Result or Result[] - parsed response corresponding to typeData.\n   * @example\n   * const res2=helloCallData.decodeParameters(\"hello::hello::UserData\",[\"0x123456\",\"0x1\"]);\n   * result = { address: 1193046n, is_claimed: true }\n   */\n  public decodeParameters(typeCairo: AllowArray<string>, response: string[]): AllowArray<Result> {\n    const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [typeCairo];\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const decodedArray = typeCairoArray.map(\n      (typeParam) =>\n        responseParser(\n          responseIterator,\n          { name: '', type: typeParam },\n          this.structs,\n          this.enums\n        ) as Result\n    );\n    return decodedArray.length === 1 ? decodedArray[0] : decodedArray;\n  }\n}\n","/**\n * Hashes Exports\n */\nexport * as poseidon from '@noble/curves/abstract/poseidon';\nexport * from './selector'; // Preserve legacy export structure\n\nexport * from './transactionHash';\nexport * from './classHash';\n","/**\n * Calculate Hashes for v0 - v2 transactions\n */\n\n/* eslint-disable no-param-reassign */\n/* eslint-disable import/extensions */\nimport { StarknetChainId, TransactionHashPrefix } from '../../../constants';\nimport { BigNumberish, RawCalldata } from '../../../types';\nimport { starkCurve } from '../../ec';\nimport { toBigInt } from '../../num';\n\n/**\n * Compute pedersen hash from data\n * @returns format: hex-string - pedersen hash\n */\nexport function computeHashOnElements(data: BigNumberish[]): string {\n  return [...data, data.length]\n    .reduce((x: BigNumberish, y: BigNumberish) => starkCurve.pedersen(toBigInt(x), toBigInt(y)), 0)\n    .toString();\n}\n\n/**\n * Calculate transaction pedersen hash for common properties\n *\n * Following implementation is based on this python [implementation #](https://github.com/starkware-libs/cairo-lang/blob/b614d1867c64f3fb2cf4a4879348cfcf87c3a5a7/src/starkware/starknet/core/os/transaction_hash/transaction_hash.py)\n * @returns format: hex-string\n */\nexport function calculateTransactionHashCommon(\n  txHashPrefix: TransactionHashPrefix,\n  version: BigNumberish,\n  contractAddress: BigNumberish,\n  entryPointSelector: BigNumberish,\n  calldata: RawCalldata,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  additionalData: BigNumberish[] = []\n): string {\n  const calldataHash = computeHashOnElements(calldata);\n  const dataToHash = [\n    txHashPrefix,\n    version,\n    contractAddress,\n    entryPointSelector,\n    calldataHash,\n    maxFee,\n    chainId,\n    ...additionalData,\n  ];\n  return computeHashOnElements(dataToHash);\n}\n\n/**\n * Calculate declare transaction hash\n * @param classHash hex-string\n * @param compiledClassHash hex-string\n * @returns format: hex-string\n */\nexport function calculateDeclareTransactionHash(\n  classHash: string,\n  senderAddress: BigNumberish,\n  version: BigNumberish,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  compiledClassHash?: string\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DECLARE,\n    version,\n    senderAddress,\n    0,\n    [classHash],\n    maxFee,\n    chainId,\n    [nonce, ...(compiledClassHash ? [compiledClassHash] : [])]\n  );\n}\n\n/**\n * Calculate deploy_account transaction hash\n * @returns format: hex-string\n */\nexport function calculateDeployAccountTransactionHash(\n  contractAddress: BigNumberish,\n  classHash: BigNumberish,\n  constructorCalldata: RawCalldata,\n  salt: BigNumberish,\n  version: BigNumberish,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish\n) {\n  const calldata = [classHash, salt, ...constructorCalldata];\n\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DEPLOY_ACCOUNT,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\n\n/**\n * Calculate invoke transaction hash\n * @returns format: hex-string\n */\nexport function calculateTransactionHash(\n  contractAddress: BigNumberish,\n  version: BigNumberish,\n  calldata: RawCalldata,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.INVOKE,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\n","// TODO rename\nexport * as starkCurve from '@scure/starknet';\nexport * as weierstrass from '@noble/curves/abstract/weierstrass';\n","/**\n * Calculate Hashes for v3 transactions\n */\n\nimport { poseidonHashMany } from '@scure/starknet';\n\nimport { StarknetChainId, TransactionHashPrefix } from '../../../constants';\nimport { BigNumberish, Calldata } from '../../../types';\nimport { EDAMode, ResourceBounds } from '../../../types/api';\nimport { toHex } from '../../num';\nimport { encodeShortString } from '../../shortString';\n\nconst AToBI = (array: BigNumberish[]) => array.map((it: BigNumberish) => BigInt(it));\n\n/* eslint-disable no-bitwise */\nconst DATA_AVAILABILITY_MODE_BITS = 32n;\nconst MAX_AMOUNT_BITS = 64n;\nconst MAX_PRICE_PER_UNIT_BITS = 128n;\nconst RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;\nconst L1_GAS_NAME = BigInt(encodeShortString('L1_GAS'));\nconst L2_GAS_NAME = BigInt(encodeShortString('L2_GAS'));\n\nexport function hashDAMode(nonceDAMode: BigNumberish, feeDAMode: BigNumberish) {\n  return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);\n}\n\nexport function hashFeeField(tip: BigNumberish, bounds: ResourceBounds) {\n  const L1Bound =\n    (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) +\n    (BigInt(bounds.l1_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) +\n    BigInt(bounds.l1_gas.max_price_per_unit);\n\n  const L2Bound =\n    (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) +\n    (BigInt(bounds.l2_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) +\n    BigInt(bounds.l2_gas.max_price_per_unit);\n\n  return poseidonHashMany([BigInt(tip), L1Bound, L2Bound]);\n}\n\nexport function calculateTransactionHashCommon(\n  txHashPrefix: TransactionHashPrefix,\n  version: BigNumberish,\n  senderAddress: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[],\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBounds,\n  additionalData: BigNumberish[] = []\n): string {\n  const feeFieldHash = hashFeeField(tip, resourceBounds);\n  const dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);\n  const dataToHash = AToBI([\n    txHashPrefix,\n    version,\n    senderAddress,\n    feeFieldHash,\n    poseidonHashMany(AToBI(paymasterData)),\n    chainId,\n    nonce,\n    dAModeHash,\n    ...AToBI(additionalData),\n  ]);\n  return toHex(poseidonHashMany(dataToHash));\n}\n\n/**\n * Calculate v3 deploy_account transaction hash\n * @returns format: hex-string\n */\nexport function calculateDeployAccountTransactionHash(\n  contractAddress: BigNumberish,\n  classHash: BigNumberish,\n  compiledConstructorCalldata: Calldata,\n  salt: BigNumberish,\n  version: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBounds,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[]\n) {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DEPLOY_ACCOUNT,\n    version,\n    contractAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [poseidonHashMany(AToBI(compiledConstructorCalldata)), classHash, salt]\n  );\n}\n\n/**\n * Calculate v3 declare transaction hash\n * @returns format: hex-string\n */\nexport function calculateDeclareTransactionHash(\n  classHash: string,\n  compiledClassHash: string,\n  senderAddress: BigNumberish,\n  version: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  accountDeploymentData: BigNumberish[],\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBounds,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[]\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DECLARE,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    AToBI(paymasterData),\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [poseidonHashMany(AToBI(accountDeploymentData)), classHash, compiledClassHash]\n  );\n}\n\n/**\n * Calculate v3 invoke transaction hash\n * @returns format: hex-string\n */\nexport function calculateInvokeTransactionHash(\n  senderAddress: BigNumberish,\n  version: BigNumberish,\n  compiledCalldata: Calldata,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  accountDeploymentData: BigNumberish[],\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBounds,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[]\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.INVOKE,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [poseidonHashMany(AToBI(accountDeploymentData)), poseidonHashMany(AToBI(compiledCalldata))]\n  );\n}\n","/**\n * Transaction Hash based on Transaction Version\n */\n\nimport { StarknetChainId } from '../../../constants';\nimport { BigNumberish, Calldata } from '../../../types';\nimport {\n  EDAMode,\n  ETransactionVersion,\n  ETransactionVersion2,\n  ETransactionVersion3,\n  ResourceBounds,\n} from '../../../types/api';\nimport {\n  calculateDeclareTransactionHash as v2calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash as v2calculateDeployAccountTransactionHash,\n  calculateTransactionHash as v2calculateInvokeTransactionHash,\n} from './v2';\nimport {\n  calculateDeclareTransactionHash as v3calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash as v3calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash as v3calculateInvokeTransactionHash,\n} from './v3';\n\n/*\n * INVOKE TX HASH\n */\n\ntype Version = typeof ETransactionVersion.V3 | typeof ETransactionVersion.F3;\n\nfunction isV3InvokeTx(args: CalcInvokeTxHashArgs): args is CalcV3InvokeTxHashArgs {\n  return [ETransactionVersion.V3, ETransactionVersion.F3].includes(args.version as Version);\n}\n\ntype CalcV2InvokeTxHashArgs = {\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion2}`;\n  compiledCalldata: Calldata;\n  maxFee: BigNumberish;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n};\n\ntype CalcV3InvokeTxHashArgs = {\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion3}`;\n  compiledCalldata: Calldata;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  accountDeploymentData: BigNumberish[];\n  nonceDataAvailabilityMode: EDAMode;\n  feeDataAvailabilityMode: EDAMode;\n  resourceBounds: ResourceBounds;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n};\n\ntype CalcInvokeTxHashArgs = CalcV2InvokeTxHashArgs | CalcV3InvokeTxHashArgs;\n\nexport function calculateInvokeTransactionHash(args: CalcInvokeTxHashArgs) {\n  if (isV3InvokeTx(args)) {\n    return v3calculateInvokeTransactionHash(\n      args.senderAddress,\n      args.version,\n      args.compiledCalldata,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return v2calculateInvokeTransactionHash(\n    args.senderAddress,\n    args.version,\n    args.compiledCalldata,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\n\n/*\n * DECLARE TX HASH\n */\nfunction isV3DeclareTx(args: CalcDeclareTxHashArgs): args is CalcV3DeclareTxHashArgs {\n  return [ETransactionVersion.V3, ETransactionVersion.F3].includes(args.version as Version);\n}\n\ntype CalcV2DeclareTxHashArgs = {\n  classHash: string;\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion2}`;\n  maxFee: BigNumberish;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  compiledClassHash?: string;\n};\n\ntype CalcV3DeclareTxHashArgs = {\n  classHash: string;\n  compiledClassHash: string;\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion3}`;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  accountDeploymentData: BigNumberish[];\n  nonceDataAvailabilityMode: EDAMode;\n  feeDataAvailabilityMode: EDAMode;\n  resourceBounds: ResourceBounds;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n};\n\ntype CalcDeclareTxHashArgs = CalcV2DeclareTxHashArgs | CalcV3DeclareTxHashArgs;\n\nexport function calculateDeclareTransactionHash(args: CalcDeclareTxHashArgs) {\n  if (isV3DeclareTx(args)) {\n    return v3calculateDeclareTransactionHash(\n      args.classHash,\n      args.compiledClassHash,\n      args.senderAddress,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n\n  return v2calculateDeclareTransactionHash(\n    args.classHash,\n    args.senderAddress,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce,\n    args.compiledClassHash\n  );\n}\n\n/*\n * DEPLOY ACCOUNT TX HASH\n */\n\nfunction isV3DeployAccountTx(\n  args: CalcDeployAccountTxHashArgs\n): args is CalcV3DeployAccountTxHashArgs {\n  return [ETransactionVersion.V3, ETransactionVersion.F3].includes(args.version as Version);\n}\n\ntype CalcV2DeployAccountTxHashArgs = {\n  contractAddress: BigNumberish;\n  classHash: BigNumberish;\n  constructorCalldata: Calldata;\n  salt: BigNumberish;\n  version: `${ETransactionVersion2}`;\n  maxFee: BigNumberish;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n};\n\ntype CalcV3DeployAccountTxHashArgs = {\n  contractAddress: BigNumberish;\n  classHash: BigNumberish;\n  compiledConstructorCalldata: Calldata;\n  salt: BigNumberish;\n  version: `${ETransactionVersion3}`;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  nonceDataAvailabilityMode: EDAMode;\n  feeDataAvailabilityMode: EDAMode;\n  resourceBounds: ResourceBounds;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n};\n\ntype CalcDeployAccountTxHashArgs = CalcV2DeployAccountTxHashArgs | CalcV3DeployAccountTxHashArgs;\n\nexport function calculateDeployAccountTransactionHash(args: CalcDeployAccountTxHashArgs) {\n  if (isV3DeployAccountTx(args)) {\n    return v3calculateDeployAccountTransactionHash(\n      args.contractAddress,\n      args.classHash,\n      args.compiledConstructorCalldata,\n      args.salt,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n\n  return v2calculateDeployAccountTransactionHash(\n    args.contractAddress,\n    args.classHash,\n    args.constructorCalldata,\n    args.salt,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\n","/**\n * Class Hash\n */\n\nimport { poseidonHashMany } from '@scure/starknet';\n\nimport { ADDR_BOUND, API_VERSION } from '../../constants';\nimport {\n  BigNumberish,\n  Builtins,\n  CompiledContract,\n  CompiledSierra,\n  CompiledSierraCasm,\n  ContractEntryPointFields,\n  LegacyCompiledContract,\n  RawArgs,\n  SierraContractEntryPointFields,\n} from '../../types';\nimport { CallData } from '../calldata';\nimport { felt } from '../calldata/cairo';\nimport { starkCurve } from '../ec';\nimport { addHexPrefix, utf8ToArray } from '../encode';\nimport { parse, stringify } from '../json';\nimport { toHex } from '../num';\nimport { encodeShortString, isString } from '../shortString';\n\nexport function computePedersenHash(a: BigNumberish, b: BigNumberish): string {\n  return starkCurve.pedersen(BigInt(a), BigInt(b));\n}\n\nexport function computePoseidonHash(a: BigNumberish, b: BigNumberish): string {\n  return toHex(starkCurve.poseidonHash(BigInt(a), BigInt(b)));\n}\n\n/**\n * Compute Pedersen hash from data\n *\n * @param {BigNumberish[]} data Array of data to compute Pedersen hash on\n * @returns {string} hex-string of Pedersen hash\n *\n * @example\n * ```typescript\n * const result = hash.computeHashOnElements(['0xabc', '0x123', '0xabc123'])\n * // result = 0x148141e8f7db29d005a0187669a56f0790d7e8c2c5b2d780e4d8b9e436a5521\n * ```\n */\nexport function computeHashOnElements(data: BigNumberish[]): string {\n  return [...data, data.length]\n    .reduce((x: BigNumberish, y: BigNumberish) => starkCurve.pedersen(BigInt(x), BigInt(y)), 0)\n    .toString();\n}\n\nexport const computePedersenHashOnElements = computeHashOnElements;\n\nexport function computePoseidonHashOnElements(data: BigNumberish[]) {\n  return toHex(poseidonHashMany(data.map((x) => BigInt(x))));\n}\n\n/**\n * Calculate contract address from class hash\n *\n * @param {BigNumberish} salt Salt to be used for hashing\n * @param {BigNumberish} classHash Class hash of contract to generate address for\n * @param {RawArgs} constructorCalldata Call data for contract constructor\n * @param {BigNumberish} deployerAddress Address of contract deployer\n * @returns {string} hex-string\n * @example\n * ```typescript\n * const result = hash.calculateContractAddressFromHash(1234, 0x1cf4fe5d37868d25524cdacb89518d88bf217a9240a1e6fde71cc22c429e0e3, [1234, true, false], 0x052fb1a9ab0db3c4f81d70fea6a2f6e55f57c709a46089b25eeec0e959db3695);\n * // result = 0x5fb03d3a88d8e474976932f927ff6a9e332e06ed36642ea3e8c7e38bf010f76\n * ```\n */\nexport function calculateContractAddressFromHash(\n  salt: BigNumberish,\n  classHash: BigNumberish,\n  constructorCalldata: RawArgs,\n  deployerAddress: BigNumberish\n): string {\n  const compiledCalldata = CallData.compile(constructorCalldata);\n  const constructorCalldataHash = computeHashOnElements(compiledCalldata);\n\n  const CONTRACT_ADDRESS_PREFIX = felt('0x535441524b4e45545f434f4e54524143545f41444452455353'); // Equivalent to 'STARKNET_CONTRACT_ADDRESS'\n\n  const hash = computeHashOnElements([\n    CONTRACT_ADDRESS_PREFIX,\n    deployerAddress,\n    salt,\n    classHash,\n    constructorCalldataHash,\n  ]);\n  return toHex(BigInt(hash) % ADDR_BOUND);\n}\n\nfunction nullSkipReplacer(key: string, value: any) {\n  if (key === 'attributes' || key === 'accessible_scopes') {\n    return Array.isArray(value) && value.length === 0 ? undefined : value;\n  }\n\n  if (key === 'debug_info') {\n    return null;\n  }\n\n  return value === null ? undefined : value;\n}\n\n/**\n * Format json-string without spaces to conform starknet json-string\n * @param {string} json json-string without spaces\n * @returns {string} json-string with additional spaces after `:` and `,`\n * @example\n * ```typescript\n * const result = hash.formatSpaces(\"{'onchain':true,'isStarknet':true}\");\n * // result = \"{'onchain': true, 'isStarknet': true}\"\n * ```\n */\nexport function formatSpaces(json: string): string {\n  let insideQuotes = false;\n  const newString = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for (const char of json) {\n    if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === '\\\\') === false) {\n      insideQuotes = !insideQuotes;\n    }\n    if (insideQuotes) {\n      newString.push(char);\n    } else {\n      // eslint-disable-next-line no-nested-ternary\n      newString.push(char === ':' ? ': ' : char === ',' ? ', ' : char);\n    }\n  }\n  return newString.join('');\n}\n\n/**\n * Compute hinted class hash for legacy compiled contract (Cairo 0)\n * @param {LegacyCompiledContract} compiledContract\n * @returns {string} hex-string\n * @example\n * ```typescript\n * const compiledCairo0 = json.parse(fs.readFileSync(\"./cairo0contract.json\").toString(\"ascii\"));\n * const result=hash.computeHintedClassHash(compiledCairo0);\n * // result = \"0x293eabb06955c0a1e55557014675aa4e7a1fd69896147382b29b2b6b166a2ac\"\n * ``` */\nexport function computeHintedClassHash(compiledContract: LegacyCompiledContract): string {\n  const { abi, program } = compiledContract;\n  const contractClass = { abi, program };\n  const serializedJson = formatSpaces(stringify(contractClass, nullSkipReplacer));\n  return addHexPrefix(starkCurve.keccak(utf8ToArray(serializedJson)).toString(16));\n}\n\n/**\n * Computes the class hash for legacy compiled contract (Cairo 0)\n * @param {LegacyCompiledContract | string} contract legacy compiled contract content\n * @returns {string} hex-string of class hash\n * @example\n * ```typescript\n * const compiledCairo0 = json.parse(fs.readFileSync(\"./cairo0contract.json\").toString(\"ascii\"));\n * const result=hash.computeLegacyContractClassHash(compiledCairo0);\n * // result = \"0x4a5cae61fa8312b0a3d0c44658b403d3e4197be80027fd5020ffcdf0c803331\"\n * ```\n */\nexport function computeLegacyContractClassHash(contract: LegacyCompiledContract | string) {\n  const compiledContract = isString(contract)\n    ? (parse(contract) as LegacyCompiledContract)\n    : contract;\n\n  const apiVersion = toHex(API_VERSION);\n\n  const externalEntryPointsHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset])\n  );\n\n  const l1HandlerEntryPointsHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset])\n  );\n\n  const constructorEntryPointHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset])\n  );\n\n  const builtinsHash = computeHashOnElements(\n    compiledContract.program.builtins.map((s) => encodeShortString(s))\n  );\n\n  const hintedClassHash = computeHintedClassHash(compiledContract);\n\n  const dataHash = computeHashOnElements(compiledContract.program.data);\n\n  return computeHashOnElements([\n    apiVersion,\n    externalEntryPointsHash,\n    l1HandlerEntryPointsHash,\n    constructorEntryPointHash,\n    builtinsHash,\n    hintedClassHash,\n    dataHash,\n  ]);\n}\n\n// Cairo 1 Contract Hashes\n\nfunction hashBuiltins(builtins: Builtins) {\n  return poseidonHashMany(\n    builtins.flatMap((it: any) => {\n      return BigInt(encodeShortString(it));\n    })\n  );\n}\n\nfunction hashEntryPoint(data: ContractEntryPointFields[]) {\n  const base = data.flatMap((it: any) => {\n    return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];\n  });\n  return poseidonHashMany(base);\n}\n\n/**\n * Compute hash of the bytecode for Sierra v1.5.0 onwards (Cairo 2.6.0)\n * Each segment is Poseidon hashed.\n * The global hash is : 1 + PoseidonHash(len0, h0, len1, h1, ...)\n * @param {CompiledSierraCasm} casm compiled Sierra CASM file content.\n * @returns {bigint} the bytecode hash as bigint.\n * @example\n * ```typescript\n * const compiledCasm = json.parse(fs.readFileSync(\"./contractC260.casm.json\").toString(\"ascii\"));\n * const result = hash.hashByteCodeSegments(compiledCasm);\n * // result = 80499149343908132326491548897246987792410240503053732367044713070598981699n\n * ```\n */\nexport function hashByteCodeSegments(casm: CompiledSierraCasm): bigint {\n  const byteCode: bigint[] = casm.bytecode.map((n) => BigInt(n));\n  const bytecodeSegmentLengths: number[] = casm.bytecode_segment_lengths ?? [];\n  let segmentStart = 0;\n  const hashLeaves = bytecodeSegmentLengths.flatMap((len) => {\n    const segment = byteCode.slice(segmentStart, (segmentStart += len));\n    return [BigInt(len), poseidonHashMany(segment)];\n  });\n  return 1n + poseidonHashMany(hashLeaves);\n}\n\n/**\n * Compute compiled class hash for contract (Cairo 1)\n * @param {CompiledSierraCasm} casm Cairo 1 compiled contract content\n * @returns {string} hex-string of class hash\n * @example \n * ```typescript\n * const compiledCasm = json.parse(fs.readFileSync(\"./cairo260.casm.json\").toString(\"ascii\"));\n * const result = hash.computeCompiledClassHash(compiledCasm);\n * // result = \"0x4087905743b4fa2b3affc1fc71333f1390c8c5d1e8ea47d6ba70786de3fc01a\"\n```\n */\nexport function computeCompiledClassHash(casm: CompiledSierraCasm): string {\n  const COMPILED_CLASS_VERSION = 'COMPILED_CLASS_V1';\n\n  // Hash compiled class version\n  const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n\n  // Hash external entry points.\n  const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n\n  // Hash L1 handler entry points.\n  const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n\n  // Hash constructor entry points.\n  const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n\n  // Hash bytecode.\n  const bytecode = casm.bytecode_segment_lengths\n    ? hashByteCodeSegments(casm)\n    : poseidonHashMany(casm.bytecode.map((it: string) => BigInt(it)));\n\n  return toHex(\n    poseidonHashMany([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      bytecode,\n    ])\n  );\n}\n\nfunction hashEntryPointSierra(data: SierraContractEntryPointFields[]) {\n  const base = data.flatMap((it: any) => {\n    return [BigInt(it.selector), BigInt(it.function_idx)];\n  });\n  return poseidonHashMany(base);\n}\n\nfunction hashAbi(sierra: CompiledSierra) {\n  const indentString = formatSpaces(stringify(sierra.abi, null));\n  return BigInt(addHexPrefix(starkCurve.keccak(utf8ToArray(indentString)).toString(16)));\n}\n\n/**\n * Compute sierra contract class hash (Cairo 1)\n * @param {CompiledSierra} sierra Cairo 1 Sierra contract content\n * @returns {string} hex-string of class hash\n * @example \n * ```typescript\n * const compiledSierra = json.parse(fs.readFileSync(\"./cairo260.sierra.json\").toString(\"ascii\"));\n * const result = hash.computeSierraContractClassHash(compiledSierra);\n * // result = \"0x67b6b4f02baded46f02feeed58c4f78e26c55364e59874d8abfd3532d85f1ba\"\n```\n */\nexport function computeSierraContractClassHash(sierra: CompiledSierra): string {\n  const CONTRACT_CLASS_VERSION = 'CONTRACT_CLASS_V0.1.0';\n\n  // Hash class version\n  const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n\n  // Hash external entry points.\n  const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n\n  // Hash L1 handler entry points.\n  const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n\n  // Hash constructor entry points.\n  const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n\n  // Hash abi_hash.\n  const abiHash = hashAbi(sierra);\n\n  // Hash Sierra program.\n  const sierraProgram = poseidonHashMany(sierra.sierra_program.map((it: string) => BigInt(it)));\n\n  return toHex(\n    poseidonHashMany([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      abiHash,\n      sierraProgram,\n    ])\n  );\n}\n\n/**\n * Compute ClassHash (sierra or legacy) based on provided contract\n * @param {CompiledContract | string} contract Cairo 1 contract content\n * @returns {string} hex-string of class hash\n * @example \n * ```typescript\n * const compiledSierra = json.parse(fs.readFileSync(\"./cairo260.sierra.json\").toString(\"ascii\"));\n * const result = hash.computeContractClassHash(compiledSierra);\n * // result = \"0x67b6b4f02baded46f02feeed58c4f78e26c55364e59874d8abfd3532d85f1ba\"\n```\n */\nexport function computeContractClassHash(contract: CompiledContract | string): string {\n  const compiledContract = isString(contract) ? parse(contract) : contract;\n\n  if ('sierra_program' in compiledContract) {\n    return computeSierraContractClassHash(compiledContract as CompiledSierra);\n  }\n\n  return computeLegacyContractClassHash(compiledContract as LegacyCompiledContract);\n}\n","import * as json from 'lossless-json';\n\n/**\n * Helper to convert string to number or bigint based on size\n */\nconst parseIntAsNumberOrBigInt = (str: string) => {\n  if (!json.isInteger(str)) return parseFloat(str);\n  const num = parseInt(str, 10);\n  return Number.isSafeInteger(num) ? num : BigInt(str);\n};\n\n/**\n * Convert JSON string to JSON object\n *\n * NOTE: the String() wrapping is used so the behavior conforms to JSON.parse()\n * which can accept simple data types but is not represented in the default typing\n *\n * @param str JSON string\n * @return {object} Parsed json object\n * @example\n * ```typescript\n * const str = '[123, 12.3, 11223344556677889900]';\n * const result = parse(str);\n * // result = [123, 12.3, 11223344556677890048n]\n * ```\n */\nexport const parse = (str: string): any =>\n  json.parse(String(str), undefined, parseIntAsNumberOrBigInt);\n\n/**\n * Convert JSON string to JSON object with all numbers as bigint\n * @param str JSON string\n * @return {object} Parsed json object\n * @example\n * ```typescript\n * const str = '[123, 12.3, 1234567890]';\n * const result = parseAlwaysAsBig(str);\n * // result = [123n, 12.3, 1234567890n]\n * ```\n */\nexport const parseAlwaysAsBig = (str: string): any =>\n  json.parse(String(str), undefined, json.parseNumberAndBigInt);\n\n/**\n * Convert JSON object to JSON string\n *\n * NOTE: the not-null assertion is used so the return type conforms to JSON.stringify()\n * which can also return undefined but is not represented in the default typing\n *\n * @param value JSON object\n * @param [replacer] Function that alters the behavior of the stringification process\n * @param [space] Used to insert white space into the output JSON string\n * @param [numberStringifiers] Function used to stringify numbers (returning undefined will delete the property from the object)\n * @return {string} JSON string\n * @example\n * ```typescript\n * const value = [123, 12.3, 1234567890];\n * const result = stringify(value);\n * // result = '[123,12.3,1234567890]'\n * ```\n */\nexport const stringify = (\n  value: unknown,\n  replacer?: any,\n  space?: string | number | undefined,\n  numberStringifiers?: json.NumberStringifier[] | undefined\n): string => json.stringify(value, replacer, space, numberStringifiers)!;\n\n/** @deprecated equivalent to 'stringify', alias will be removed */\nexport const stringifyAlwaysAsBig = stringify;\n","// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { SPEC } from 'starknet-types-07';\nimport { getStarkKey, utils } from '@scure/starknet';\nimport { gzip, ungzip } from 'pako';\n\nimport { ZERO, FeeMarginPercentage } from '../constants';\nimport {\n  ArraySignatureType,\n  BigNumberish,\n  CompressedProgram,\n  Program,\n  Signature,\n  UniversalDetails,\n} from '../types';\nimport { EDAMode, EDataAvailabilityMode, ETransactionVersion, ResourceBounds } from '../types/api';\nimport { FeeEstimate } from '../types/provider';\nimport { addHexPrefix, arrayBufferToString, atobUniversal, btoaUniversal } from './encode';\nimport { parse, stringify } from './json';\nimport {\n  addPercent,\n  bigNumberishArrayToDecimalStringArray,\n  bigNumberishArrayToHexadecimalStringArray,\n  isBigInt,\n  toHex,\n} from './num';\nimport { isString } from './shortString';\n\n/**\n * Compress compiled Cairo 0 program\n *\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/services/api/gateway/transaction.py#L54-L58)\n * @param {Program | string} jsonProgram Representing the compiled Cairo 0 program\n * @return {CompressedProgram} Compressed Cairo 0 program\n * @example\n * ```typescript\n * const contractCairo0 = json.parse(fs.readFileSync(\"./cairo0contract.json\").toString(\"ascii\"));\n * const result = stark.compressProgram(contractCairo0);\n * // result = \"H4sIAAAAAAAAA+1dC4/bOJL+K4aBu01me7r5EEUyixzQk/TuB...\"\n * ```\n */\nexport function compressProgram(jsonProgram: Program | string): CompressedProgram {\n  const stringified = isString(jsonProgram) ? jsonProgram : stringify(jsonProgram);\n  const compressedProgram = gzip(stringified);\n  return btoaUniversal(compressedProgram);\n}\n\n/**\n * Decompress compressed compiled Cairo 0 program\n * @param {CompressedProgram} base64 Compressed Cairo 0 program\n * @returns {Object | CompressedProgram} Parsed decompressed compiled Cairo 0 program\n * @example\n * ```typescript\n * const contractCairo0 = json.parse(fs.readFileSync(\"./cairo0contract.json\").toString(\"ascii\"));\n * const compressedCairo0 = stark.compressProgram(contractCairo0);\n * const result = stark.decompressProgram(compressedCairo0);\n * // result = {\n * //   abi: [\n * //     {\n * //       inputs: [Array],\n * //       name: 'increase_balance',\n * //       outputs: [],\n * //       type: 'function'\n * //     }\n * //   ],\n * //   entry_points_by_type: { CONSTRUCTOR: [], EXTERNAL: [ [Object], [Object] ], L1_HANDLER: [] },\n * //   program: {\n * //     attributes: [],\n * //     builtins: [ 'pedersen', 'range_check' ],\n * //     compiler_version: '0.10.2',\n * //     data: [\n * //       '0x480680017fff8000',\n * // ...\n * ```\n */\nexport function decompressProgram(base64: CompressedProgram) {\n  if (Array.isArray(base64)) return base64;\n  const decompressed = arrayBufferToString(ungzip(atobUniversal(base64)));\n  return parse(decompressed);\n}\n\n/**\n * Random Address based on random keyPair\n * @returns {string} an hex string of a random Starknet address\n * @example\n * ```typescript\n * const result = stark.randomAddress();\n * // result = \"0x51fc8126a13cd5ddb29a71ca399cb1e814f086f5af1b502d7151c14929554f\"\n * ```\n */\nexport function randomAddress(): string {\n  const randomKeyPair = utils.randomPrivateKey();\n  return getStarkKey(randomKeyPair);\n}\n\n/**\n * Lowercase and hex prefix string\n *\n * @deprecated Not used internally, naming is confusing based on functionality\n */\nexport function makeAddress(input: string): string {\n  return addHexPrefix(input).toLowerCase();\n}\n\n/**\n * Format Signature to standard type (hex array)\n * @param {Signature} [sig]\n * @returns {ArraySignatureType} Custom hex string array\n * @throws {Error} if sig not defined, or wrong format\n * @example\n * ```typescript\n * const signature = ec.starkCurve.sign(\"0x12de34\", \"0x3487123eac\");\n * const result = stark.formatSignature(signature);\n * // result = ['0xba8eecee2d69c417e8c6a20cf331c821f716b58ba9e47166c7476afdb38997',\n * //  '0x69ef7438c94104839a6e2aa2385482a77399d2f46e894ae4f50ab6d69239d1c']\n * ```\n */\nexport function formatSignature(sig?: Signature): ArraySignatureType {\n  if (!sig) throw Error('formatSignature: provided signature is undefined');\n  if (Array.isArray(sig)) {\n    return sig.map((it) => toHex(it));\n  }\n  try {\n    const { r, s } = sig;\n    return [toHex(r), toHex(s)];\n  } catch (e) {\n    throw new Error('Signature need to be weierstrass.SignatureType or an array for custom');\n  }\n}\n\n/**\n * Format Signature to decimal string array\n * @param {Signature} [sig]\n * @returns {ArraySignatureType} Custom hex string array\n * @throws {Error} if sig not defined, or wrong format\n * @example\n * ```typescript\n * const signature = ec.starkCurve.sign(\"0x12de34\", \"0x3487123eac\");\n * const result = stark.signatureToDecimalArray(signature);\n * // result = ['329619989660444495690615805546674399714973829707166906185976654753023887767',\n * //  '2994745480203297689255012826403147585778741462125743754529207781488706428188']\n * ```\n */\nexport function signatureToDecimalArray(sig?: Signature): ArraySignatureType {\n  return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\n\n/**\n * Format Signature to hex string array\n * @param {Signature} [sig]\n * @returns {ArraySignatureType} Custom hex string array\n * @throws {Error} if sig not defined, or wrong format\n * @example\n * ```typescript\n * const signature = ec.starkCurve.sign(\"0x12de34\", \"0x3487123eac\");\n * const result = stark.signatureToHexArray(signature);\n * // result = ['0xba8eecee2d69c417e8c6a20cf331c821f716b58ba9e47166c7476afdb38997',\n * //  '0x69ef7438c94104839a6e2aa2385482a77399d2f46e894ae4f50ab6d69239d1c']\n * ```\n */\nexport function signatureToHexArray(sig?: Signature): ArraySignatureType {\n  return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\n\n/**\n * Convert estimated fee to max fee including a margin\n * @param {BigNumberish} estimatedFee - The estimated fee\n * @param {number} [overhead = feeMarginPercentage.MAX_FEE] - The overhead added to the gas\n * @returns {bigint} The maximum fee with the margin\n * @example\n * ```typescript\n * const result = stark.estimatedFeeToMaxFee(\"8982300000000\", 50);\n * // result = \"13473450000000n\"\n * ```\n */\nexport function estimatedFeeToMaxFee(\n  estimatedFee: BigNumberish,\n  overhead: number = FeeMarginPercentage.MAX_FEE\n): bigint {\n  return addPercent(estimatedFee, overhead);\n}\n\n/**\n * Calculates the maximum resource bounds for fee estimation.\n *\n * @param {FeeEstimate | 0n} estimate The estimate for the fee. If a BigInt is provided, the returned bounds will be set to '0x0'.\n * @param {number} [amountOverhead = feeMarginPercentage.L1_BOUND_MAX_AMOUNT] - The percentage overhead added to the gas consumed or overall fee amount.\n * @param {number} [priceOverhead = feeMarginPercentage.L1_BOUND_MAX_PRICE_PER_UNIT] The percentage overhead added to the gas price per unit.\n * @returns {ResourceBounds} The maximum resource bounds for fee estimation.\n * @throws {Error} If the estimate object is undefined or does not have the required properties.\n * @example\n * ```typescript\n * const feeEstimated: FeeEstimate = {\n  gas_consumed: \"0x3456a\",\n  gas_price: \"0xa45567567567ae4\",\n  overall_fee: \"0x2198F463A77A899A5668\",\n  unit: \"WEI\"\n};\nconst result = stark.estimateFeeToBounds(feeEstimated, 70, 50);\n * // result = {\n * //   l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n * //   l1_gas: { max_amount: '0x58f9a', max_price_per_unit: '0xf6801b01b01b856' }\n * // }\n * ```\n */\nexport function estimateFeeToBounds(\n  estimate: FeeEstimate | 0n,\n  amountOverhead: number = FeeMarginPercentage.L1_BOUND_MAX_AMOUNT,\n  priceOverhead: number = FeeMarginPercentage.L1_BOUND_MAX_PRICE_PER_UNIT\n): ResourceBounds {\n  if (isBigInt(estimate)) {\n    return {\n      l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n      l1_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n    };\n  }\n\n  if (typeof estimate.gas_consumed === 'undefined' || typeof estimate.gas_price === 'undefined') {\n    throw Error('estimateFeeToBounds: estimate is undefined');\n  }\n\n  const maxUnits =\n    estimate.data_gas_consumed !== undefined && estimate.data_gas_price !== undefined // RPC v0.7\n      ? toHex(addPercent(BigInt(estimate.overall_fee) / BigInt(estimate.gas_price), amountOverhead))\n      : toHex(addPercent(estimate.gas_consumed, amountOverhead));\n  const maxUnitPrice = toHex(addPercent(estimate.gas_price, priceOverhead));\n  return {\n    l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n    l1_gas: { max_amount: maxUnits, max_price_per_unit: maxUnitPrice },\n  };\n}\n\n/**\n * Converts the data availability mode from EDataAvailabilityMode to EDAMode.\n *\n * @param {EDataAvailabilityMode} dam The data availability mode to be converted.\n * @return {EDAMode} The converted data availability mode.\n * @throws {Error} If the data availability mode is not a valid value.\n * @example\n * ```typescript\n * const result = stark.intDAM(RPC.EDataAvailabilityMode.L1);\n * // result = 0\n * ```\n */\nexport function intDAM(dam: EDataAvailabilityMode): EDAMode {\n  if (dam === EDataAvailabilityMode.L1) return EDAMode.L1;\n  if (dam === EDataAvailabilityMode.L2) return EDAMode.L2;\n  throw Error('EDAM conversion');\n}\n\n/**\n * Convert to ETransactionVersion or throw an error.\n * Return providedVersion is specified else return defaultVersion\n * @param {BigNumberish} defaultVersion default estimate transaction version\n * @param {BigNumberish} [providedVersion] estimate transaction version\n * @returns {ETransactionVersion} if providedVersion is not provided, returns the default estimate version, else return the provided version\n * @throws {Error} if estimate transaction version or default estimate transaction version is unknown\n * @example\n * ```typescript\n * const result = stark.toTransactionVersion(\"0x100000000000000000000000000000003\", stark.toFeeVersion(2));\n * // result = \"0x100000000000000000000000000000002\"\n * ```\n */\nexport function toTransactionVersion(\n  defaultVersion: BigNumberish,\n  providedVersion?: BigNumberish\n): ETransactionVersion {\n  const providedVersion0xs = providedVersion ? toHex(providedVersion) : undefined;\n  const defaultVersion0xs = toHex(defaultVersion);\n\n  if (providedVersion && !Object.values(ETransactionVersion).includes(providedVersion0xs as any)) {\n    throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);\n  }\n  if (!Object.values(ETransactionVersion).includes(defaultVersion0xs as any)) {\n    throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);\n  }\n\n  return (providedVersion ? providedVersion0xs : defaultVersion0xs) as ETransactionVersion;\n}\n\n/**\n * Convert Transaction version to Fee version or throw an error\n * @param {BigNumberish} [providedVersion] 0..3 number representing the transaction version\n * @returns {ETransactionVersion} the fee estimation version corresponding to the transaction version provided\n * @throws {Error} if the transaction version is unknown\n * @example\n * ```typescript\n * const result = stark.toFeeVersion(2);\n * // result = \"0x100000000000000000000000000000002\"\n * ```\n */\nexport function toFeeVersion(providedVersion?: BigNumberish) {\n  if (!providedVersion) return undefined;\n  const version = toHex(providedVersion);\n\n  if (version === ETransactionVersion.V0) return ETransactionVersion.F0;\n  if (version === ETransactionVersion.V1) return ETransactionVersion.F1;\n  if (version === ETransactionVersion.V2) return ETransactionVersion.F2;\n  if (version === ETransactionVersion.V3) return ETransactionVersion.F3;\n\n  throw Error(`toFeeVersion: ${version} is not supported`);\n}\n\n/**\n * Return provided or default v3 tx details\n * @param {UniversalDetails} details details of the transaction\n * @return {} an object including the V3 transaction details.\n * @example\n * ```typescript\n * const detail: UniversalDetails = { tip: 3456n };\n * const result = stark.v3Details(detail);\n * // result = {\n * //   tip: 3456n,\n * //   paymasterData: [],\n * //   accountDeploymentData: [],\n * //   nonceDataAvailabilityMode: 'L1',\n * //   feeDataAvailabilityMode: 'L1',\n * //   resourceBounds: {\n * //     l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n * //     l1_gas: { max_amount: '0x0', max_price_per_unit: '0x0' }\n * //   }\n * // }\n * ```\n */\nexport function v3Details(details: UniversalDetails) {\n  return {\n    tip: details.tip || 0,\n    paymasterData: details.paymasterData || [],\n    accountDeploymentData: details.accountDeploymentData || [],\n    nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || EDataAvailabilityMode.L1,\n    feeDataAvailabilityMode: details.feeDataAvailabilityMode || EDataAvailabilityMode.L1,\n    resourceBounds: details.resourceBounds ?? estimateFeeToBounds(ZERO),\n  };\n}\n\n/**\n * It will reduce V2 to V1, else (V3) stay the same\n * F2 -> F1\n * V2 -> V1\n * F3 -> F3\n * V3 -> V3\n * @param {ETransactionVersion} providedVersion\n * @returns {ETransactionVersion} if v2 then returns v1. if v3 then return v3\n * @example\n * ```typescript\n * const result = stark.reduceV2(constants.TRANSACTION_VERSION.V2);\n * // result = \"0x1\"\n * ```\n */\nexport function reduceV2(providedVersion: ETransactionVersion): ETransactionVersion {\n  if (providedVersion === ETransactionVersion.F2) return ETransactionVersion.F1;\n  if (providedVersion === ETransactionVersion.V2) return ETransactionVersion.V1;\n  return providedVersion;\n}\n","import { ContractClassResponse } from '../types';\nimport {\n  CairoContract,\n  CompiledSierra,\n  LegacyCompiledContract,\n  LegacyContractClass,\n  SierraContractClass,\n} from '../types/lib/contract/index';\nimport { CompleteDeclareContractPayload, DeclareContractPayload } from '../types/lib/index';\nimport { computeCompiledClassHash, computeContractClassHash } from './hash';\nimport { parse } from './json';\nimport { decompressProgram } from './stark';\n\nimport { isString } from './shortString';\n\n/**\n * Checks if a given contract is in Sierra (Safe Intermediate Representation) format.\n *\n * @param {CairoContract | string} contract - The contract to check. Can be either a CairoContract object or a string representation of the contract.\n * @return {boolean} - Returns true if the contract is a Sierra contract, otherwise false.\n * @example\n * ```typescript\n * const result = isSierra(contract);\n * // result = true | false\n * ```\n */\nexport function isSierra(\n  contract: CairoContract | string\n): contract is SierraContractClass | CompiledSierra {\n  const compiledContract = isString(contract) ? parse(contract) : contract;\n  return 'sierra_program' in compiledContract;\n}\n\n/**\n * Extracts contract hashes from `DeclareContractPayload`.\n *\n * @param {DeclareContractPayload} payload - The payload containing contract information.\n * @return {CompleteDeclareContractPayload} - The `CompleteDeclareContractPayload` with extracted contract hashes.\n * @throws {Error} - If extraction of compiledClassHash or classHash fails.\n * @example\n * ```typescript\n * const result = extractContractHashes(contract);\n * // result = {\n * //   contract: ...,\n * //   classHash: ...,\n * //   casm: ...,\n * //   compiledClassHash: ...,\n * // }\n * ```\n */\nexport function extractContractHashes(\n  payload: DeclareContractPayload\n): CompleteDeclareContractPayload {\n  const response = { ...payload } as CompleteDeclareContractPayload;\n\n  if (isSierra(payload.contract)) {\n    if (!payload.compiledClassHash && payload.casm) {\n      response.compiledClassHash = computeCompiledClassHash(payload.casm);\n    }\n    if (!response.compiledClassHash)\n      throw new Error(\n        'Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash'\n      );\n  }\n\n  response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n  if (!response.classHash)\n    throw new Error('Extract classHash failed, provide (CompiledContract).json file or classHash');\n\n  return response;\n}\n\n/**\n * Helper to redeclare response Cairo0 contract\n */\nexport function contractClassResponseToLegacyCompiledContract(ccr: ContractClassResponse) {\n  if (isSierra(ccr)) {\n    throw Error('ContractClassResponse need to be LegacyContractClass (cairo0 response class)');\n  }\n  const contract = ccr as LegacyContractClass;\n  return { ...contract, program: decompressProgram(contract.program) } as LegacyCompiledContract;\n}\n","import { secp256k1 } from '@noble/curves/secp256k1';\n\nimport { addHexPrefix, buf2hex, removeHexPrefix, sanitizeHex } from './encode';\nimport type { BigNumberish } from '../types';\nimport { assertInRange, toHex } from './num';\nimport { ZERO } from '../constants';\nimport assert from './assert';\n\n/**\n * Get random Ethereum private Key.\n * @returns an Hex string\n * @example\n * ```typescript\n * const myPK: string = randomAddress()\n * // result = \"0xf04e69ac152fba37c02929c2ae78c9a481461dda42dbc6c6e286be6eb2a8ab83\"\n * ```\n */\nexport function ethRandomPrivateKey(): string {\n  return sanitizeHex(buf2hex(secp256k1.utils.randomPrivateKey()));\n}\n\n/**\n * Get a string formatted for an Ethereum address, without uppercase characters.\n * @param {BigNumberish} address Address of an Ethereum account.\n * @returns an Hex string coded on 20 bytes\n * @example\n * ```typescript\n * const myEthAddress: string = validateAndParseEthAddress(\"0x8359E4B0152ed5A731162D3c7B0D8D56edB165\")\n * // result = \"0x008359e4b0152ed5a731162d3c7b0d8d56edb165\"\n * ```\n */\nexport function validateAndParseEthAddress(address: BigNumberish): string {\n  assertInRange(address, ZERO, 2n ** 160n - 1n, 'Ethereum Address ');\n  const result = addHexPrefix(removeHexPrefix(toHex(address)).padStart(40, '0'));\n  assert(Boolean(result.match(/^(0x)?[0-9a-f]{40}$/)), 'Invalid Ethereum Address Format');\n  return result;\n}\n","// the ts-ignore suppresses an esm to cjs import error that is resolved with entry point resolution\n// @ts-ignore\nimport makeFetchCookie from 'fetch-cookie';\nimport isomorphicFetch from 'isomorphic-fetch';\n\nexport default (typeof window !== 'undefined' && window.fetch) || // use buildin fetch in browser if available\n  (typeof global !== 'undefined' && makeFetchCookie(global.fetch)) || // use buildin fetch in node, react-native and service worker if available\n  isomorphicFetch; // ponyfill fetch in node and browsers that don't have it\n","import { NetworkName, RPC_NODES } from '../constants';\nimport {\n  BlockIdentifier,\n  BlockTag,\n  CompiledContract,\n  CompiledSierra,\n  ContractClass,\n  GetBlockResponse,\n  InvocationsDetailsWithNonce,\n  LegacyContractClass,\n  PendingBlock,\n  PendingStateUpdate,\n  SierraContractClass,\n  StateUpdateResponse,\n  V3TransactionDetails,\n} from '../types';\nimport { ETransactionVersion } from '../types/api';\nimport { isSierra } from './contract';\nimport { formatSpaces } from './hash';\nimport { parse, stringify } from './json';\nimport { isBigInt, isHex, isNumber, toHex } from './num';\nimport { isDecimalString, isString } from './shortString';\nimport { compressProgram } from './stark';\nimport type { GetTransactionReceiptResponse } from './transactionReceipt';\n\n/**\n * Helper - Async Sleep for 'delay' time\n *\n * @param {number} delay - Number of milliseconds to delay\n * @returns {Promise<unknown>}\n * @example\n * ```typescript\n * await provider.wait(1000) // 1000 milliseconds == 1 second\n * ```\n */\nexport function wait(delay: number): Promise<unknown> {\n  return new Promise((res) => {\n    setTimeout(res, delay);\n  });\n}\n\n/**\n * Create Sierra compressed Contract Class from a given Compiled Sierra\n *\n * CompiledSierra -> SierraContractClass\n * \n * @param {CompiledSierra} contract sierra code from the Cairo compiler\n * @returns {SierraContractClass} compressed Sierra\n * @example\n * ```typescript\n * const result = provider.createSierraContractClass({\n    \"sierra_program\": [\n        \"0x1\",\n        \"0x4\",\n        \"0x0\",\n        \"0x2\",\n        \"0x4\",\n        \"0x1\",\n        \"0x3b4\",\n        \"0x4c\",\n        \"0x65\",\n        \"0x52616e6765436865636b\",...})\n * // result = {sierra_program: 'H4sIAAAAAAAAA6x9WZbsrI7uVGqd53qgb8ZynwzYY7jDv5JAAmxHZuQ+96yq/L0jIzEINZ8axP/5j/q/+j//+z/wH9f/o/p/zPbh+Iot49+u9v8G3//rTdDhDDF4Z0MKPthQ+m+S2v6n1S//638VvdXW2PQ6RvxuDG+jiybCXKJ7Hef6ZRi9E+Q89WmKLilfqbrsL6PUCf8...}\n * ```\n */\nexport function createSierraContractClass(contract: CompiledSierra): SierraContractClass {\n  const result = { ...contract } as any;\n  delete result.sierra_program_debug_info;\n  result.abi = formatSpaces(stringify(contract.abi));\n  result.sierra_program = formatSpaces(stringify(contract.sierra_program));\n  result.sierra_program = compressProgram(result.sierra_program);\n  return result;\n}\n\n/**\n * Create a compressed contract from a given compiled Cairo 0 & 1 contract or a string.\n * @param {CompiledContract | string} contract - Compiled Cairo 0 or Cairo 1 contract, or string\n * @returns {ContractClass} Cairo 0 or Cairo 1 compressed contract\n * @example\n * ```typescript\n * const result = provider.parseContract({\n    \"sierra_program\": [\n        \"0x1\",\n        \"0x4\",\n        \"0x0\",\n        \"0x2\",\n        \"0x4\",\n        \"0x1\",\n        \"0x3b4\",\n        \"0x4c\",\n        \"0x65\",\n        \"0x52616e6765436865636b\",...})\n * // result = {sierra_program: 'H4sIAAAAAAAAA6x9WZbsrI7uVGqd53qgb8ZynwzYY7jDv5JAAmxHZuQ+96yq/L0jIzEINZ8axP/5j/q/+j//+z/wH9f/o/p/zPbh+Iot49+u9v8G3//rTdDhDDF4Z0MKPthQ+m+S2v6n1S//638VvdXW2PQ6RvxuDG+jiybCXKJ7Hef6ZRi9E+Q89WmKLilfqbrsL6PUCf8...}\n * ```\n */\nexport function parseContract(contract: CompiledContract | string): ContractClass {\n  const parsedContract = isString(contract) ? (parse(contract) as CompiledContract) : contract;\n\n  if (!isSierra(contract)) {\n    return {\n      ...parsedContract,\n      ...('program' in parsedContract && { program: compressProgram(parsedContract.program) }),\n    } as LegacyContractClass;\n  }\n\n  return createSierraContractClass(parsedContract as CompiledSierra);\n}\n\n/**\n * Return randomly select available public node\n * @param {NetworkName} networkName NetworkName\n * @param {boolean} mute mute public node warning\n * @returns {string} default node url\n * @example\n * ```typescript\n * const result= provider.getDefaultNodeUrl(constants.NetworkName.SN_MAIN,false);\n * // console : \"Using default public node url, please provide nodeUrl in provider options!\"\n * // result = \"https://starknet-mainnet.public.blastapi.io/rpc/v0_7\"\n * ```\n */\nexport const getDefaultNodeUrl = (networkName?: NetworkName, mute: boolean = false): string => {\n  if (!mute) {\n    // eslint-disable-next-line no-console\n    console.warn('Using default public node url, please provide nodeUrl in provider options!');\n  }\n  const nodes = RPC_NODES[networkName ?? NetworkName.SN_SEPOLIA];\n  const randIdx = Math.floor(Math.random() * nodes.length);\n  return nodes[randIdx];\n};\n\nexport const validBlockTags = Object.values(BlockTag);\n\n/**\n * This class is formatting the identifier of a block.\n *\n * hex string and BigInt are detected as block hashes. identifier return { block_hash: hash }\n *\n * decimal string and number are detected as block numbers. identifier return { block_number: number }\n *\n * text string are detected as block tag. identifier return tag\n *\n * null is detected as 'pending' block tag. identifier return 'pending'\n * @example\n * ```typescript\n * const result = new provider.Block(null).identifier;\n * // result = \"pending\"\n * ```\n */\nexport class Block {\n  /**\n   * @param {BlockIdentifier} hash if not null, contains the block hash\n   */\n  hash: BlockIdentifier = null;\n\n  /**\n   * @param {BlockIdentifier} number if not null, contains the block number\n   */\n  number: BlockIdentifier = null;\n\n  /**\n   * @param {BlockIdentifier} tag if not null, contains \"pending\" or \"latest\"\n   */\n  tag: BlockIdentifier = null;\n\n  private setIdentifier(__identifier: BlockIdentifier): void {\n    if (isString(__identifier)) {\n      if (isDecimalString(__identifier)) {\n        this.number = parseInt(__identifier, 10);\n      } else if (isHex(__identifier)) {\n        this.hash = __identifier;\n      } else if (validBlockTags.includes(__identifier as BlockTag)) {\n        this.tag = __identifier;\n      } else {\n        throw TypeError(`Block identifier unmanaged: ${__identifier}`);\n      }\n    } else if (isBigInt(__identifier)) {\n      this.hash = toHex(__identifier);\n    } else if (isNumber(__identifier)) {\n      this.number = __identifier;\n    } else {\n      this.tag = BlockTag.PENDING;\n    }\n\n    if (isNumber(this.number) && this.number < 0) {\n      throw TypeError(`Block number (${this.number}) can't be negative`);\n    }\n  }\n\n  /**\n   * Create a Block instance\n   * @param {BlockIdentifier} _identifier  hex string and BigInt are detected as block hashes.\n   * decimal string and number are detected as block numbers.\n   * text string are detected as block tag.\n   * null is considered as a 'pending' block tag.\n   */\n  constructor(_identifier: BlockIdentifier) {\n    this.setIdentifier(_identifier);\n  }\n\n  // TODO: fix any\n  /**\n   * @returns {any} the identifier as a string\n   * @example\n   * ```typescript\n   * const result = new provider.Block(123456n).queryIdentifier;\n   * // result = \"blockHash=0x1e240\"\n   * ```\n   */\n  get queryIdentifier(): any {\n    if (this.number !== null) {\n      return `blockNumber=${this.number}`;\n    }\n\n    if (this.hash !== null) {\n      return `blockHash=${this.hash}`;\n    }\n\n    return `blockNumber=${this.tag}`;\n  }\n\n  // TODO: fix any\n  /**\n   * @returns {any} the identifier as an object\n   * @example\n   * ```typescript\n   * const result = new provider.Block(56789).identifier;\n   * // result = { block_number: 56789 }\n   * ```\n   */\n  get identifier(): any {\n    if (this.number !== null) {\n      return { block_number: this.number };\n    }\n\n    if (this.hash !== null) {\n      return { block_hash: this.hash };\n    }\n\n    return this.tag;\n  }\n\n  /**\n   * change the identifier of an existing Block instance\n   * @example\n   * ```typescript\n   * const myBlock = new provider.Block(\"latest\");\n   * myBlock.identifier =\"0x3456789abc\";\n   * const result = myBlock.identifier;\n   * // result = { block_hash: '0x3456789abc' }\n   * ```\n   */\n  set identifier(_identifier: BlockIdentifier) {\n    this.setIdentifier(_identifier);\n  }\n\n  valueOf = () => this.number;\n\n  toString = () => this.hash;\n}\n\n/**\n * Check if the given transaction details is a V3 transaction.\n *\n * @param {InvocationsDetailsWithNonce} details The transaction details to be checked.\n * @return {boolean} Returns true if the transaction is a V3 transaction, otherwise false.\n * @example\n * ```typescript\n * const invocation: InvocationsDetailsWithNonce = {\n *   nonce: 1,\n *   version: 3,\n *   maxFee: 10 ** 15,\n *   feeDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n *   tip: 10 ** 13,\n *   paymasterData: [],\n *   resourceBounds: {\n *       l1_gas: { max_amount: num.toHex(10 ** 14), max_price_per_unit: num.toHex(50) },\n *       l2_gas: { max_amount: num.toHex(0), max_price_per_unit: num.toHex(0) }}};\n * const result = provider.isV3Tx(invocation);\n * // result = true\n * ```\n */\nexport function isV3Tx(details: InvocationsDetailsWithNonce): details is V3TransactionDetails {\n  const version = details.version ? toHex(details.version) : ETransactionVersion.V3;\n  return version === ETransactionVersion.V3 || version === ETransactionVersion.F3;\n}\n\n/**\n * Determines if the given response matches the specified version.\n *\n * @param {('0.5' | '0.6' | '0.7')} version The version to compare against the response.\n * @param {string} response The response to check against the version.\n * @returns {boolean} True if the response matches the version, false otherwise.\n * @example\n * ``` typescript\n * const result = provider.isVersion(\"0.7\",\"0_7\");\n * // result = false\n * ```\n */\nexport function isVersion(version: '0.5' | '0.6' | '0.7', response: string): boolean {\n  const [majorS, minorS] = version.split('.');\n  const [majorR, minorR] = response.split('.');\n\n  return majorS === majorR && minorS === minorR;\n}\n\n/**\n * Guard Pending Block\n * @param {GetBlockResponse} response answer of myProvider.getBlock()\n * @return {boolean} true if block is the pending block\n * @example\n * ```typescript\n * const block = await myProvider.getBlock(\"pending\");\n * const result = provider.isPendingBlock(block);\n * // result = true\n * ```\n */\nexport function isPendingBlock(response: GetBlockResponse): response is PendingBlock {\n  return response.status === 'PENDING';\n}\n\n/**\n * Guard Pending Transaction\n * @param {GetTransactionReceiptResponse} response transaction Receipt\n * @return {boolean} true if the transaction is part of the pending block\n * @example\n * ```typescript\n * const block = await myProvider.getBlockWithTxs(\"pending\");\n * const txR = await myProvider.getTransactionReceipt(block.transactions[0].transaction_hash);\n * const result = provider.isPendingTransaction(txR);\n * // result = true\n * ```\n */\nexport function isPendingTransaction(response: GetTransactionReceiptResponse): boolean {\n  return !('block_hash' in response);\n}\n\n/**\n * Guard Pending State Update\n * @param {StateUpdateResponse} response State of a block\n * @return {boolean} true if the block is pending\n * @example\n * ```typescript\n * const state: StateUpdateResponse = await myProvider.getStateUpdate(\"pending\");\n * const result = provider.isPendingStateUpdate(state);\n * // result = true\n * ```\n */\nexport function isPendingStateUpdate(\n  response: StateUpdateResponse\n): response is PendingStateUpdate {\n  return !('block_hash' in response);\n}\n","import { UDC } from '../constants';\nimport {\n  BigNumberish,\n  CairoVersion,\n  Call,\n  CallStruct,\n  Calldata,\n  ParsedStruct,\n  RawArgs,\n  UniversalDeployerContractPayload,\n} from '../types';\nimport { ETransactionVersion } from '../types/api';\nimport { CallData } from './calldata';\nimport { starkCurve } from './ec';\nimport { calculateContractAddressFromHash, getSelectorFromName } from './hash';\nimport { toBigInt, toCairoBool } from './num';\nimport { randomAddress } from './stark';\n\n/**\n * Transforms a list of Calls, each with their own calldata, into\n * two arrays: one with the entry points, and one with the concatenated calldata\n * @param {Call[]} calls the list of calls to transform.\n * @returns {callArray: ParsedStruct[], calldata: BigNumberish[]} An object containing two arrays: callArray and calldata.\n * @example\n * ```typescript\n * const calls: Call[] = [\n * \t{\n * \t\tcontractAddress: \"0x1234567890123456789012345678901234567890\",\n * \t\tentrypoint: \"functionName\",\n * \t\tcalldata: [1,2,3]\n * \t},\n * \t{\n * \t\tcontractAddress: \"0x0987654321098765432109876543210987654321\",\n * \t\tentrypoint: \"anotherFunction\",\n * \t\tcalldata: [4,5,6]\n * \t}\n * ];\n * const result = transaction.transformCallsToMulticallArrays(calls);\n * // result = {\n * // callArray: [\n * // { to: \"0x1234567890123456789012345678901234567890\", selector: \"1234567890\",\n * // data_offset: \"0\", data_len: \"3\" },\n * // { to: \"0x0987654321098765432109876543210987654321\", selector: \"1234567890\",\n * // data_offset: \"0987654321\", data_offset: \"3\", data_len: \"3\"}\n * // ], calldata: [1, 2, 3, 4, 5, 6]\n * // }\n * ```\n */\nexport const transformCallsToMulticallArrays = (calls: Call[]) => {\n  const callArray: ParsedStruct[] = [];\n  const calldata: BigNumberish[] = [];\n  calls.forEach((call) => {\n    const data = CallData.compile(call.calldata || []);\n    callArray.push({\n      to: toBigInt(call.contractAddress).toString(10),\n      selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n      data_offset: calldata.length.toString(),\n      data_len: data.length.toString(),\n    });\n    calldata.push(...data);\n  });\n  return {\n    callArray,\n    calldata: CallData.compile({ calldata }),\n  };\n};\n\n/**\n * Transforms a list of calls into the Cairo 0 `__execute__` calldata.\n * @param {Call[]} calls the list of calls to transform\n * @returns {Calldata} the Cairo 0 `__execute__` calldata\n * @example\n * ```typescript\n * const calls: Call[] = [\n * \t{\n * \t\tcontractAddress: \"0x1234567890123456789012345678901234567890\",\n * \t\tentrypoint: \"functionName\",\n * \t\tcalldata: [1, 2, 3]\n * \t},\n * \t{\n * \t\tcontractAddress: \"0x0987654321098765432109876543210987654321\",\n * \t\tentrypoint: \"anotherFunction\",\n * \t\tcalldata: [4, 5, 6]\n * \t}\n * ];\n * const result = transaction.fromCallsToExecuteCalldata(calls);\n * // result = ['2', '103929005307130220006098923584552504982110632080',\n * //   '784552248838722632831848474045274978537388011177294206940059575485454596699', '0',\n * //   '3', '54400338722927882010739357306608455014511100705',\n * //   '836430224577382061379420368022192503799782058803937958828224424676927281484',\n * //   '3', '3', '6', '1', '2', '3', '4', '5', '6']\n * ```\n */\nexport const fromCallsToExecuteCalldata = (calls: Call[]) => {\n  const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n  const compiledCalls = CallData.compile({ callArray });\n  return [...compiledCalls, ...calldata] as Calldata;\n};\n\n/**\n * Transforms a list of calls into the Cairo 0 `__execute__` calldata including nonce.\n * @deprecated\n */\nexport const fromCallsToExecuteCalldataWithNonce = (calls: Call[], nonce: BigNumberish) => {\n  return [...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()] as Calldata;\n};\n\n/**\n * Format Data inside Calls\n * @deprecated Not required for getting execute Calldata\n */\nexport const transformCallsToMulticallArrays_cairo1 = (calls: Call[]) => {\n  const callArray = calls.map<CallStruct>((call) => ({\n    to: toBigInt(call.contractAddress).toString(10),\n    selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n    calldata: CallData.compile(call.calldata || []),\n  }));\n  return callArray;\n};\n\n/**\n * Transforms a list of calls into the Cairo 1 `__execute__` calldata.\n * @param {Call[]} calls the list of calls to transform.\n * @returns {Calldata} the Cairo 1 `__execute__` calldata.\n * @example\n * ```typescript\n * const calls: Call[] = [\n * \t{\n * \t\tcontractAddress: \"0x1234567890123456789012345678901234567890\",\n * \t\tentrypoint: \"functionName\",\n * \t\tcalldata: [1, 2, 3]\n * \t},\n * \t{\n * \t\tcontractAddress: \"0x0987654321098765432109876543210987654321\",\n * \t\tentrypoint: \"anotherFunction\",\n * \t\tcalldata: [4, 5, 6]\n * \t}\n * ];\n * const result = transaction.fromCallsToExecuteCalldata_cairo1(calls);\n * // result = ['2', '103929005307130220006098923584552504982110632080',\n * //   '784552248838722632831848474045274978537388011177294206940059575485454596699',\n * //   '3', '1', '2', '3', '54400338722927882010739357306608455014511100705',\n * //   '836430224577382061379420368022192503799782058803937958828224424676927281484',\n * //   '3', '4', '5', '6']\n * ```\n */\nexport const fromCallsToExecuteCalldata_cairo1 = (calls: Call[]) => {\n  // ensure property order\n  const orderCalls = calls.map((call) => ({\n    contractAddress: call.contractAddress,\n    entrypoint: call.entrypoint,\n    calldata:\n      Array.isArray(call.calldata) && '__compiled__' in call.calldata\n        ? call.calldata // Calldata type\n        : CallData.compile(call.calldata as RawArgs), // RawArgsObject | RawArgsArray type\n  }));\n\n  return CallData.compile({ orderCalls });\n};\n\n/**\n * Create `__execute__` Calldata from Calls based on Cairo versions.\n * @param {Call[]} calls the list of calls to transform\n * @param {CairoVersion} cairoVersion the Cairo version\n * @returns {Calldata} the `__execute__` calldata.\n * @example\n * ```typescript\n * const calls: Call[] = [\n * \t{\n * \t\tcontractAddress: \"0x1234567890123456789012345678901234567890\",\n * \t\tentrypoint: \"functionName\",\n * \t\tcalldata: [1, 2, 3]\n * \t},\n * \t{\n * \t\tcontractAddress: \"0x0987654321098765432109876543210987654321\",\n * \t\tentrypoint: \"anotherFunction\",\n * \t\tcalldata: [4, 5, 6]\n * \t}\n * ];\n * const result = transaction.getExecuteCalldata(calls, '1');\n * // result = ['2', '103929005307130220006098923584552504982110632080',\n * //   '784552248838722632831848474045274978537388011177294206940059575485454596699',\n * //   '3', '1', '2', '3', '54400338722927882010739357306608455014511100705',\n * //   '836430224577382061379420368022192503799782058803937958828224424676927281484',\n * //   '3', '4', '5', '6']\n * ```\n */\nexport const getExecuteCalldata = (calls: Call[], cairoVersion: CairoVersion = '0') => {\n  if (cairoVersion === '1') {\n    return fromCallsToExecuteCalldata_cairo1(calls);\n  }\n  return fromCallsToExecuteCalldata(calls);\n};\n\n/**\n * Builds a UDCCall object.\n *\n * @param {UniversalDeployerContractPayload | UniversalDeployerContractPayload[]} payload the payload data for the UDCCall. Can be a single payload object or an array of payload objects.\n * @param {string} address the address to be used in the UDCCall\n * @returns { calls: Call[], addresses: string[] } the UDCCall object containing an array of calls and an array of addresses.\n * @example\n * ```typescript\n * const payload: UniversalDeployerContractPayload = {\n * classHash: \"0x1234567890123456789012345678901234567890\",\n * salt: \"0x0987654321098765432109876543210987654321\",\n * unique:true,\n * constructorCalldata: [1, 2, 3]\n * };\n * const address = \"0xABCDEF1234567890ABCDEF1234567890ABCDEF12\";\n * const result  = transaction.buildUDCCall(payload, address);\n * // result = {\n * // \tcalls: [\n * //\t\t\t{\n * //\t\t\tcontractAddress: \"0xABCDEF1234567890ABCDEF1234567890ABCDEF12\",\n * //\t\t\tentrypoint: \"functionName\",\n * //\t\t\tcalldata: [classHash, salt, true, 3, 1, 2, 3]\n * //\t\t}],\n * //\taddresses: [\"0x6fD084B56a7EDc5C06B3eB40f97Ae5A0C707A865\"]\n * // }\n * ```\n */\nexport function buildUDCCall(\n  payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n  address: string\n) {\n  const params = [].concat(payload as []).map((it) => {\n    const {\n      classHash,\n      salt,\n      unique = true,\n      constructorCalldata = [],\n    } = it as UniversalDeployerContractPayload;\n\n    const compiledConstructorCallData = CallData.compile(constructorCalldata);\n    const deploySalt = salt ?? randomAddress();\n\n    return {\n      call: {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          deploySalt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData,\n        ],\n      },\n      address: calculateContractAddressFromHash(\n        unique ? starkCurve.pedersen(address, deploySalt) : deploySalt,\n        classHash,\n        compiledConstructorCallData,\n        unique ? UDC.ADDRESS : 0\n      ),\n    };\n  });\n\n  return {\n    calls: params.map((it) => it.call),\n    addresses: params.map((it) => it.address),\n  };\n}\n\n/**\n * Return transaction versions based on version type, default version type is 'transaction'.\n * @param {'fee' | 'transaction'} [versionType] the type of version (\"fee\" or \"transaction\")\n * @returns {v1: ETransactionVersion, v2: ETransactionVersion, v3: ETransactionVersion} an object containing the transaction versions.\n * @example\n * ```typescript\n * const result = transaction.getVersionsByType('fee');\n * // result = {\n * //   v1: '0x100000000000000000000000000000001',\n * //   v2: '0x100000000000000000000000000000002',\n * //   v3: '0x100000000000000000000000000000003'\n * // }\n * ```\n */\nexport function getVersionsByType(versionType?: 'fee' | 'transaction') {\n  return versionType === 'fee'\n    ? {\n        v1: ETransactionVersion.F1,\n        v2: ETransactionVersion.F2,\n        v3: ETransactionVersion.F3,\n      }\n    : { v1: ETransactionVersion.V1, v2: ETransactionVersion.V2, v3: ETransactionVersion.V3 };\n}\n","import { NetworkName, StarknetChainId } from '../constants';\nimport { LibraryError } from '../provider/errors';\nimport {\n  AccountInvocationItem,\n  AccountInvocations,\n  BigNumberish,\n  BlockIdentifier,\n  BlockTag,\n  Call,\n  DeclareContractTransaction,\n  DeployAccountContractTransaction,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  RpcProviderOptions,\n  TransactionType,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  waitForTransactionOptions,\n} from '../types';\nimport { JRPC, RPCSPEC07 as RPC } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { isSierra } from '../utils/contract';\nimport { validateAndParseEthAddress } from '../utils/eth';\nimport fetch from '../utils/fetchPonyfill';\nimport { getSelector, getSelectorFromName } from '../utils/hash';\nimport { stringify } from '../utils/json';\nimport { getHexStringArray, toHex, toStorageKey } from '../utils/num';\nimport { Block, getDefaultNodeUrl, isV3Tx, isVersion, wait } from '../utils/provider';\nimport { decompressProgram, signatureToHexArray } from '../utils/stark';\nimport { getVersionsByType } from '../utils/transaction';\n\nconst defaultOptions = {\n  headers: { 'Content-Type': 'application/json' },\n  blockIdentifier: BlockTag.PENDING,\n  retries: 200,\n};\n\nexport class RpcChannel {\n  public nodeUrl: string;\n\n  public headers: object;\n\n  readonly retries: number;\n\n  public requestId: number;\n\n  readonly blockIdentifier: BlockIdentifier;\n\n  private chainId?: StarknetChainId;\n\n  private specVersion?: string;\n\n  private transactionRetryIntervalFallback?: number;\n\n  readonly waitMode: Boolean; // behave like web2 rpc and return when tx is processed\n\n  constructor(optionsOrProvider?: RpcProviderOptions) {\n    const {\n      nodeUrl,\n      retries,\n      headers,\n      blockIdentifier,\n      chainId,\n      specVersion,\n      waitMode,\n      transactionRetryIntervalFallback,\n    } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl as NetworkName)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl as NetworkName, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(undefined, optionsOrProvider?.default);\n    }\n    this.retries = retries || defaultOptions.retries;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n    this.specVersion = specVersion;\n    this.waitMode = waitMode || false;\n    this.requestId = 0;\n    this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;\n  }\n\n  private get transactionRetryIntervalDefault() {\n    return this.transactionRetryIntervalFallback ?? 5000;\n  }\n\n  public setChainId(chainId: StarknetChainId) {\n    this.chainId = chainId;\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    const rpcRequestBody: JRPC.RequestBody = {\n      id,\n      jsonrpc: '2.0',\n      method,\n      ...(params && { params }),\n    };\n    return fetch(this.nodeUrl, {\n      method: 'POST',\n      body: stringify(rpcRequestBody),\n      headers: this.headers as Record<string, string>,\n    });\n  }\n\n  protected errorHandler(method: string, params: any, rpcError?: JRPC.Error, otherError?: any) {\n    if (rpcError) {\n      const { code, message, data } = rpcError;\n      throw new LibraryError(\n        `RPC: ${method} with params ${stringify(params, null, 2)}\\n \n        ${code}: ${message}: ${stringify(data)}`\n      );\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n\n  protected async fetchEndpoint<T extends keyof RPC.Methods>(\n    method: T,\n    params?: RPC.Methods[T]['params']\n  ): Promise<RPC.Methods[T]['result']> {\n    try {\n      const rawResult = await this.fetch(method, params, (this.requestId += 1));\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result as RPC.Methods[T]['result'];\n    } catch (error: any) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n\n  public async getChainId() {\n    this.chainId ??= (await this.fetchEndpoint('starknet_chainId')) as StarknetChainId;\n    return this.chainId;\n  }\n\n  public async getSpecVersion() {\n    this.specVersion ??= (await this.fetchEndpoint('starknet_specVersion')) as StarknetChainId;\n    return this.specVersion;\n  }\n\n  public getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getNonce', {\n      contract_address,\n      block_id,\n    });\n  }\n\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  public getBlockLatestAccepted() {\n    return this.fetchEndpoint('starknet_blockHashAndNumber');\n  }\n\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  public getBlockNumber() {\n    return this.fetchEndpoint('starknet_blockNumber');\n  }\n\n  public getBlockWithTxHashes(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxHashes', { block_id });\n  }\n\n  public getBlockWithTxs(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxs', { block_id });\n  }\n\n  public getBlockWithReceipts(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithReceipts', { block_id });\n  }\n\n  public getBlockStateUpdate(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStateUpdate', { block_id });\n  }\n\n  public getBlockTransactionsTraces(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_traceBlockTransactions', { block_id });\n  }\n\n  public getBlockTransactionCount(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockTransactionCount', { block_id });\n  }\n\n  public getTransactionByHash(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionByHash', {\n      transaction_hash,\n    });\n  }\n\n  public getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getTransactionByBlockIdAndIndex', { block_id, index });\n  }\n\n  public getTransactionReceipt(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionReceipt', { transaction_hash });\n  }\n\n  public getTransactionTrace(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_traceTransaction', { transaction_hash });\n  }\n\n  /**\n   * Get the status of a transaction\n   */\n  public getTransactionStatus(transactionHash: BigNumberish) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint('starknet_getTransactionStatus', { transaction_hash });\n  }\n\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  public simulateTransaction(\n    invocations: AccountInvocations,\n    simulateTransactionOptions: getSimulateTransactionOptions = {}\n  ) {\n    const {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true,\n    } = simulateTransactionOptions;\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags: RPC.ESimulationFlag[] = [];\n    if (skipValidate) simulationFlags.push(RPC.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge) simulationFlags.push(RPC.ESimulationFlag.SKIP_FEE_CHARGE);\n\n    return this.fetchEndpoint('starknet_simulateTransactions', {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags,\n    });\n  }\n\n  public async waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? this.transactionRetryIntervalDefault;\n    const errorStates: any = options?.errorStates ?? [\n      RPC.ETransactionStatus.REJECTED,\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates: any = options?.successStates ?? [\n      RPC.ETransactionExecutionStatus.SUCCEEDED,\n      RPC.ETransactionStatus.ACCEPTED_ON_L2,\n      RPC.ETransactionStatus.ACCEPTED_ON_L1,\n    ];\n\n    let txStatus: RPC.TransactionStatus;\n    while (!onchain) {\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txStatus = await this.getTransactionStatus(transactionHash);\n\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n\n        if (!finalityStatus) {\n          // Transaction is potentially NOT_RECEIVED or RPC not Synced yet\n          // so we will retry '{ retries }' times\n          const error = new Error('waiting for transaction status');\n          throw error;\n        }\n\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message) as Error & { response: RPC.TransactionStatus };\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (\n          successStates.includes(executionStatus) ||\n          successStates.includes(finalityStatus)\n        ) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n\n      retries -= 1;\n    }\n\n    /**\n     * For some nodes even though the transaction has executionStatus SUCCEEDED finalityStatus ACCEPTED_ON_L2, getTransactionReceipt returns \"Transaction hash not found\"\n     * Retry until rpc is actually ready to work with txHash\n     */\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n    }\n    return txReceipt as RPC.SPEC.TXN_RECEIPT;\n  }\n\n  public getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStorageAt', {\n      contract_address,\n      key: parsedKey,\n      block_id,\n    });\n  }\n\n  public getClassHashAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassHashAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public getClass(\n    classHash: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClass', {\n      class_hash,\n      block_id,\n    });\n  }\n\n  public getClassAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public async getEstimateFee(\n    invocations: AccountInvocations,\n    { blockIdentifier = this.blockIdentifier, skipValidate = true }: getEstimateFeeBulkOptions\n  ) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion('0.5', await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [RPC.ESimulationFlag.SKIP_VALIDATE] : [],\n      };\n    } // else v(0.5) no flags\n\n    return this.fetchEndpoint('starknet_estimateFee', {\n      request: invocations.map((it) => this.buildTransaction(it, 'fee')),\n      block_id,\n      ...flags,\n    });\n  }\n\n  public async invoke(functionInvocation: Invocation, details: InvocationsDetailsWithNonce) {\n    let promise;\n    if (!isV3Tx(details)) {\n      // V1\n      promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: RPC.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: RPC.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else {\n      // V3\n      promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n        invoke_transaction: {\n          type: RPC.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async declare(\n    { contract, signature, senderAddress, compiledClassHash }: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      // V1 Cairo 0\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          version: RPC.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      // V2 Cairo1\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          compiled_class_hash: compiledClassHash || '',\n          version: RPC.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      // V3 Cairo1\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || '',\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    } else {\n      throw Error('declare unspotted parameters');\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async deployAccount(\n    { classHash, constructorCalldata, addressSalt, signature }: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (!isV3Tx(details)) {\n      // v1\n      promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: RPC.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else {\n      // v3\n      promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n        deploy_account_transaction: {\n          type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public callContract(call: Call, blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_call', {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata),\n      },\n      block_id,\n    });\n  }\n\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  public estimateMessageFee(\n    message: RPC.L1Message,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload),\n    };\n\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_estimateMessageFee', {\n      message: formattedMessage,\n      block_id,\n    });\n  }\n\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  public getSyncingStats() {\n    return this.fetchEndpoint('starknet_syncing');\n  }\n\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  public getEvents(eventFilter: RPC.EventFilter) {\n    return this.fetchEndpoint('starknet_getEvents', { filter: eventFilter });\n  }\n\n  public buildTransaction(\n    invocation: AccountInvocationItem,\n    versionType?: 'fee' | 'transaction'\n  ): RPC.BaseTransaction {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n\n    if (!isV3Tx(invocation)) {\n      // V0,V1,V2\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0),\n      };\n    } else {\n      // V3\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it)),\n      };\n    }\n\n    if (invocation.type === TransactionType.INVOKE) {\n      return {\n        // v0 v1 v3\n        type: RPC.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details,\n      } as RPC.SPEC.BROADCASTED_INVOKE_TXN;\n    }\n    if (invocation.type === TransactionType.DECLARE) {\n      if (!isSierra(invocation.contract)) {\n        // Cairo 0 - v1\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details,\n        } as RPC.SPEC.BROADCASTED_DECLARE_TXN_V1;\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program),\n        },\n        compiled_class_hash: invocation.compiledClassHash || '',\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details,\n      } as RPC.SPEC.BROADCASTED_DECLARE_TXN;\n    }\n    if (invocation.type === TransactionType.DEPLOY_ACCOUNT) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { account_deployment_data, ...restDetails } = details;\n      // v1 v3\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3) as RPC.SPEC.INVOKE_TXN['version'],\n        ...restDetails,\n      } as RPC.SPEC.BROADCASTED_DEPLOY_ACCOUNT_TXN;\n    }\n    throw Error('RPC buildTransaction received unknown TransactionType');\n  }\n}\n","/**\n * Map RPC Response to common interface response\n * Intersection (sequencer response ∩ (∪ rpc responses))\n */\nimport type {\n  BlockWithTxHashes,\n  ContractClassPayload,\n  ContractClassResponse,\n  EstimateFeeResponse,\n  EstimateFeeResponseBulk,\n  FeeEstimate,\n  GetBlockResponse,\n  GetTxReceiptResponseWithoutHelper,\n  RpcProviderOptions,\n  SimulateTransactionResponse,\n  SimulatedTransaction,\n  TransactionReceipt,\n} from '../../types/provider';\nimport { toBigInt } from '../num';\nimport { isString } from '../shortString';\nimport { estimateFeeToBounds, estimatedFeeToMaxFee } from '../stark';\nimport { ResponseParser } from './interface';\n\nexport class RPCResponseParser\n  implements\n    Omit<\n      ResponseParser,\n      | 'parseDeclareContractResponse'\n      | 'parseDeployContractResponse'\n      | 'parseInvokeFunctionResponse'\n      | 'parseGetTransactionReceiptResponse'\n      | 'parseGetTransactionResponse'\n      | 'parseCallContractResponse'\n    >\n{\n  private margin: RpcProviderOptions['feeMarginPercentage'];\n\n  constructor(margin?: RpcProviderOptions['feeMarginPercentage']) {\n    this.margin = margin;\n  }\n\n  private estimatedFeeToMaxFee(estimatedFee: Parameters<typeof estimatedFeeToMaxFee>[0]) {\n    return estimatedFeeToMaxFee(estimatedFee, this.margin?.maxFee);\n  }\n\n  private estimateFeeToBounds(estimate: Parameters<typeof estimateFeeToBounds>[0]) {\n    return estimateFeeToBounds(\n      estimate,\n      this.margin?.l1BoundMaxAmount,\n      this.margin?.l1BoundMaxPricePerUnit\n    );\n  }\n\n  public parseGetBlockResponse(res: BlockWithTxHashes): GetBlockResponse {\n    return { status: 'PENDING', ...res } as GetBlockResponse;\n  }\n\n  public parseTransactionReceipt(res: TransactionReceipt): GetTxReceiptResponseWithoutHelper {\n    // HOTFIX RPC 0.5 to align with RPC 0.6\n    // This case is RPC 0.5. It can be only v2 thx with FRI units\n    if ('actual_fee' in res && isString(res.actual_fee)) {\n      return {\n        ...(res as GetTxReceiptResponseWithoutHelper),\n        actual_fee: {\n          amount: res.actual_fee,\n          unit: 'FRI',\n        },\n      } as GetTxReceiptResponseWithoutHelper;\n    }\n\n    return res as GetTxReceiptResponseWithoutHelper;\n  }\n\n  public parseFeeEstimateResponse(res: FeeEstimate[]): EstimateFeeResponse {\n    const val = res[0];\n    return {\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n      data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n      data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n,\n    };\n  }\n\n  public parseFeeEstimateBulkResponse(res: FeeEstimate[]): EstimateFeeResponseBulk {\n    return res.map((val) => ({\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n      data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n      data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n,\n    }));\n  }\n\n  public parseSimulateTransactionResponse(\n    // TODO: revisit\n    // set as 'any' to avoid a mapped type circular recursion error stemming from\n    // merging src/types/api/rpcspec*/components/FUNCTION_INVOCATION.calls\n    //\n    // res: SimulateTransactionResponse\n    res: any\n  ): SimulateTransactionResponse {\n    return res.map((it: SimulatedTransaction) => {\n      return {\n        ...it,\n        suggestedMaxFee: this.estimatedFeeToMaxFee(it.fee_estimation.overall_fee),\n        resourceBounds: this.estimateFeeToBounds(it.fee_estimation),\n      };\n    });\n  }\n\n  public parseContractClassResponse(res: ContractClassPayload): ContractClassResponse {\n    return {\n      ...(res as ContractClassResponse),\n      abi: isString(res.abi) ? JSON.parse(res.abi) : res.abi,\n    };\n  }\n\n  public parseL1GasPriceResponse(res: BlockWithTxHashes): string {\n    return res.l1_gas_price.price_in_wei;\n  }\n}\n","/* eslint-disable no-nested-ternary */\nimport {\n  GetTxReceiptResponseWithoutHelper,\n  RejectedTransactionReceiptResponse,\n  RevertedTransactionReceiptResponse,\n  SuccessfulTransactionReceiptResponse,\n  TransactionExecutionStatus,\n} from '../types';\nimport type {\n  TransactionReceiptCallbacks,\n  TransactionReceiptCallbacksDefault,\n  TransactionReceiptStatus,\n  TransactionReceiptUtilityInterface,\n  TransactionReceiptValue,\n} from '../types/transactionReceipt';\n\n/**\n * Utility that analyses transaction receipt response and provides helpers to process it\n * @example\n * ```typescript\n * const responseTx = new ReceiptTx(receipt);\n * responseTx.match({\n *   success: (txR: SuccessfulTransactionReceiptResponse) => { },\n *   rejected: (txR: RejectedTransactionReceiptResponse) => { },\n *   reverted: (txR: RevertedTransactionReceiptResponse) => { },\n *   error: (err: Error) => { },\n * });\n * responseTx.match({\n *   success: (txR: SuccessfulTransactionReceiptResponse) => { },\n *   _: () => { },\n * }\n * ```\n */\nexport class ReceiptTx implements TransactionReceiptUtilityInterface {\n  public readonly statusReceipt: TransactionReceiptStatus;\n\n  public readonly value: TransactionReceiptValue;\n\n  constructor(receipt: GetTxReceiptResponseWithoutHelper) {\n    [this.statusReceipt, this.value] = ReceiptTx.isSuccess(receipt)\n      ? ['success', receipt]\n      : ReceiptTx.isReverted(receipt)\n        ? ['reverted', receipt]\n        : ReceiptTx.isRejected(receipt)\n          ? ['rejected', receipt]\n          : ['error', new Error('Unknown response type')];\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [key] of Object.entries(this)) {\n      Object.defineProperty(this, key, {\n        enumerable: false,\n      });\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [key, value] of Object.entries(receipt)) {\n      Object.defineProperty(this, key, {\n        enumerable: true,\n        writable: false,\n        value,\n      });\n    }\n  }\n\n  match(callbacks: TransactionReceiptCallbacks) {\n    if (this.statusReceipt in callbacks) {\n      return callbacks[this.statusReceipt]!(this.value as any);\n    }\n    return (callbacks as TransactionReceiptCallbacksDefault)._();\n  }\n\n  isSuccess(): this is SuccessfulTransactionReceiptResponse {\n    return this.statusReceipt === 'success';\n  }\n\n  isReverted(): this is RevertedTransactionReceiptResponse {\n    return this.statusReceipt === 'reverted';\n  }\n\n  isRejected(): this is RejectedTransactionReceiptResponse {\n    return this.statusReceipt === 'rejected';\n  }\n\n  isError() {\n    return this.statusReceipt === 'error';\n  }\n\n  static isSuccess(\n    transactionReceipt: GetTxReceiptResponseWithoutHelper\n  ): transactionReceipt is SuccessfulTransactionReceiptResponse {\n    return (\n      (transactionReceipt as SuccessfulTransactionReceiptResponse).execution_status ===\n      TransactionExecutionStatus.SUCCEEDED\n    );\n  }\n\n  static isReverted(\n    transactionReceipt: GetTxReceiptResponseWithoutHelper\n  ): transactionReceipt is RevertedTransactionReceiptResponse {\n    return (\n      (transactionReceipt as RevertedTransactionReceiptResponse).execution_status ===\n      TransactionExecutionStatus.REVERTED\n    );\n  }\n\n  static isRejected(\n    transactionReceipt: GetTxReceiptResponseWithoutHelper\n  ): transactionReceipt is RejectedTransactionReceiptResponse {\n    return (\n      (transactionReceipt as RejectedTransactionReceiptResponse).status ===\n      TransactionExecutionStatus.REJECTED\n    );\n  }\n}\n\nexport type GetTransactionReceiptResponse = GetTxReceiptResponseWithoutHelper & ReceiptTx;\n","/* eslint-disable max-classes-per-file */\nimport { Mixin } from 'ts-mixer';\n\nimport { RpcProvider as BaseRpcProvider } from '../rpc';\nimport { StarknetId } from './starknetId';\n\nexport class RpcProvider extends Mixin(BaseRpcProvider, StarknetId) {}\n","import { StarknetChainId, ZERO } from '../constants';\nimport { BigNumberish } from '../types';\nimport { tuple } from './calldata/cairo';\nimport { CairoCustomEnum } from './calldata/enum/CairoCustomEnum';\n/* eslint-disable no-param-reassign */\n\nconst basicAlphabet = 'abcdefghijklmnopqrstuvwxyz0123456789-';\nconst basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nconst bigAlphabet = '这来';\nconst basicAlphabetSize = BigInt(basicAlphabet.length);\nconst bigAlphabetSize = BigInt(bigAlphabet.length);\nconst bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\n\nfunction extractStars(str: string): [string, number] {\n  let k = 0;\n  while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {\n    str = str.substring(0, str.length - 1);\n    k += 1;\n  }\n  return [str, k];\n}\n\n/**\n * Decodes an array of BigInts into a string using the given algorithm.\n * @param {bigint[]} encoded The encoded array of BigInts.\n * @return {string} The decoded string.\n * @example\n * ```typescript\n * const result = starknetId.useDecoded([3015206943634620n]);\n * // result = \"starknetjs.stark\"\n * ```\n */\nexport function useDecoded(encoded: bigint[]): string {\n  let decoded = '';\n\n  encoded.forEach((subdomain) => {\n    while (subdomain !== ZERO) {\n      const code = subdomain % basicSizePlusOne;\n      subdomain /= basicSizePlusOne;\n      if (code === BigInt(basicAlphabet.length)) {\n        const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n        if (nextSubdomain === ZERO) {\n          const code2 = subdomain % bigAlphabetSizePlusOne;\n          subdomain = nextSubdomain;\n          if (code2 === ZERO) decoded += basicAlphabet[0];\n          else decoded += bigAlphabet[Number(code2) - 1];\n        } else {\n          const code2 = subdomain % bigAlphabetSize;\n          decoded += bigAlphabet[Number(code2)];\n          subdomain /= bigAlphabetSize;\n        }\n      } else decoded += basicAlphabet[Number(code)];\n    }\n\n    const [str, k] = extractStars(decoded);\n    if (k)\n      decoded =\n        str +\n        (k % 2 === 0\n          ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) +\n            bigAlphabet[0] +\n            basicAlphabet[1]\n          : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n    decoded += '.';\n  });\n\n  if (!decoded) {\n    return decoded;\n  }\n\n  return decoded.concat('stark');\n}\n\n/**\n * Encodes a string into a bigint value.\n *\n * @param {string} decoded The string to be encoded.\n * @returns {bigint} The encoded bigint value.\n * @example\n * ```typescript\n * const result = starknetId.useEncoded(\"starknet.js\");\n * // result = 3015206943634620n\n * ```\n */\nexport function useEncoded(decoded: string): bigint {\n  let encoded = BigInt(0);\n  let multiplier = BigInt(1);\n\n  if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n    const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n    decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n  } else {\n    const [str, k] = extractStars(decoded);\n    if (k) decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n  }\n\n  for (let i = 0; i < decoded.length; i += 1) {\n    const char = decoded[i];\n    const index = basicAlphabet.indexOf(char);\n    const bnIndex = BigInt(basicAlphabet.indexOf(char));\n\n    if (index !== -1) {\n      // add encoded + multiplier * index\n      if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n        encoded += multiplier * basicAlphabetSize;\n        multiplier *= basicSizePlusOne;\n        // add 0\n        multiplier *= basicSizePlusOne;\n      } else {\n        encoded += multiplier * bnIndex;\n        multiplier *= basicSizePlusOne;\n      }\n    } else if (bigAlphabet.indexOf(char) !== -1) {\n      // add encoded + multiplier * (basicAlphabetSize)\n      encoded += multiplier * basicAlphabetSize;\n      multiplier *= basicSizePlusOne;\n      // add encoded + multiplier * index\n      const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n      encoded += multiplier * BigInt(newid);\n      multiplier *= bigAlphabetSize;\n    }\n  }\n\n  return encoded;\n}\n\nexport enum StarknetIdContract {\n  MAINNET = '0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678',\n  TESTNET_SEPOLIA = '0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474',\n}\n\n/**\n * Returns the Starknet ID contract address based on the provided chain ID.\n *\n * @param {StarknetChainId} chainId The chain ID of the Starknet network.\n * @return {string} The Starknet ID contract address.\n * @throws {Error} Throws an error if the Starknet ID contract is not deployed on the network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\"\n * ```\n */\nexport function getStarknetIdContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error('Starknet.id is not yet deployed on this network');\n  }\n}\n\nexport enum StarknetIdIdentityContract {\n  MAINNET = '0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af',\n  TESTNET_SEPOLIA = '0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda',\n}\n\n/**\n * Returns the Starknet ID identity contract address for the given chain ID.\n *\n * @param {StarknetChainId} chainId The chain ID for the specified network.\n *\n * @return {string} The Starknet ID identity contract address for the specified network.\n *\n * @throws {Error} If the Starknet ID verifier contract is not deployed on the network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdIdentityContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\"\n * ```\n */\nexport function getStarknetIdIdentityContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdIdentityContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdIdentityContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error('Starknet.id verifier contract is not yet deployed on this network');\n  }\n}\n\nexport const StarknetIdMulticallContract =\n  '0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970';\n\n/**\n * Returns the Starknet.id multicall contract address based on the provided chainId.\n *\n * @param {StarknetChainId} chainId - The chainId of the network.\n * @return {string} - The address of the Starknet.id multicall contract.\n * @throws {Error} - If the Starknet.id multicall contract is not deployed on the network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdMulticallContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\"\n * ```\n */\nexport function getStarknetIdMulticallContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdMulticallContract;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdMulticallContract;\n\n    default:\n      throw new Error('Starknet.id multicall contract is not yet deployed on this network');\n  }\n}\n\nexport enum StarknetIdVerifierContract {\n  MAINNET = '0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf',\n  TESTNET_SEPOLIA = '0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566',\n}\n\n/**\n * Returns the address of the Starknet ID Verifier contract based on the specified chain ID.\n *\n * @param {StarknetChainId} chainId - The ID of the Starknet chain.\n * @return {string} - The address of the Starknet ID Verifier contract.\n * @throws {Error} - If the Starknet ID Verifier contract is not deployed on the specified network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdVerifierContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\"\n * ```\n */\nexport function getStarknetIdVerifierContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdVerifierContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdVerifierContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error('Starknet.id verifier contract is not yet deployed on this network');\n  }\n}\n\nexport enum StarknetIdPfpContract {\n  MAINNET = '0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7',\n  TESTNET_SEPOLIA = '0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02',\n}\n\n/**\n * Retrieves the contract address of the Starknet.id profile picture verifier contract based on the given chain ID.\n *\n * @param {StarknetChainId} chainId - The chain ID of the network.\n * @returns {string} - The contract address of the Starknet.id profile picture verifier contract.\n * @throws {Error} - Throws an error if the Starknet.id profile picture verifier contract is not yet deployed on the network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdPfpContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\"\n * ```\n */\nexport function getStarknetIdPfpContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdPfpContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdPfpContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error(\n        'Starknet.id profile picture verifier contract is not yet deployed on this network'\n      );\n  }\n}\n\nexport enum StarknetIdPopContract {\n  MAINNET = '0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4',\n  TESTNET_SEPOLIA = '0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a',\n}\n\n/**\n * Retrieves the Starknet ID Proof of Personhood (IdPop) verifier contract address for the given chain ID.\n *\n * @param {StarknetChainId} chainId - The chain ID of the Starknet network.\n * @return {string} - The Starknet ID Pop contract address.\n * @throws {Error} - If the Starknet ID Pop contract is not deployed on the specified network.\n * @example\n * ```typescript\n * const result = starknetId.getStarknetIdPopContract(constants.StarknetChainId.SN_SEPOLIA);\n * // result = \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\"\n * ```\n */\nexport function getStarknetIdPopContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdPopContract.MAINNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdPopContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error(\n        'Starknet.id proof of personhood verifier contract is not yet deployed on this network'\n      );\n  }\n}\n\n/**\n * Returns a CairoCustomEnum object.\n *\n * Functions to build CairoCustomEnum for multiCall contracts\n * @param {Object} [staticEx] An optional object defining the \"Static\" value of the CairoCustomEnum.\n * @param {number[]} [ifEqual] An optional array defining the \"IfEqual\" value of the CairoCustomEnum.\n * @param {number[]} [ifNotEqual] An optional array defining the \"IfNotEqual\" value of the CairoCustomEnum.\n * @return {CairoCustomEnum} - The created CairoCustomEnum object.\n * @example\n * ```typescript\n * const result: CairoCustomEnum = starknetId.execution(undefined, [1, 2, 3], undefined);\n * // result = CairoCustomEnum {\n * //   variant: {\n * //     Static: undefined,\n * //     IfEqual: { '0': 1, '1': 2, '2': 3 },\n * //     IfNotEqual: undefined\n * //   }\n * // }\n * ```\n */\nexport function execution(\n  staticEx: {} | undefined,\n  ifEqual: number[] | undefined = undefined,\n  ifNotEqual: number[] | undefined = undefined\n): CairoCustomEnum {\n  return new CairoCustomEnum({\n    Static: staticEx,\n    IfEqual: ifEqual ? tuple(ifEqual[0], ifEqual[1], ifEqual[2]) : undefined,\n    IfNotEqual: ifNotEqual ? tuple(ifNotEqual[0], ifNotEqual[1], ifNotEqual[2]) : undefined,\n  });\n}\n\n/**\n * Creates a new instance of CairoCustomEnum.\n *\n * @param {BigNumberish} [hardcoded] The hardcoded value for the CairoCustomEnum.\n * @param {number[]} [reference] The reference array for the CairoCustomEnum.\n * @returns {CairoCustomEnum} The new instance of CairoCustomEnum.\n * @example\n * ```typescript\n * const result: CairoCustomEnum = starknetId.dynamicFelt(undefined, [1, 2]);\n * // result = CairoCustomEnum {\n * //  variant: { Hardcoded: undefined, Reference: { '0': 1, '1': 2 } }\n * // }\n * ```\n */\nexport function dynamicFelt(\n  hardcoded: BigNumberish | undefined,\n  reference: number[] | undefined = undefined\n): CairoCustomEnum {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : undefined,\n  });\n}\n\n/**\n * Creates a new instance of CairoCustomEnum with the given parameters.\n * @param {BigNumberish} [hardcoded] The hardcoded value.\n * @param {BigNumberish[]} [reference] The reference value (optional).\n * @param {BigNumberish[]} [arrayReference] The array reference value (optional).\n * @return {CairoCustomEnum} The new instance of CairoCustomEnum.\n * @example\n * ```typescript\n * const result: CairoCustomEnum = starknetId.dynamicCallData(undefined, [1, 2], undefined);\n * // result = CairoCustomEnum {\n * //   variant: {\n * //     Hardcoded: undefined,\n * //     Reference: { '0': 1, '1': 2 },\n * //     ArrayReference: undefined\n * //   }\n * // }\n * ```\n */\nexport function dynamicCallData(\n  hardcoded: BigNumberish | undefined,\n  reference: BigNumberish[] | undefined = undefined,\n  arrayReference: BigNumberish[] | undefined = undefined\n): CairoCustomEnum {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : undefined,\n    ArrayReference: arrayReference ? tuple(arrayReference[0], arrayReference[1]) : undefined,\n  });\n}\n","import { BigNumberish, RawArgsArray, StarkProfile } from '../../types';\nimport { CallData } from '../../utils/calldata';\nimport { getSelectorFromName } from '../../utils/hash';\nimport { decodeShortString, encodeShortString } from '../../utils/shortString';\nimport {\n  dynamicCallData,\n  dynamicFelt,\n  execution,\n  getStarknetIdContract,\n  getStarknetIdIdentityContract,\n  getStarknetIdMulticallContract,\n  getStarknetIdPfpContract,\n  getStarknetIdPopContract,\n  getStarknetIdVerifierContract,\n  useDecoded,\n  useEncoded,\n} from '../../utils/starknetId';\nimport type { ProviderInterface } from '..';\n\nexport class StarknetId {\n  async getStarkName(address: BigNumberish, StarknetIdContract?: string) {\n    return StarknetId.getStarkName(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      address,\n      StarknetIdContract\n    );\n  }\n\n  public async getAddressFromStarkName(name: string, StarknetIdContract?: string): Promise<string> {\n    return StarknetId.getAddressFromStarkName(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      name,\n      StarknetIdContract\n    );\n  }\n\n  async getStarkProfile(\n    address: BigNumberish,\n    StarknetIdContract?: string,\n    StarknetIdIdentityContract?: string,\n    StarknetIdVerifierContract?: string,\n    StarknetIdPfpContract?: string,\n    StarknetIdPopContract?: string,\n    StarknetIdMulticallContract?: string\n  ) {\n    return StarknetId.getStarkProfile(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      address,\n      StarknetIdContract,\n      StarknetIdIdentityContract,\n      StarknetIdVerifierContract,\n      StarknetIdPfpContract,\n      StarknetIdPopContract,\n      StarknetIdMulticallContract\n    );\n  }\n\n  static async getStarkName(\n    provider: ProviderInterface,\n    address: BigNumberish,\n    StarknetIdContract?: string\n  ): Promise<string> {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);\n\n    try {\n      const hexDomain = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: 'address_to_domain',\n        calldata: CallData.compile({\n          address,\n          hint: [],\n        }),\n      });\n      const decimalDomain = hexDomain.map((element) => BigInt(element)).slice(1);\n\n      const stringDomain = useDecoded(decimalDomain);\n\n      if (!stringDomain) {\n        throw Error('Starkname not found');\n      }\n\n      return stringDomain;\n    } catch (e) {\n      if (e instanceof Error && e.message === 'Starkname not found') {\n        throw e;\n      }\n      throw Error('Could not get stark name');\n    }\n  }\n\n  static async getAddressFromStarkName(\n    provider: ProviderInterface,\n    name: string,\n    StarknetIdContract?: string\n  ): Promise<string> {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);\n\n    try {\n      const encodedDomain = name\n        .replace('.stark', '')\n        .split('.')\n        .map((part) => useEncoded(part).toString(10));\n\n      const addressData = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: 'domain_to_address',\n        calldata: CallData.compile({ domain: encodedDomain, hint: [] }),\n      });\n\n      return addressData[0];\n    } catch {\n      throw Error('Could not get address from stark name');\n    }\n  }\n\n  static async getStarkProfile(\n    provider: ProviderInterface,\n    address: BigNumberish,\n    StarknetIdContract?: string,\n    StarknetIdIdentityContract?: string,\n    StarknetIdVerifierContract?: string,\n    StarknetIdPfpContract?: string,\n    StarknetIdPopContract?: string,\n    StarknetIdMulticallContract?: string\n  ): Promise<StarkProfile> {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);\n    const identityContract = StarknetIdIdentityContract ?? getStarknetIdIdentityContract(chainId);\n    const verifierContract = StarknetIdVerifierContract ?? getStarknetIdVerifierContract(chainId);\n    const pfpContract = StarknetIdPfpContract ?? getStarknetIdPfpContract(chainId);\n    const popContract = StarknetIdPopContract ?? getStarknetIdPopContract(chainId);\n    const multicallAddress = StarknetIdMulticallContract ?? getStarknetIdMulticallContract(chainId);\n\n    try {\n      const calls: RawArgsArray = [\n        {\n          execution: execution({}),\n          to: dynamicCallData(contract),\n          selector: dynamicCallData(getSelectorFromName('address_to_domain')),\n          calldata: [dynamicCallData(address), dynamicCallData('0')],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(contract),\n          selector: dynamicFelt(getSelectorFromName('domain_to_id')),\n          calldata: [dynamicCallData(undefined, undefined, [0, 0])],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('twitter')),\n            dynamicCallData(verifierContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('github')),\n            dynamicCallData(verifierContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('discord')),\n            dynamicCallData(verifierContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('proof_of_personhood')),\n            dynamicCallData(popContract),\n            dynamicCallData('0'),\n          ],\n        },\n        // PFP\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('nft_pp_contract')),\n            dynamicCallData(pfpContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName('get_extended_verifier_data')),\n          calldata: [\n            dynamicCallData(undefined, [1, 0]),\n            dynamicCallData(encodeShortString('nft_pp_id')),\n            dynamicCallData('2'),\n            dynamicCallData(pfpContract),\n            dynamicCallData('0'),\n          ],\n        },\n        {\n          execution: execution(undefined, undefined, [6, 0, 0]),\n          to: dynamicFelt(undefined, [6, 0]),\n          selector: dynamicFelt(getSelectorFromName('tokenURI')),\n          calldata: [dynamicCallData(undefined, [7, 1]), dynamicCallData(undefined, [7, 2])],\n        },\n      ];\n\n      const data = await provider.callContract({\n        contractAddress: multicallAddress,\n        entrypoint: 'aggregate',\n        calldata: CallData.compile({\n          calls,\n        }),\n      });\n\n      if (Array.isArray(data)) {\n        // Format data\n        const size = parseInt(data[0], 16);\n        const finalArray: string[][] = [];\n        let index = 1;\n        for (let i = 0; i < size; i += 1) {\n          if (index < data.length) {\n            const subArraySize = parseInt(data[index], 16);\n            index += 1;\n\n            const subArray = data.slice(index, index + subArraySize);\n            finalArray.push(subArray);\n\n            index += subArraySize;\n          } else {\n            break;\n          }\n        }\n\n        const name = useDecoded(finalArray[0].slice(1).map((hexString) => BigInt(hexString)));\n\n        const twitter =\n          finalArray[2][0] !== '0x0' ? BigInt(finalArray[2][0]).toString() : undefined;\n        const github = finalArray[3][0] !== '0x0' ? BigInt(finalArray[3][0]).toString() : undefined;\n        const discord =\n          finalArray[4][0] !== '0x0' ? BigInt(finalArray[4][0]).toString() : undefined;\n        const proofOfPersonhood = finalArray[5][0] === '0x1'; // 10\n\n        const profilePictureMetadata =\n          data[0] === '0x9'\n            ? finalArray[8]\n                .slice(1)\n                .map((val: string) => decodeShortString(val))\n                .join('')\n            : undefined;\n\n        const profilePicture =\n          profilePictureMetadata ||\n          `https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`;\n\n        return {\n          name,\n          twitter,\n          github,\n          discord,\n          proofOfPersonhood,\n          profilePicture,\n        };\n      }\n      throw Error('Error while calling aggregate function');\n    } catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      throw Error('Could not get user stark profile data from address');\n    }\n  }\n}\n","import { RPC06, RPC07 } from '../channel';\nimport { StarknetChainId } from '../constants';\nimport type {\n  AccountInvocations,\n  BigNumberish,\n  Block,\n  BlockIdentifier,\n  Call,\n  CallContractResponse,\n  ContractClassResponse,\n  ContractVersion,\n  DeclareContractResponse,\n  DeclareContractTransaction,\n  DeployAccountContractPayload,\n  DeployAccountContractTransaction,\n  DeployContractResponse,\n  EstimateFeeResponse,\n  EstimateFeeResponseBulk,\n  GetBlockResponse,\n  GetTransactionResponse,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  InvokeFunctionResponse,\n  Nonce,\n  PendingBlock,\n  SimulateTransactionResponse,\n  StateUpdateResponse,\n  Storage,\n  getContractVersionOptions,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  waitForTransactionOptions,\n} from '../types';\nimport type { GetTransactionReceiptResponse } from '../utils/transactionReceipt';\n\nexport abstract class ProviderInterface {\n  public abstract channel: RPC07.RpcChannel | RPC06.RpcChannel;\n\n  /**\n   * Gets the Starknet chain Id\n   *\n   * @returns the chain Id\n   */\n  public abstract getChainId(): Promise<StarknetChainId>;\n\n  /**\n   * Calls a function on the Starknet contract.\n   *\n   * @param call transaction to be called\n   * @param blockIdentifier block identifier\n   * @returns the result of the function on the smart contract.\n   */\n  public abstract callContract(\n    call: Call,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<CallContractResponse>;\n\n  /**\n   * Gets the block information\n   *\n   * @param blockIdentifier block identifier\n   * @returns the block object\n   */\n  public abstract getBlock(blockIdentifier?: 'pending'): Promise<PendingBlock>;\n  public abstract getBlock(blockIdentifier: 'latest'): Promise<Block>;\n  public abstract getBlock(blockIdentifier: BlockIdentifier): Promise<GetBlockResponse>;\n\n  /**\n   * Gets the contract class of the deployed contract.\n   *\n   * @param contractAddress - contract address\n   * @param blockIdentifier - block identifier\n   * @returns Contract class of compiled contract\n   */\n  public abstract getClassAt(\n    contractAddress: string,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<ContractClassResponse>;\n\n  /**\n   * Gets the price of l1 gas in the block\n   *\n   * @param blockIdentifier block identifier\n   * @returns gas price of the block\n   */\n  public abstract getL1GasPrice(blockIdentifier: BlockIdentifier): Promise<string>;\n\n  /**\n   * Get L1 message hash from L2 transaction hash\n   * @param {BigNumberish} l2TxHash L2 transaction hash\n   * @returns {string} Hex string of L1 message hash\n   * @example\n   * In Sepolia Testnet :\n   * ```typescript\n   * const result = provider.getL1MessageHash('0x28dfc05eb4f261b37ddad451ff22f1d08d4e3c24dc646af0ec69fa20e096819');\n   * // result = '0x55b3f8b6e607fffd9b4d843dfe8f9b5c05822cd94fcad8797deb01d77805532a'\n   * ```\n   */\n  public abstract getL1MessageHash(l2TxHash: BigNumberish): Promise<string>;\n\n  /**\n   * Returns the contract class hash in the given block for the contract deployed at the given address\n   *\n   * @param contractAddress - contract address\n   * @param blockIdentifier - block identifier\n   * @returns Class hash\n   */\n  public abstract getClassHashAt(\n    contractAddress: string,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<string>;\n\n  /**\n   * Returns the contract class deployed under the given class hash.\n   *\n   * @param classHash - class hash\n   * @returns Contract class of compiled contract\n   */\n  public abstract getClassByHash(classHash: string): Promise<ContractClassResponse>;\n\n  /**\n   * Returns the nonce associated with the given address in the given block\n   *\n   * @param contractAddress - contract address\n   * @returns the hex nonce\n   */\n  public abstract getNonceForAddress(\n    contractAddress: string,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<Nonce>;\n\n  /**\n   * Get the value of the storage (contract's variable) at the given address and key\n   *\n   * @param contractAddress\n   * @param key - from getStorageVarAddress('<STORAGE_VARIABLE_NAME>') (WIP)\n   * @param blockIdentifier - block identifier\n   * @returns the value of the storage variable\n   */\n  public abstract getStorageAt(\n    contractAddress: string,\n    key: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<Storage>;\n\n  /**\n   * Gets the transaction information from a tx id.\n   *\n   * @param transactionHash\n   * @returns the transaction object \\{ transaction_id, status, transaction, block_number?, block_number?, transaction_index?, transaction_failure_reason? \\}\n   */\n  public abstract getTransaction(transactionHash: BigNumberish): Promise<GetTransactionResponse>;\n\n  /**\n   * Gets the transaction receipt from a tx hash.\n   *\n   * @param transactionHash\n   * @returns the transaction receipt object\n   */\n  public abstract getTransactionReceipt(\n    transactionHash: BigNumberish\n  ): Promise<GetTransactionReceiptResponse>;\n\n  /**\n   * Deploys a given compiled Account contract (json) to starknet\n   *\n   * @param payload payload to be deployed containing:\n   * - compiled contract code\n   * - constructor calldata\n   * - address salt\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract deployAccountContract(\n    payload: DeployAccountContractPayload,\n    details: InvocationsDetailsWithNonce\n  ): Promise<DeployContractResponse>;\n\n  /**\n   * Invokes a function on starknet\n   * @deprecated This method won't be supported as soon as fees are mandatory. Should not be used outside of Account class\n   *\n   * @param invocation the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce - optional nonce\n   * - version - optional version\n   * - maxFee - optional maxFee\n   * @returns response from addTransaction\n   */\n  public abstract invokeFunction(\n    invocation: Invocation,\n    details: InvocationsDetailsWithNonce\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Declares a given compiled contract (json) to starknet\n   * @param transaction transaction payload to be deployed containing:\n   * - compiled contract code\n   * - sender address\n   * - signature\n   * @param details Invocation Details containing:\n   * - nonce\n   * - optional version\n   * - optional maxFee\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract declareContract(\n    transaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ): Promise<DeclareContractResponse>;\n\n  /**\n   * Estimates the fee for a given INVOKE transaction\n   * @deprecated Please use getInvokeEstimateFee or getDeclareEstimateFee instead. Should not be used outside of Account class\n   *\n   * @param invocation the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce - optional nonce\n   * - version - optional version\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   */\n  public abstract getEstimateFee(\n    invocation: Invocation,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimates the fee for a given INVOKE transaction\n   *\n   * @param invocation the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce - optional nonce\n   * - version - optional version\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   */\n  public abstract getInvokeEstimateFee(\n    invocation: Invocation,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimates the fee for a given DECLARE transaction\n   *\n   * @param transaction transaction payload to be declared containing:\n   * - compiled contract code\n   * - sender address\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce\n   * - version - optional version\n   * - optional maxFee\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   */\n  public abstract getDeclareEstimateFee(\n    transaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimates the fee for a given DEPLOY_ACCOUNT transaction\n   *\n   * @param transaction transaction payload to be deployed containing:\n   * - classHash\n   * - constructorCalldata\n   * - addressSalt\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce\n   * - version - optional version\n   * - optional maxFee\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   */\n  public abstract getDeployAccountEstimateFee(\n    transaction: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimates the fee for a list of INVOKE transaction\n   *\n   * @param invocations AccountInvocations - Complete invocations array with account details\n   * @param options getEstimateFeeBulkOptions\n   * - (optional) blockIdentifier - BlockIdentifier\n   * @returns the estimated fee\n   */\n  public abstract getEstimateFeeBulk(\n    invocations: AccountInvocations,\n    options?: getEstimateFeeBulkOptions\n  ): Promise<EstimateFeeResponseBulk>;\n\n  /**\n   * Wait for the transaction to be accepted\n   * @param txHash - transaction hash\n   * @param options waitForTransactionOptions\n   * - (optional) retryInterval: number | undefined;\n   * - (optional) successStates: TransactionStatus[] | undefined;\n   * @return GetTransactionReceiptResponse\n   */\n  public abstract waitForTransaction(\n    txHash: BigNumberish,\n    options?: waitForTransactionOptions\n  ): Promise<GetTransactionReceiptResponse>;\n\n  /**\n   * Simulates the transaction and returns the transaction trace and estimated fee.\n   *\n   * @param invocations AccountInvocations - Complete invocations array with account details\n   * @param options - getSimulateTransactionOptions\n   *  - (optional) blockIdentifier - block identifier\n   *  - (optional) skipValidate - skip cairo __validate__ method\n   *  - (optional) skipExecute - skip cairo __execute__ method\n   * @returns an array of transaction trace and estimated fee\n   */\n  public abstract getSimulateTransaction(\n    invocations: AccountInvocations,\n    options?: getSimulateTransactionOptions\n  ): Promise<SimulateTransactionResponse>;\n\n  /**\n   * Gets the state changes in a specific block (result of executing the requested block)\n   *\n   * @param blockIdentifier - block identifier\n   * @returns StateUpdateResponse\n   */\n  public abstract getStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;\n\n  /**\n   * Gets the contract version from the provided address\n   * @param contractAddress string\n   * @param classHash undefined\n   * @param options - getContractVersionOptions\n   *   - (optional) compiler - (default true) extract compiler version using type tactic from abi\n   *   - (optional) blockIdentifier - block identifier\n   */\n  public abstract getContractVersion(\n    contractAddress: string,\n    classHash?: undefined,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n\n  /**\n   * Gets the contract version from the provided address\n   * @param contractAddress undefined\n   * @param classHash\n   * @param options - getContractVersionOptions\n   *   - (optional) compiler - (default true) extract compiler version using type tactic from abi\n   *   - (optional) blockIdentifier - block identifier\n   */\n  public abstract getContractVersion(\n    contractAddress: undefined,\n    classHash: string,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n}\n","import { RpcProvider } from './rpc';\n\nexport { RpcProvider as Provider } from './extensions/default'; // backward-compatibility\nexport * from './errors';\nexport * from './interface';\nexport * from './extensions/default';\n\nexport const defaultProvider = new RpcProvider({ default: true });\n","import {\n  Call,\n  DeclareSignerDetails,\n  DeployAccountSignerDetails,\n  InvocationsSignerDetails,\n  Signature,\n  TypedData,\n} from '../types';\n\nexport abstract class SignerInterface {\n  /**\n   * Method to get the public key of the signer\n   *\n   * @returns {string} hex-string\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const result = await mySigner.getPubKey();\n   * // result = \"0x566d69d8c99f62bc71118399bab25c1f03719463eab8d6a444cd11ece131616\"\n   * ```\n   */\n  public abstract getPubKey(): Promise<string>;\n\n  /**\n   * Signs a JSON object for off-chain usage with the private key and returns the signature.\n   * This adds a message prefix so it can't be interchanged with transactions\n   *\n   * @param {TypedData} typedData JSON object to be signed\n   * @param {string} accountAddress Hex string of the account's address\n   * @returns {Promise<Signature>} the signature of the message\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   *     const myTypedData: TypedData = {\n   *         domain: {name: \"Example DApp\",\n   *           chainId: constants.StarknetChainId.SN_SEPOLIA,\n   *           version: \"0.0.3\"},\n   *         types: {StarkNetDomain: [\n   *             { name: \"name\", type: \"string\" },\n   *             { name: \"chainId\", type: \"felt\" },\n   *             { name: \"version\", type: \"string\" }],\n   *           Message: [{ name: \"message\", type: \"felt\" }]},\n   *         primaryType: \"Message\", message: {message: \"1234\"}};\n   *     const result = await mySigner.signMessage(myTypedData,\"0x5d08a4e9188429da4e993c9bf25aafe5cd491ee2b501505d4d059f0c938f82d\");\n   * // result = Signature {r: 684915484701699003335398790608214855489903651271362390249153620883122231253n,\n   * // s: 1399150959912500412309102776989465580949387575375484933432871778355496929189n, recovery: 1}\n   * ```\n\n   */\n  public abstract signMessage(typedData: TypedData, accountAddress: string): Promise<Signature>;\n\n  /**\n   * Signs transactions with the private key and returns the signature\n   *\n   * @param {Call[]} transactions array of Call objects\n   * @param {InvocationsSignerDetails} transactionsDetail InvocationsSignerDetails object\n   * @returns {Promise<Signature>} the signature of the transaction\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const calls: Call[] = [{\n   *     contractAddress: \"0x1234567890123456789012345678901234567890\",\n   *     entrypoint: \"functionName\",\n   *     calldata: [1, 2, 3]\n   * }];\n   * const transactionsDetail: InvocationsSignerDetails = {\n   *     walletAddress: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e',\n   *     chainId: constants.StarknetChainId.SN_MAIN,\n   *     cairoVersion: \"1\",\n   *     maxFee: '0x1234567890abcdef',\n   *     version: \"0x0\", nonce: 1};\n   * const result = await mySigner.signTransaction(calls, transactionsDetail);\n   * // result = Signature {r: 304910226421970384958146916800275294114105560641204815169249090836676768876n,\n   * //   s: 1072798866000813654190523783606274062837012608648308896325315895472901074693n, recovery: 0}\n   * ```\n   */\n  public abstract signTransaction(\n    transactions: Call[],\n    transactionsDetail: InvocationsSignerDetails\n  ): Promise<Signature>;\n\n  /**\n   * Signs a DEPLOY_ACCOUNT transaction with the private key and returns the signature\n   *\n   * @param {DeployAccountSignerDetails} transaction to deploy an account contract\n   * @returns {Promise<Signature>} the signature of the transaction to deploy an account\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const myDeployAcc: DeployAccountSignerDetails = {\n   *   contractAddress: \"0x65a822fbee1ae79e898688b5a4282dc79e0042cbed12f6169937fddb4c26641\",\n   *   version: \"0x2\", chainId: constants.StarknetChainId.SN_SEPOLIA,\n   *   classHash: \"0x5f3614e8671257aff9ac38e929c74d65b02d460ae966cd826c9f04a7fa8e0d4\",\n   *   constructorCalldata: [1, 2],addressSalt: 1234,\n   *   nonce: 45, maxFee: 10 ** 15, tip: 0, paymasterData: [],accountDeploymentData: [],\n   *   nonceDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n   *   feeDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n   *   resourceBounds: stark.estimateFeeToBounds(constants.ZERO),\n   * }\n   * const result = await mySigner.signDeployAccountTransaction(myDeployAcc);\n   * // result = Signature {r: 2871311234341436528393212130310036951068553852419934781736214693308640202748n,\n   * //  s: 1746271646048888422437132495446973163454853863041370993384284773665861377605n, recovery: 1}\n   * ```\n   */\n  public abstract signDeployAccountTransaction(\n    transaction: DeployAccountSignerDetails\n  ): Promise<Signature>;\n\n  /**\n   * Signs a DECLARE transaction with the private key and returns the signature\n   *\n   * @param {DeclareSignerDetails} transaction to declare a class\n   * @returns {Promise<Signature>} the signature of the transaction to declare a class\n   * @example\n   * ```typescript\n   * const mySigner = new Signer(\"0x123\");\n   * const myDeclare: DeclareSignerDetails = {\n   *   version: \"0x2\", chainId: constants.StarknetChainId.SN_SEPOLIA,\n   *   senderAddress: \"0x65a822fbee1ae79e898688b5a4282dc79e0042cbed12f6169937fddb4c26641\",\n   *   classHash: \"0x5f3614e8671257aff9ac38e929c74d65b02d460ae966cd826c9f04a7fa8e0d4\",\n   *   nonce: 45, maxFee: 10 ** 15, tip: 0, paymasterData: [], accountDeploymentData: [],\n   *   nonceDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n   *   feeDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,\n   *   resourceBounds: stark.estimateFeeToBounds(constants.ZERO),\n}\n   * const result = await mySigner.signDeclareTransaction(myDeclare);\n   * // result = Signature {r: 2432056944313955951711774394836075930010416436707488863728289188289211995670n,\n   * //  s: 3407649393310177489888603098175002856596469926897298636282244411990343146307n, recovery: 1}\n   * ```\n   */\n  public abstract signDeclareTransaction(transaction: DeclareSignerDetails): Promise<Signature>;\n}\n","/* eslint-disable no-param-reassign */\nimport { PRIME, RANGE_FELT, RANGE_I128, RANGE_U128 } from '../constants';\nimport {\n  BigNumberish,\n  TypedDataRevision as Revision,\n  StarknetEnumType,\n  StarknetMerkleType,\n  StarknetType,\n  TypedData,\n} from '../types';\nimport assert from './assert';\nimport { byteArrayFromString } from './calldata/byteArray';\nimport {\n  computePedersenHash,\n  computePedersenHashOnElements,\n  computePoseidonHash,\n  computePoseidonHashOnElements,\n  getSelectorFromName,\n} from './hash';\nimport { MerkleTree } from './merkle';\nimport { isHex, toHex } from './num';\nimport { encodeShortString, isString } from './shortString';\n\n/** @deprecated prefer importing from 'types' over 'typedData' */\nexport * from '../types/typedData';\n\ninterface Context {\n  parent?: string;\n  key?: string;\n}\n\ninterface Configuration {\n  domain: string;\n  hashMethod: (data: BigNumberish[]) => string;\n  hashMerkleMethod: (a: BigNumberish, b: BigNumberish) => string;\n  escapeTypeString: (s: string) => string;\n  presetTypes: TypedData['types'];\n}\n\nconst presetTypes: TypedData['types'] = {\n  u256: JSON.parse('[{ \"name\": \"low\", \"type\": \"u128\" }, { \"name\": \"high\", \"type\": \"u128\" }]'),\n  TokenAmount: JSON.parse(\n    '[{ \"name\": \"token_address\", \"type\": \"ContractAddress\" }, { \"name\": \"amount\", \"type\": \"u256\" }]'\n  ),\n  NftId: JSON.parse(\n    '[{ \"name\": \"collection_address\", \"type\": \"ContractAddress\" }, { \"name\": \"token_id\", \"type\": \"u256\" }]'\n  ),\n};\n\nconst revisionConfiguration: Record<Revision, Configuration> = {\n  [Revision.ACTIVE]: {\n    domain: 'StarknetDomain',\n    hashMethod: computePoseidonHashOnElements,\n    hashMerkleMethod: computePoseidonHash,\n    escapeTypeString: (s) => `\"${s}\"`,\n    presetTypes,\n  },\n  [Revision.LEGACY]: {\n    domain: 'StarkNetDomain',\n    hashMethod: computePedersenHashOnElements,\n    hashMerkleMethod: computePedersenHash,\n    escapeTypeString: (s) => s,\n    presetTypes: {},\n  },\n};\n\nfunction assertRange(data: unknown, type: string, { min, max }: { min: bigint; max: bigint }) {\n  const value = BigInt(data as string);\n  assert(value >= min && value <= max, `${value} (${type}) is out of bounds [${min}, ${max}]`);\n}\n\nfunction identifyRevision({ types, domain }: TypedData) {\n  if (revisionConfiguration[Revision.ACTIVE].domain in types && domain.revision === Revision.ACTIVE)\n    return Revision.ACTIVE;\n\n  if (\n    revisionConfiguration[Revision.LEGACY].domain in types &&\n    (domain.revision ?? Revision.LEGACY) === Revision.LEGACY\n  )\n    return Revision.LEGACY;\n\n  return undefined;\n}\n\nfunction getHex(value: BigNumberish): string {\n  try {\n    return toHex(value);\n  } catch (e) {\n    if (isString(value)) {\n      return toHex(encodeShortString(value));\n    }\n    throw new Error(`Invalid BigNumberish: ${value}`);\n  }\n}\n\n/**\n * Validates that `data` matches the EIP-712 JSON schema.\n */\nfunction validateTypedData(data: unknown): data is TypedData {\n  const typedData = data as TypedData;\n  return Boolean(\n    typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData)\n  );\n}\n\n/**\n * Prepares the selector for use.\n *\n * @param {string} selector - The selector to be prepared.\n * @returns {string} The prepared selector.\n */\nexport function prepareSelector(selector: string): string {\n  return isHex(selector) ? selector : getSelectorFromName(selector);\n}\n\n/**\n * Checks if the given Starknet type is a Merkle tree type.\n *\n * @param {StarknetType} type - The StarkNet type to check.\n *\n * @returns {boolean} - True if the type is a Merkle tree type, false otherwise.\n */\nexport function isMerkleTreeType(type: StarknetType): type is StarknetMerkleType {\n  return type.type === 'merkletree';\n}\n\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n */\nexport function getDependencies(\n  types: TypedData['types'],\n  type: string,\n  dependencies: string[] = [],\n  contains: string = '',\n  revision: Revision = Revision.LEGACY\n): string[] {\n  // Include pointers (struct arrays)\n  if (type[type.length - 1] === '*') {\n    type = type.slice(0, -1);\n  } else if (revision === Revision.ACTIVE) {\n    // enum base\n    if (type === 'enum') {\n      type = contains;\n    }\n    // enum element types\n    else if (type.match(/^\\(.*\\)$/)) {\n      type = type.slice(1, -1);\n    }\n  }\n\n  if (dependencies.includes(type) || !types[type]) {\n    return dependencies;\n  }\n\n  return [\n    type,\n    ...(types[type] as StarknetEnumType[]).reduce<string[]>(\n      (previous, t) => [\n        ...previous,\n        ...getDependencies(types, t.type, previous, t.contains, revision).filter(\n          (dependency) => !previous.includes(dependency)\n        ),\n      ],\n      []\n    ),\n  ];\n}\n\nfunction getMerkleTreeType(types: TypedData['types'], ctx: Context) {\n  if (ctx.parent && ctx.key) {\n    const parentType = types[ctx.parent];\n    const merkleType = parentType.find((t) => t.name === ctx.key)!;\n    const isMerkleTree = isMerkleTreeType(merkleType);\n    if (!isMerkleTree) {\n      throw new Error(`${ctx.key} is not a merkle tree`);\n    }\n    if (merkleType.contains.endsWith('*')) {\n      throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n    }\n    return merkleType.contains;\n  }\n  return 'raw';\n}\n\n/**\n * Encode a type to a string. All dependent types are alphabetically sorted.\n */\nexport function encodeType(\n  types: TypedData['types'],\n  type: string,\n  revision: Revision = Revision.LEGACY\n): string {\n  const allTypes =\n    revision === Revision.ACTIVE\n      ? { ...types, ...revisionConfiguration[revision].presetTypes }\n      : types;\n  const [primary, ...dependencies] = getDependencies(\n    allTypes,\n    type,\n    undefined,\n    undefined,\n    revision\n  );\n  const newTypes = !primary ? [] : [primary, ...dependencies.sort()];\n\n  const esc = revisionConfiguration[revision].escapeTypeString;\n\n  return newTypes\n    .map((dependency) => {\n      const dependencyElements = allTypes[dependency].map((t) => {\n        const targetType =\n          t.type === 'enum' && revision === Revision.ACTIVE\n            ? (t as StarknetEnumType).contains\n            : t.type;\n        // parentheses handling for enum variant types\n        const typeString = targetType.match(/^\\(.*\\)$/)\n          ? `(${targetType\n              .slice(1, -1)\n              .split(',')\n              .map((e) => (e ? esc(e) : e))\n              .join(',')})`\n          : esc(targetType);\n        return `${esc(t.name)}:${typeString}`;\n      });\n      return `${esc(dependency)}(${dependencyElements})`;\n    })\n    .join('');\n}\n\n/**\n * Get a type string as hash.\n */\nexport function getTypeHash(\n  types: TypedData['types'],\n  type: string,\n  revision: Revision = Revision.LEGACY\n): string {\n  return getSelectorFromName(encodeType(types, type, revision));\n}\n\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n */\nexport function encodeValue(\n  types: TypedData['types'],\n  type: string,\n  data: unknown,\n  ctx: Context = {},\n  revision: Revision = Revision.LEGACY\n): [string, string] {\n  if (types[type]) {\n    return [type, getStructHash(types, type, data as TypedData['message'], revision)];\n  }\n\n  if (revisionConfiguration[revision].presetTypes[type]) {\n    return [\n      type,\n      getStructHash(\n        revisionConfiguration[revision].presetTypes,\n        type,\n        data as TypedData['message'],\n        revision\n      ),\n    ];\n  }\n\n  if (type.endsWith('*')) {\n    const hashes: string[] = (data as Array<TypedData['message']>).map(\n      (entry) => encodeValue(types, type.slice(0, -1), entry, undefined, revision)[1]\n    );\n    return [type, revisionConfiguration[revision].hashMethod(hashes)];\n  }\n\n  switch (type) {\n    case 'enum': {\n      if (revision === Revision.ACTIVE) {\n        const [variantKey, variantData] = Object.entries(data as TypedData['message'])[0];\n\n        const parentType = types[ctx.parent as string][0] as StarknetEnumType;\n        const enumType = types[parentType.contains];\n        const variantType = enumType.find((t) => t.name === variantKey) as StarknetType;\n        const variantIndex = enumType.indexOf(variantType);\n\n        const encodedSubtypes = variantType.type\n          .slice(1, -1)\n          .split(',')\n          .map((subtype, index) => {\n            if (!subtype) return subtype;\n            const subtypeData = (variantData as unknown[])[index];\n            return encodeValue(types, subtype, subtypeData, undefined, revision)[1];\n          });\n        return [\n          type,\n          revisionConfiguration[revision].hashMethod([variantIndex, ...encodedSubtypes]),\n        ];\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'merkletree': {\n      const merkleTreeType = getMerkleTreeType(types, ctx);\n      const structHashes: string[] = (data as Array<TypedData['message']>).map((struct) => {\n        return encodeValue(types, merkleTreeType, struct, undefined, revision)[1];\n      });\n      const { root } = new MerkleTree(\n        structHashes as string[],\n        revisionConfiguration[revision].hashMerkleMethod\n      );\n      return ['felt', root];\n    }\n    case 'selector': {\n      return ['felt', prepareSelector(data as string)];\n    }\n    case 'string': {\n      if (revision === Revision.ACTIVE) {\n        const byteArray = byteArrayFromString(data as string);\n        const elements = [\n          byteArray.data.length,\n          ...byteArray.data,\n          byteArray.pending_word,\n          byteArray.pending_word_len,\n        ];\n        return [type, revisionConfiguration[revision].hashMethod(elements)];\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'i128': {\n      if (revision === Revision.ACTIVE) {\n        const value = BigInt(data as string);\n        assertRange(value, type, RANGE_I128);\n        return [type, getHex(value < 0n ? PRIME + value : value)];\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'timestamp':\n    case 'u128': {\n      if (revision === Revision.ACTIVE) {\n        assertRange(data, type, RANGE_U128);\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'felt':\n    case 'shortstring': {\n      // TODO: should 'shortstring' diverge into directly using encodeShortString()?\n      if (revision === Revision.ACTIVE) {\n        assertRange(getHex(data as string), type, RANGE_FELT);\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'ClassHash':\n    case 'ContractAddress': {\n      if (revision === Revision.ACTIVE) {\n        assertRange(data, type, RANGE_FELT);\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'bool': {\n      if (revision === Revision.ACTIVE) {\n        assert(typeof data === 'boolean', `Type mismatch for ${type} ${data}`);\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    default: {\n      if (revision === Revision.ACTIVE) {\n        throw new Error(`Unsupported type: ${type}`);\n      }\n      return [type, getHex(data as string)];\n    }\n  }\n}\n\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values.\n * All dependent types are automatically encoded.\n */\nexport function encodeData<T extends TypedData>(\n  types: T['types'],\n  type: string,\n  data: T['message'],\n  revision: Revision = Revision.LEGACY\n) {\n  const targetType = types[type] ?? revisionConfiguration[revision].presetTypes[type];\n  const [returnTypes, values] = targetType.reduce<[string[], string[]]>(\n    ([ts, vs], field) => {\n      if (\n        data[field.name as keyof T['message']] === undefined ||\n        (data[field.name as keyof T['message']] === null && field.type !== 'enum')\n      ) {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n\n      const value = data[field.name as keyof T['message']];\n      const ctx = { parent: type, key: field.name };\n      const [t, encodedValue] = encodeValue(types, field.type, value, ctx, revision);\n\n      return [\n        [...ts, t],\n        [...vs, encodedValue],\n      ];\n    },\n    [['felt'], [getTypeHash(types, type, revision)]]\n  );\n\n  return [returnTypes, values];\n}\n\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values.\n * All dependent types are automatically encoded.\n */\nexport function getStructHash<T extends TypedData>(\n  types: T['types'],\n  type: string,\n  data: T['message'],\n  revision: Revision = Revision.LEGACY\n) {\n  return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);\n}\n\n/**\n * Get the SNIP-12 encoded message to sign, from the typedData object.\n */\nexport function getMessageHash(typedData: TypedData, account: BigNumberish): string {\n  if (!validateTypedData(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  const revision = identifyRevision(typedData) as Revision;\n  const { domain, hashMethod } = revisionConfiguration[revision];\n\n  const message = [\n    encodeShortString('StarkNet Message'),\n    getStructHash(typedData.types, domain, typedData.domain, revision),\n    account,\n    getStructHash(typedData.types, typedData.primaryType, typedData.message, revision),\n  ];\n\n  return hashMethod(message);\n}\n","import { BigNumberish } from '../types';\nimport { computePedersenHash } from './hash';\n\nexport class MerkleTree {\n  public leaves: string[];\n\n  public branches: string[][] = [];\n\n  public root: string;\n\n  public hashMethod: (a: BigNumberish, b: BigNumberish) => string;\n\n  /**\n   * Create a Merkle tree\n   *\n   * @param leafHashes hex-string array\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns created Merkle tree\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * // tree = {\n   * //   branches: [['0x5bb9440e2...', '0x262697b88...', ...], ['0x38118a340...', ...], ...],\n   * //   leaves: ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'],\n   * //   root: '0x7f748c75e5bdb7ae28013f076b8ab650c4e01d3530c6e5ab665f9f1accbe7d4',\n   * //   hashMethod: [Function computePedersenHash],\n   * // }\n   * ```\n   */\n  constructor(\n    leafHashes: string[],\n    hashMethod: (a: BigNumberish, b: BigNumberish) => string = computePedersenHash\n  ) {\n    this.hashMethod = hashMethod;\n    this.leaves = leafHashes;\n    this.root = this.build(leafHashes);\n  }\n\n  /** @ignore */\n  private build(leaves: string[]): string {\n    if (leaves.length === 1) {\n      return leaves[0];\n    }\n    if (leaves.length !== this.leaves.length) {\n      this.branches.push(leaves);\n    }\n    const newLeaves: string[] = [];\n    for (let i = 0; i < leaves.length; i += 2) {\n      if (i + 1 === leaves.length) {\n        newLeaves.push(MerkleTree.hash(leaves[i], '0x0', this.hashMethod));\n      } else {\n        newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));\n      }\n    }\n    return this.build(newLeaves);\n  }\n\n  /**\n   * Calculate hash from ordered a and b, Pedersen hash default\n   *\n   * @param a first value\n   * @param b second value\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns result of the hash function\n   * @example\n   * ```typescript\n   * const result1 = MerkleTree.hash('0xabc', '0xdef');\n   * // result1 = '0x484f029da7914ada038b1adf67fc83632364a3ebc2cd9349b41ab61626d9e82'\n   *\n   * const customHashMethod = (a, b) => `custom_${a}_${b}`;\n   * const result2 = MerkleTree.hash('0xabc', '0xdef', customHashMethod);\n   * // result2 = 'custom_2748_3567'\n   * ```\n   */\n  static hash(\n    a: BigNumberish,\n    b: BigNumberish,\n    hashMethod: (a: BigNumberish, b: BigNumberish) => string = computePedersenHash\n  ) {\n    const [aSorted, bSorted] = [BigInt(a), BigInt(b)].sort((x, y) => (x >= y ? 1 : -1));\n    return hashMethod(aSorted, bSorted);\n  }\n\n  /**\n   * Calculates the merkle membership proof path\n   *\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns collection of merkle proof hex-string hashes\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * const result = tree.getProof('0x3');\n   * // result = [\n   * //   '0x4',\n   * //   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',\n   * //   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',\n   * // ]\n   * ```\n   */\n  public getProof(leaf: string, branch = this.leaves, hashPath: string[] = []): string[] {\n    const index = branch.indexOf(leaf);\n    if (index === -1) {\n      throw new Error('leaf not found');\n    }\n    if (branch.length === 1) {\n      return hashPath;\n    }\n    const isLeft = index % 2 === 0;\n    const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? '0x0';\n    const newHashPath = [...hashPath, neededBranch];\n    const currentBranchLevelIndex =\n      this.leaves.length === branch.length\n        ? -1\n        : this.branches.findIndex((b) => b.length === branch.length);\n    const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];\n    return this.getProof(\n      MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod),\n      nextBranch,\n      newHashPath\n    );\n  }\n}\n\n/**\n * Tests a Merkle tree path\n *\n * @param root hex-string\n * @param leaf hex-string\n * @param path hex-string array\n * @param hashMethod hash method to use, default: Pedersen\n * @returns true if the path is valid, false otherwise\n * @example\n * ```typescript\n * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n * const tree = new MerkleTree(leaves);\n * const result = proofMerklePath(tree.root, '0x3', [\n *   '0x4',\n *   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',\n *   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',\n * ]);\n * // result = true\n * ```\n */\nexport function proofMerklePath(\n  root: string,\n  leaf: string,\n  path: string[],\n  hashMethod: (a: BigNumberish, b: BigNumberish) => string = computePedersenHash\n): boolean {\n  if (path.length === 0) {\n    return root === leaf;\n  }\n  const [next, ...rest] = path;\n  return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);\n}\n","import {\n  Call,\n  DeclareSignerDetails,\n  DeployAccountSignerDetails,\n  InvocationsSignerDetails,\n  Signature,\n  TypedData,\n  V2DeclareSignerDetails,\n  V2DeployAccountSignerDetails,\n  V2InvocationsSignerDetails,\n  V3DeclareSignerDetails,\n  V3DeployAccountSignerDetails,\n  V3InvocationsSignerDetails,\n} from '../types';\nimport { ETransactionVersion2, ETransactionVersion3 } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { starkCurve } from '../utils/ec';\nimport { buf2hex } from '../utils/encode';\nimport {\n  calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash,\n} from '../utils/hash';\nimport { toHex } from '../utils/num';\nimport { intDAM } from '../utils/stark';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport { getMessageHash } from '../utils/typedData';\nimport { SignerInterface } from './interface';\n\nexport class Signer implements SignerInterface {\n  protected pk: Uint8Array | string;\n\n  constructor(pk: Uint8Array | string = starkCurve.utils.randomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n  }\n\n  public async getPubKey(): Promise<string> {\n    return starkCurve.getStarkKey(this.pk);\n  }\n\n  public async signMessage(typedData: TypedData, accountAddress: string): Promise<Signature> {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    return this.signRaw(msgHash);\n  }\n\n  public async signTransaction(\n    transactions: Call[],\n    details: InvocationsSignerDetails\n  ): Promise<Signature> {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n\n    // TODO: How to do generic union discriminator for all like this\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  public async signDeployAccountTransaction(\n    details: DeployAccountSignerDetails\n  ): Promise<Signature> {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    /*     const version = BigInt(details.version).toString(); */\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeployAccountTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  public async signDeclareTransaction(\n    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass\n    details: DeclareSignerDetails\n  ): Promise<Signature> {\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeclareTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  protected async signRaw(msgHash: string): Promise<Signature> {\n    return starkCurve.sign(msgHash, this.pk);\n  }\n}\n","import type { RecoveredSignatureType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\n\nimport {\n  ArraySignatureType,\n  Call,\n  DeclareSignerDetails,\n  DeployAccountSignerDetails,\n  InvocationsSignerDetails,\n  Signature,\n  TypedData,\n  Uint256,\n  V2DeclareSignerDetails,\n  V2DeployAccountSignerDetails,\n  V2InvocationsSignerDetails,\n  V3DeclareSignerDetails,\n  V3DeployAccountSignerDetails,\n  V3InvocationsSignerDetails,\n} from '../types';\nimport { ETransactionVersion2, ETransactionVersion3 } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { addHexPrefix, buf2hex, removeHexPrefix, sanitizeHex } from '../utils/encode';\nimport { ethRandomPrivateKey } from '../utils/eth';\nimport {\n  calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash,\n} from '../utils/hash';\nimport { toHex } from '../utils/num';\nimport { intDAM } from '../utils/stark';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport { getMessageHash } from '../utils/typedData';\nimport { bnToUint256 } from '../utils/uint256';\nimport { SignerInterface } from './interface';\n\n/**\n * Signer for accounts using Ethereum signature\n */\nexport class EthSigner implements SignerInterface {\n  protected pk: string; // hex string without 0x and with an odd number of characters\n\n  constructor(pk: Uint8Array | string = ethRandomPrivateKey()) {\n    this.pk =\n      pk instanceof Uint8Array\n        ? buf2hex(pk).padStart(64, '0')\n        : removeHexPrefix(toHex(pk)).padStart(64, '0');\n  }\n\n  /**\n   * provides the Ethereum full public key (without parity prefix)\n   * @returns an hex string : 64 first characters are Point X coordinate. 64 last characters are Point Y coordinate.\n   */\n  public async getPubKey(): Promise<string> {\n    return addHexPrefix(\n      buf2hex(secp256k1.getPublicKey(this.pk, false)).padStart(130, '0').slice(2)\n    );\n  }\n\n  public async signMessage(typedData: TypedData, accountAddress: string): Promise<Signature> {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    const signature: RecoveredSignatureType = secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n\n  public async signTransaction(\n    transactions: Call[],\n    details: InvocationsSignerDetails\n  ): Promise<Signature> {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n\n    // TODO: How to do generic union discriminator for all like this\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signTransaction version');\n    }\n    const signature: RecoveredSignatureType = secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n\n  public async signDeployAccountTransaction(\n    details: DeployAccountSignerDetails\n  ): Promise<Signature> {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    /*     const version = BigInt(details.version).toString(); */\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeployAccountTransaction version');\n    }\n    const signature: RecoveredSignatureType = secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n\n  public async signDeclareTransaction(\n    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass\n    details: DeclareSignerDetails\n  ): Promise<Signature> {\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeclareTransaction version');\n    }\n\n    const signature: RecoveredSignatureType = secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n\n  /**\n   * Serialize the signature in conformity with starknet::eth_signature::Signature\n   * @param ethSignature secp256k1 signature from Noble curves library\n   * @return an array of felts, representing a Cairo Eth Signature.\n   */\n  protected formatEthSignature(ethSignature: RecoveredSignatureType): ArraySignatureType {\n    const r: Uint256 = bnToUint256(ethSignature.r);\n    const s: Uint256 = bnToUint256(ethSignature.s);\n    return [\n      toHex(r.low),\n      toHex(r.high),\n      toHex(s.low),\n      toHex(s.high),\n      toHex(ethSignature.recovery),\n    ] as ArraySignatureType;\n  }\n}\n","/* eslint-disable no-bitwise */\nimport { BigNumberish, Uint256 } from '../types';\nimport { CairoUint256, UINT_128_MAX, UINT_256_MAX } from './cairoDataTypes/uint256';\n\n/**\n * @deprecated Legacy support Export\n */\nexport { UINT_128_MAX, UINT_256_MAX };\n\n/**\n * Convert Uint256 to bigint\n * Legacy support Export\n * @param {Uint256} uint256 Uint256 value to convert to bigint\n * @returns {bigint} BigInt representation of the input Uint256\n * @example\n * ```typescript\n * const uint256Value: Uint256 = {low: 1234567890, high: 1};\n * const result = uint256.uint256ToBN(uint256Value);\n * // result = 340282366920938463463374607433002779346n\n * ```\n */\nexport function uint256ToBN(uint256: Uint256): bigint {\n  return new CairoUint256(uint256).toBigInt();\n}\n\n/**\n * Test BigNumberish is in the range[0, 2**256-1]\n * Legacy support Export\n * @param {BigNumberish} bn value to test\n * @returns {boolean} True if the input value is in the range[0, 2**256-1], false otherwise\n * @example\n * ```typescript\n * const result = uint256.isUint256(12345n);\n * // result = true\n * const result1 = uint256.isUint256(-1);\n * // result1 = false\n * ```\n */\nexport function isUint256(bn: BigNumberish): boolean {\n  return CairoUint256.is(bn);\n}\n\n/**\n * Convert BigNumberish (string | number | bigint) to Uint256\n * Legacy support Export\n * @param {BigNumberish} bn value to convert to Uint256\n * @returns {Uint256} Uint256 object representing the BigNumberish value\n * @example\n * ```typescript\n * const result = uint256.bnToUint256(1000000000n);\n * // result = {\"low\": \"0x3b9aca00\", \"high\": \"0x0\"}\n * ```\n */\nexport function bnToUint256(bn: BigNumberish): Uint256 {\n  return new CairoUint256(bn).toUint256HexString();\n}\n","import { UDC } from '../../constants';\nimport {\n  Abi,\n  AbiEnums,\n  AbiEvents,\n  AbiStructs,\n  CairoEvent,\n  AbiEvent,\n  LegacyEvent,\n  ParsedEvent,\n  ParsedEvents,\n  RPC,\n  type CairoEventDefinition,\n  type CairoEventVariant,\n  type InvokeTransactionReceiptResponse,\n  type AbiEntry,\n} from '../../types';\nimport assert from '../assert';\nimport { isCairo1Abi } from '../calldata/cairo';\nimport responseParser from '../calldata/responseParser';\nimport { starkCurve } from '../ec';\nimport { addHexPrefix, utf8ToArray } from '../encode';\nimport { cleanHex } from '../num';\n\n/**\n * Check if an ABI entry is related to events.\n * @param {AbiEntry} object an Abi entry\n * @returns {boolean} true if this Abi Entry is related to an event\n * @example\n * ```typescript\n * // use of a transaction receipt\n * ```\n */\nexport function isAbiEvent(object: AbiEntry): boolean {\n  return object.type === 'event';\n}\n\n/**\n * Retrieves the events from the given Cairo 0 ABI.\n * @param {Abi} abi - The Cairo 0 ABI to extract events from.\n * @return {AbiEvents} - An object containing the hashes and the definition of the events.\n * @example\n * ```typescript\n * const result = events.getCairo0AbiEvents(abi0);\n * // result = {\n  '0x35ea10b06d74221d24a134672e9f776a3088ba6b9829e53b9a10abd8817a211': {\n    data: [{ name: 'admin_requester', type: 'felt' }, { name: 'new_requester', type: 'felt' }],\n    keys: [],\n    name: 'AddAdmin',\n    type: 'event'\n  }\n * ```\n */\nfunction getCairo0AbiEvents(abi: Abi) {\n  return abi\n    .filter((abiEntry) => abiEntry.type === 'event')\n    .reduce((acc, abiEntry) => {\n      const entryName = abiEntry.name;\n      const abiEntryMod = { ...abiEntry };\n      abiEntryMod.name = entryName;\n      return {\n        ...acc,\n        [addHexPrefix(starkCurve.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod,\n      };\n    }, {});\n}\n\n/**\n * Retrieves the events from the given Cairo 1 ABI.\n *\n * Is able to handle events nested in Cairo components.\n * @param {Abi} abi - The Cairo 1 ABI to extract events from.\n * @return {AbiEvents} - An object containing the hashes and the definition of the events.\n * @example\n * ```typescript\n * const result = events.getCairo1AbiEvents(abi1);\n * // result = {\n * //   '0x22ea134d4126804c60797e633195f8c9aa5fd6d1567e299f4961d0e96f373ee': \n * //    { '0x34e55c1cd55f1338241b50d352f0e91c7e4ffad0e4271d64eb347589ebdfd16': {\n * //     kind: 'struct', type: 'event',\n * //     name: 'ka::ExComponent::ex_logic_component::Mint',\n      \n * //     members: [{\n * //      name: 'spender',\n * //      type: 'core::starknet::contract_address::ContractAddress',\n * //      kind: 'key'},\n * //      { name: 'value', type: 'core::integer::u256', kind: 'data' }]},\n * // ...\n * ```\n */\nfunction getCairo1AbiEvents(abi: Abi) {\n  const abiEventsStructs = abi.filter((obj) => isAbiEvent(obj) && obj.kind === 'struct');\n  const abiEventsEnums = abi.filter((obj) => isAbiEvent(obj) && obj.kind === 'enum');\n  const abiEventsData: AbiEvents = abiEventsStructs.reduce((acc: CairoEvent, event: CairoEvent) => {\n    let nameList: string[] = [];\n    let { name } = event;\n    let flat: boolean = false;\n    const findName = (variant: CairoEventVariant) => variant.type === name;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const eventEnum = abiEventsEnums.find((eventE) => eventE.variants.some(findName));\n      if (typeof eventEnum === 'undefined') break;\n      const variant = eventEnum.variants.find(findName);\n      nameList.unshift(variant.name);\n      if (variant.kind === 'flat') flat = true;\n      name = eventEnum.name;\n    }\n    if (nameList.length === 0) {\n      throw new Error('inconsistency in ABI events definition.');\n    }\n    if (flat) nameList = [nameList[nameList.length - 1]];\n    const final = nameList.pop();\n    let result: AbiEvents = {\n      [addHexPrefix(starkCurve.keccak(utf8ToArray(final!)).toString(16))]: event,\n    };\n    while (nameList.length > 0) {\n      result = {\n        [addHexPrefix(starkCurve.keccak(utf8ToArray(nameList.pop()!)).toString(16))]: result,\n      };\n    }\n    result = { ...result };\n    return mergeAbiEvents(acc, result);\n  }, {});\n  return abiEventsData;\n}\n\n/**\n * Retrieves the events from the given ABI (from Cairo 0 or Cairo 1 contract).\n *\n * Is able to handle Cairo 1 events nested in Cairo components.\n * @param {Abi} abi - The ABI to extract events from.\n * @return {AbiEvents} - An object containing the hashes and the definition of the events.\n * @example\n * ```typescript\n * const result = events.getAbiEvents(abi);\n * // result = {\n * //   '0x22ea134d4126804c60797e633195f8c9aa5fd6d1567e299f4961d0e96f373ee': \n * //    { '0x34e55c1cd55f1338241b50d352f0e91c7e4ffad0e4271d64eb347589ebdfd16': {\n * //     kind: 'struct', type: 'event',\n * //     name: 'ka::ExComponent::ex_logic_component::Mint',\n      \n * //     members: [{\n * //      name: 'spender',\n * //      type: 'core::starknet::contract_address::ContractAddress',\n * //      kind: 'key'},\n * //      { name: 'value', type: 'core::integer::u256', kind: 'data' }]},\n * // ...\n * ```\n */\nexport function getAbiEvents(abi: Abi): AbiEvents {\n  return isCairo1Abi(abi) ? getCairo1AbiEvents(abi) : getCairo0AbiEvents(abi);\n}\n\n/**\n * Checks if a given value is an object (Object or Array)\n * @param {any} item the tested item\n * @returns {boolean}\n * @example\n * ```typescript\n * const result = events.isObject({event: \"pending\"});\n * // result = true\n * ```\n */\nexport function isObject(item: any): boolean {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n\n/**\n * internal function to deep merge 2 event description objects\n */\nfunction mergeAbiEvents(target: any, source: any): Object {\n  const output = { ...target };\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key])) {\n        if (!(key in target)) Object.assign(output, { [key]: source[key] });\n        else output[key] = mergeAbiEvents(target[key], source[key]);\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\n\n/**\n * Parse raw events and structure them into response object based on a contract structs and defined events\n * @param {RPC.Event[]} providerReceivedEvents Array of raw events\n * @param {AbiEvents} abiEvents Events defined in the abi\n * @param {AbiStructs} abiStructs Structs defined in the abi\n * @param {AbiEnums} abiEnums Enums defined in the abi\n * @returns {ParsedEvents} parsed events corresponding to the abi\n * @example\n * ```typescript\n * const abiEvents = events.getAbiEvents(sierra.abi);\n * const abiStructs =  CallData.getAbiStruct(sierra.abi);\n * const abiEnums = CallData.getAbiEnum(sierra.abi);\n * const result = events.parseEvents(myEvents, abiEvents, abiStructs, abiEnums);\n * // result = [{test::ExCh::ex_ch::Trade: {\n      maker: 7548613724711489396448209137n,\n      taker: 6435850562375218974960297344n,\n      router_maker: 0n,\n    }}]\n * ```\n */\nexport function parseEvents(\n  providerReceivedEvents: RPC.Event[],\n  abiEvents: AbiEvents,\n  abiStructs: AbiStructs,\n  abiEnums: AbiEnums\n): ParsedEvents {\n  const ret = providerReceivedEvents.flat().reduce((acc, recEvent: RPC.Event) => {\n    let abiEvent: AbiEvent | AbiEvents = abiEvents[recEvent.keys.shift() ?? 0];\n    if (!abiEvent) {\n      return acc;\n    }\n    while (!abiEvent.name) {\n      const hashName = recEvent.keys.shift();\n      assert(!!hashName, 'Not enough data in \"key\" property of this event.');\n      abiEvent = (abiEvent as AbiEvents)[hashName];\n    }\n    // Create our final event object\n    const parsedEvent: ParsedEvent = {};\n    parsedEvent[abiEvent.name as string] = {};\n    // Remove the event's name hashed from the keys array\n    const keysIter = recEvent.keys[Symbol.iterator]();\n    const dataIter = recEvent.data[Symbol.iterator]();\n\n    const abiEventKeys =\n      (abiEvent as CairoEventDefinition).members?.filter((it) => it.kind === 'key') ||\n      (abiEvent as LegacyEvent).keys;\n    const abiEventData =\n      (abiEvent as CairoEventDefinition).members?.filter((it) => it.kind === 'data') ||\n      (abiEvent as LegacyEvent).data;\n\n    abiEventKeys.forEach((key) => {\n      parsedEvent[abiEvent.name as string][key.name] = responseParser(\n        keysIter,\n        key,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name as string]\n      );\n    });\n\n    abiEventData.forEach((data) => {\n      parsedEvent[abiEvent.name as string][data.name] = responseParser(\n        dataIter,\n        data,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name as string]\n      );\n    });\n    acc.push(parsedEvent);\n    return acc;\n  }, [] as ParsedEvents);\n  return ret;\n}\n\n/**\n * Parse Transaction Receipt Event from UDC invoke transaction and\n * create DeployContractResponse compatible response with addition of the UDC Event data\n *\n * @returns DeployContractResponse | UDC Event Response data\n */\nexport function parseUDCEvent(txReceipt: InvokeTransactionReceiptResponse) {\n  if (!txReceipt.events) {\n    throw new Error('UDC emitted event is empty');\n  }\n  const event = txReceipt.events.find(\n    (it: any) => cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)\n  ) || {\n    data: [],\n  };\n  return {\n    transaction_hash: txReceipt.transaction_hash,\n    contract_address: event.data[0],\n    address: event.data[0],\n    deployer: event.data[1],\n    unique: event.data[2],\n    classHash: event.data[3],\n    calldata_len: event.data[4],\n    calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n    salt: event.data[event.data.length - 1],\n  };\n}\n","// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { SPEC } from 'starknet-types-07';\nimport { UDC, ZERO } from '../constants';\nimport { Provider, ProviderInterface } from '../provider';\nimport { Signer, SignerInterface } from '../signer';\nimport {\n  Abi,\n  AccountInvocations,\n  AccountInvocationsFactoryDetails,\n  AllowArray,\n  BigNumberish,\n  BlockIdentifier,\n  CairoVersion,\n  Call,\n  DeclareAndDeployContractPayload,\n  DeclareContractPayload,\n  DeclareContractResponse,\n  DeclareContractTransaction,\n  DeclareDeployUDCResponse,\n  DeployAccountContractPayload,\n  DeployAccountContractTransaction,\n  DeployContractResponse,\n  DeployContractUDCResponse,\n  DeployTransactionReceiptResponse,\n  EstimateFee,\n  EstimateFeeAction,\n  EstimateFeeBulk,\n  Invocation,\n  Invocations,\n  InvocationsSignerDetails,\n  InvokeFunctionResponse,\n  MultiDeployContractResponse,\n  Nonce,\n  ProviderOptions,\n  Signature,\n  SimulateTransactionDetails,\n  SimulateTransactionResponse,\n  TransactionType,\n  TypedData,\n  UniversalDeployerContractPayload,\n  UniversalDetails,\n} from '../types';\nimport { ETransactionVersion, ETransactionVersion3, ResourceBounds } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { extractContractHashes, isSierra } from '../utils/contract';\nimport { parseUDCEvent } from '../utils/events';\nimport { calculateContractAddressFromHash } from '../utils/hash';\nimport { toBigInt, toCairoBool } from '../utils/num';\nimport { parseContract } from '../utils/provider';\nimport { isString } from '../utils/shortString';\nimport {\n  estimateFeeToBounds,\n  formatSignature,\n  reduceV2,\n  toFeeVersion,\n  toTransactionVersion,\n  v3Details,\n} from '../utils/stark';\nimport { buildUDCCall, getExecuteCalldata } from '../utils/transaction';\nimport { getMessageHash } from '../utils/typedData';\nimport { AccountInterface } from './interface';\n\nexport class Account extends Provider implements AccountInterface {\n  public signer: SignerInterface;\n\n  public address: string;\n\n  public cairoVersion: CairoVersion;\n\n  readonly transactionVersion: typeof ETransactionVersion.V2 | typeof ETransactionVersion.V3;\n\n  constructor(\n    providerOrOptions: ProviderOptions | ProviderInterface,\n    address: string,\n    pkOrSigner: Uint8Array | string | SignerInterface,\n    cairoVersion?: CairoVersion,\n    transactionVersion:\n      | typeof ETransactionVersion.V2\n      | typeof ETransactionVersion.V3 = ETransactionVersion.V2 // TODO: Discuss this, set to v2 for backward compatibility\n  ) {\n    super(providerOrOptions);\n    this.address = address.toLowerCase();\n    this.signer =\n      isString(pkOrSigner) || pkOrSigner instanceof Uint8Array\n        ? new Signer(pkOrSigner)\n        : pkOrSigner;\n\n    if (cairoVersion) {\n      this.cairoVersion = cairoVersion.toString() as CairoVersion;\n    }\n    this.transactionVersion = transactionVersion;\n  }\n\n  // provided version or contract based preferred transactionVersion\n  protected getPreferredVersion(type12: ETransactionVersion, type3: ETransactionVersion) {\n    if (this.transactionVersion === ETransactionVersion.V3) return type3;\n    if (this.transactionVersion === ETransactionVersion.V2) return type12;\n\n    return ETransactionVersion.V3;\n  }\n\n  public async getNonce(blockIdentifier?: BlockIdentifier): Promise<Nonce> {\n    return super.getNonceForAddress(this.address, blockIdentifier);\n  }\n\n  protected async getNonceSafe(nonce?: BigNumberish) {\n    // Patch DEPLOY_ACCOUNT: RPC getNonce for non-existing address will result in error\n    try {\n      return toBigInt(nonce ?? (await this.getNonce()));\n    } catch (error) {\n      return 0n;\n    }\n  }\n\n  /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor.\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */\n  public async getCairoVersion(classHash?: string) {\n    if (!this.cairoVersion) {\n      const { cairo } = classHash\n        ? await super.getContractVersion(undefined, classHash)\n        : await super.getContractVersion(this.address);\n      this.cairoVersion = cairo;\n    }\n    return this.cairoVersion;\n  }\n\n  public async estimateFee(\n    calls: AllowArray<Call>,\n    estimateFeeDetails: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    return this.estimateInvokeFee(calls, estimateFeeDetails);\n  }\n\n  public async estimateInvokeFee(\n    calls: AllowArray<Call>,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    const {\n      nonce: providedNonce,\n      blockIdentifier,\n      version: providedVersion,\n      skipValidate = true,\n    } = details;\n\n    const transactions = Array.isArray(calls) ? calls : [calls];\n    const nonce = toBigInt(providedNonce ?? (await this.getNonce()));\n    const version = toTransactionVersion(\n      this.getPreferredVersion(ETransactionVersion.F1, ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n\n    const signerDetails: InvocationsSignerDetails = {\n      ...v3Details(details),\n      walletAddress: this.address,\n      nonce,\n      maxFee: ZERO,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion(),\n      skipValidate,\n    };\n\n    const invocation = await this.buildInvocation(transactions, signerDetails);\n    return super.getInvokeEstimateFee(\n      { ...invocation },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n\n  public async estimateDeclareFee(\n    payload: DeclareContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    const {\n      blockIdentifier,\n      nonce: providedNonce,\n      version: providedVersion,\n      skipValidate = true,\n    } = details;\n    const nonce = toBigInt(providedNonce ?? (await this.getNonce()));\n    const version = toTransactionVersion(\n      !isSierra(payload.contract)\n        ? ETransactionVersion.F1\n        : this.getPreferredVersion(ETransactionVersion.F2, ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n\n    const declareContractTransaction = await this.buildDeclarePayload(payload, {\n      ...v3Details(details),\n      nonce,\n      chainId,\n      version,\n      walletAddress: this.address,\n      maxFee: ZERO,\n      cairoVersion: undefined, // unused parameter\n      skipValidate,\n    });\n\n    return super.getDeclareEstimateFee(\n      declareContractTransaction,\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n\n  public async estimateAccountDeployFee(\n    {\n      classHash,\n      addressSalt = 0,\n      constructorCalldata = [],\n      contractAddress,\n    }: DeployAccountContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    const { blockIdentifier, version: providedVersion, skipValidate = true } = details;\n    const version = toTransactionVersion(\n      this.getPreferredVersion(ETransactionVersion.F1, ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    ); // TODO: Can Cairo0 be deployed with F3 ?\n    const nonce = ZERO; // DEPLOY_ACCOUNT transaction will have a nonce zero as it is the first transaction in the account\n    const chainId = await this.getChainId();\n\n    const payload = await this.buildAccountDeployPayload(\n      { classHash, addressSalt, constructorCalldata, contractAddress },\n      {\n        ...v3Details(details),\n        nonce,\n        chainId,\n        version,\n        walletAddress: this.address, // unused parameter\n        maxFee: ZERO,\n        cairoVersion: undefined, // unused parameter,\n        skipValidate,\n      }\n    );\n\n    return super.getDeployAccountEstimateFee(\n      { ...payload },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n\n  public async estimateDeployFee(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    const calls = this.buildUDCContractPayload(payload);\n    return this.estimateInvokeFee(calls, details);\n  }\n\n  public async estimateFeeBulk(\n    invocations: Invocations,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFeeBulk> {\n    const { nonce, blockIdentifier, version, skipValidate } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        ETransactionVersion.F1, // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(ETransactionVersion.F2, ETransactionVersion.F3),\n          version\n        ), // sierra\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate,\n    });\n\n    return super.getEstimateFeeBulk(accountInvocations, {\n      blockIdentifier,\n      skipValidate,\n    });\n  }\n\n  public async simulateTransaction(\n    invocations: Invocations,\n    details: SimulateTransactionDetails = {}\n  ): Promise<SimulateTransactionResponse> {\n    const { nonce, blockIdentifier, skipValidate = true, skipExecute, version } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        ETransactionVersion.V1, // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(ETransactionVersion.V2, ETransactionVersion.V3),\n          version\n        ),\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate,\n    });\n\n    return super.getSimulateTransaction(accountInvocations, {\n      blockIdentifier,\n      skipValidate,\n      skipExecute,\n    });\n  }\n\n  public async execute(\n    transactions: AllowArray<Call>,\n    transactionsDetail?: UniversalDetails\n  ): Promise<InvokeFunctionResponse>;\n  public async execute(\n    transactions: AllowArray<Call>,\n    abis?: Abi[],\n    transactionsDetail?: UniversalDetails\n  ): Promise<InvokeFunctionResponse>;\n  public async execute(\n    transactions: AllowArray<Call>,\n    arg2?: Abi[] | UniversalDetails,\n    transactionsDetail: UniversalDetails = {}\n  ): Promise<InvokeFunctionResponse> {\n    const details = arg2 === undefined || Array.isArray(arg2) ? transactionsDetail : arg2;\n    const calls = Array.isArray(transactions) ? transactions : [transactions];\n    const nonce = toBigInt(details.nonce ?? (await this.getNonce()));\n    const version = toTransactionVersion(\n      this.getPreferredVersion(ETransactionVersion.V1, ETransactionVersion.V3), // TODO: does this depend on cairo version ?\n      details.version\n    );\n\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      { type: TransactionType.INVOKE, payload: transactions },\n      {\n        ...details,\n        version,\n      }\n    );\n\n    const chainId = await this.getChainId();\n\n    const signerDetails: InvocationsSignerDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      walletAddress: this.address,\n      nonce,\n      maxFee: estimate.maxFee,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion(),\n    };\n\n    const signature = await this.signer.signTransaction(calls, signerDetails);\n\n    const calldata = getExecuteCalldata(calls, await this.getCairoVersion());\n\n    return this.invokeFunction(\n      { contractAddress: this.address, calldata, signature },\n      {\n        ...v3Details(details),\n        resourceBounds: estimate.resourceBounds,\n        nonce,\n        maxFee: estimate.maxFee,\n        version,\n      }\n    );\n  }\n\n  /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */\n  public async declareIfNot(\n    payload: DeclareContractPayload,\n    transactionsDetail: UniversalDetails = {}\n  ): Promise<DeclareContractResponse> {\n    const declareContractPayload = extractContractHashes(payload);\n    try {\n      await this.getClassByHash(declareContractPayload.classHash);\n    } catch (error) {\n      return this.declare(payload, transactionsDetail);\n    }\n    return {\n      transaction_hash: '',\n      class_hash: declareContractPayload.classHash,\n    };\n  }\n\n  public async declare(\n    payload: DeclareContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<DeclareContractResponse> {\n    const declareContractPayload = extractContractHashes(payload);\n    const { nonce, version: providedVersion } = details;\n    const version = toTransactionVersion(\n      !isSierra(payload.contract)\n        ? ETransactionVersion.V1\n        : this.getPreferredVersion(ETransactionVersion.V2, ETransactionVersion.V3),\n      providedVersion\n    );\n\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: TransactionType.DECLARE,\n        payload: declareContractPayload,\n      },\n      {\n        ...details,\n        version,\n      }\n    );\n\n    const declareDetails: InvocationsSignerDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      nonce: toBigInt(nonce ?? (await this.getNonce())),\n      version,\n      chainId: await this.getChainId(),\n      walletAddress: this.address,\n      cairoVersion: undefined,\n    };\n\n    const declareContractTransaction = await this.buildDeclarePayload(\n      declareContractPayload,\n      declareDetails\n    );\n\n    return this.declareContract(declareContractTransaction, declareDetails);\n  }\n\n  public async deploy(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details: UniversalDetails = {}\n  ): Promise<MultiDeployContractResponse> {\n    const { calls, addresses } = buildUDCCall(payload, this.address);\n    const invokeResponse = await this.execute(calls, undefined, details);\n\n    return {\n      ...invokeResponse,\n      contract_address: addresses,\n    };\n  }\n\n  public async deployContract(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details: UniversalDetails = {}\n  ): Promise<DeployContractUDCResponse> {\n    const deployTx = await this.deploy(payload, details);\n    const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n    return parseUDCEvent(txReceipt as unknown as DeployTransactionReceiptResponse);\n  }\n\n  public async declareAndDeploy(\n    payload: DeclareAndDeployContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<DeclareDeployUDCResponse> {\n    const { constructorCalldata, salt, unique } = payload;\n    let declare = await this.declareIfNot(payload, details);\n    if (declare.transaction_hash !== '') {\n      const tx = await this.waitForTransaction(declare.transaction_hash);\n      declare = { ...declare, ...tx };\n    }\n    const deploy = await this.deployContract(\n      { classHash: declare.class_hash, salt, unique, constructorCalldata },\n      details\n    );\n    return { declare: { ...declare }, deploy };\n  }\n\n  public deploySelf = this.deployAccount;\n\n  public async deployAccount(\n    {\n      classHash,\n      constructorCalldata = [],\n      addressSalt = 0,\n      contractAddress: providedContractAddress,\n    }: DeployAccountContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<DeployContractResponse> {\n    const version = toTransactionVersion(\n      this.getPreferredVersion(ETransactionVersion.V1, ETransactionVersion.V3),\n      details.version\n    );\n    const nonce = ZERO; // DEPLOY_ACCOUNT transaction will have a nonce zero as it is the first transaction in the account\n    const chainId = await this.getChainId();\n\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress =\n      providedContractAddress ??\n      calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: TransactionType.DEPLOY_ACCOUNT,\n        payload: {\n          classHash,\n          constructorCalldata: compiledCalldata,\n          addressSalt,\n          contractAddress,\n        },\n      },\n      details\n    );\n\n    const signature = await this.signer.signDeployAccountTransaction({\n      ...v3Details(details),\n      classHash,\n      constructorCalldata: compiledCalldata,\n      contractAddress,\n      addressSalt,\n      chainId,\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      version,\n      nonce,\n    });\n\n    return this.deployAccountContract(\n      { classHash, addressSalt, constructorCalldata, signature },\n      {\n        ...v3Details(details),\n        nonce,\n        resourceBounds: estimate.resourceBounds,\n        maxFee: estimate.maxFee,\n        version,\n      }\n    );\n  }\n\n  public async signMessage(typedData: TypedData): Promise<Signature> {\n    return this.signer.signMessage(typedData, this.address);\n  }\n\n  public async hashMessage(typedData: TypedData): Promise<string> {\n    return getMessageHash(typedData, this.address);\n  }\n\n  public async verifyMessageHash(\n    hash: BigNumberish,\n    signature: Signature,\n    signatureVerificationFunctionName?: string,\n    signatureVerificationResponse?: { okResponse: string[]; nokResponse: string[]; error: string[] }\n  ): Promise<boolean> {\n    // HOTFIX: Accounts should conform to SNIP-6\n    // (https://github.com/starknet-io/SNIPs/blob/f6998f779ee2157d5e1dea36042b08062093b3c5/SNIPS/snip-6.md?plain=1#L61),\n    // but they don't always conform. Also, the SNIP doesn't standardize the response if the signature isn't valid.\n    const knownSigVerificationFName = signatureVerificationFunctionName\n      ? [signatureVerificationFunctionName]\n      : ['isValidSignature', 'is_valid_signature'];\n    const knownSignatureResponse = signatureVerificationResponse || {\n      okResponse: [\n        // any non-nok response is true\n      ],\n      nokResponse: [\n        '0x0', // Devnet\n        '0x00', // OpenZeppelin 0.7.0 to 0.9.0 invalid signature\n      ],\n      error: [\n        'argent/invalid-signature', // ArgentX 0.3.0 to 0.3.1\n        'is invalid, with respect to the public key', // OpenZeppelin until 0.6.1, Braavos 0.0.11\n        'INVALID_SIG', // Braavos 1.0.0\n      ],\n    };\n    let error: any;\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const SigVerificationFName of knownSigVerificationFName) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        const resp = await this.callContract({\n          contractAddress: this.address,\n          entrypoint: SigVerificationFName,\n          calldata: CallData.compile({\n            hash: toBigInt(hash).toString(),\n            signature: formatSignature(signature),\n          }),\n        });\n        // Response NOK Signature\n        if (knownSignatureResponse.nokResponse.includes(resp[0].toString())) {\n          return false;\n        }\n        // Response OK Signature\n        // Empty okResponse assume all non-nok responses are valid signatures\n        // OpenZeppelin 0.7.0 to 0.9.0, ArgentX 0.3.0 to 0.3.1 & Braavos Cairo 0.0.11 to 1.0.0 valid signature\n        if (\n          knownSignatureResponse.okResponse.length === 0 ||\n          knownSignatureResponse.okResponse.includes(resp[0].toString())\n        ) {\n          return true;\n        }\n        throw Error('signatureVerificationResponse Error: response is not part of known responses');\n      } catch (err) {\n        // Known NOK Errors\n        if (\n          knownSignatureResponse.error.some((errMessage) =>\n            (err as Error).message.includes(errMessage)\n          )\n        ) {\n          return false;\n        }\n        // Unknown Error\n        error = err;\n      }\n    }\n\n    throw Error(`Signature verification Error: ${error}`);\n  }\n\n  public async verifyMessage(\n    typedData: TypedData,\n    signature: Signature,\n    signatureVerificationFunctionName?: string,\n    signatureVerificationResponse?: { okResponse: string[]; nokResponse: string[]; error: string[] }\n  ): Promise<boolean> {\n    const hash = await this.hashMessage(typedData);\n    return this.verifyMessageHash(\n      hash,\n      signature,\n      signatureVerificationFunctionName,\n      signatureVerificationResponse\n    );\n  }\n\n  /*\n   * Support methods\n   */\n\n  protected async getUniversalSuggestedFee(\n    version: ETransactionVersion,\n    { type, payload }: EstimateFeeAction,\n    details: UniversalDetails\n  ) {\n    let maxFee: BigNumberish = 0;\n    let resourceBounds: ResourceBounds = estimateFeeToBounds(ZERO);\n    if (version === ETransactionVersion.V3) {\n      resourceBounds =\n        details.resourceBounds ??\n        (await this.getSuggestedFee({ type, payload } as any, details)).resourceBounds;\n    } else {\n      maxFee =\n        details.maxFee ??\n        (await this.getSuggestedFee({ type, payload } as any, details)).suggestedMaxFee;\n    }\n\n    return {\n      maxFee,\n      resourceBounds,\n    };\n  }\n\n  public async getSuggestedFee({ type, payload }: EstimateFeeAction, details: UniversalDetails) {\n    let feeEstimate: EstimateFee;\n\n    switch (type) {\n      case TransactionType.INVOKE:\n        feeEstimate = await this.estimateInvokeFee(payload, details);\n        break;\n\n      case TransactionType.DECLARE:\n        feeEstimate = await this.estimateDeclareFee(payload, details);\n        break;\n\n      case TransactionType.DEPLOY_ACCOUNT:\n        feeEstimate = await this.estimateAccountDeployFee(payload, details);\n        break;\n\n      case TransactionType.DEPLOY:\n        feeEstimate = await this.estimateDeployFee(payload, details);\n        break;\n\n      default:\n        feeEstimate = {\n          gas_consumed: 0n,\n          gas_price: 0n,\n          overall_fee: ZERO,\n          unit: 'FRI',\n          suggestedMaxFee: ZERO,\n          resourceBounds: estimateFeeToBounds(ZERO),\n          data_gas_consumed: 0n,\n          data_gas_price: 0n,\n        };\n        break;\n    }\n\n    return feeEstimate;\n  }\n\n  public async buildInvocation(\n    call: Array<Call>,\n    details: InvocationsSignerDetails\n  ): Promise<Invocation> {\n    const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n    const signature = !details.skipValidate ? await this.signer.signTransaction(call, details) : [];\n\n    return {\n      ...v3Details(details),\n      contractAddress: this.address,\n      calldata,\n      signature,\n    };\n  }\n\n  public async buildDeclarePayload(\n    payload: DeclareContractPayload,\n    details: InvocationsSignerDetails\n  ): Promise<DeclareContractTransaction> {\n    const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n    const compressedCompiledContract = parseContract(contract);\n\n    if (\n      typeof compiledClassHash === 'undefined' &&\n      (details.version === ETransactionVersion3.F3 || details.version === ETransactionVersion3.V3)\n    ) {\n      throw Error('V3 Transaction work with Cairo1 Contracts and require compiledClassHash');\n    }\n\n    const signature = !details.skipValidate\n      ? await this.signer.signDeclareTransaction({\n          ...details,\n          ...v3Details(details),\n          classHash,\n          compiledClassHash: compiledClassHash as string, // TODO: TS, cast because optional for v2 and required for v3, thrown if not present\n          senderAddress: details.walletAddress,\n        })\n      : [];\n\n    return {\n      senderAddress: details.walletAddress,\n      signature,\n      contract: compressedCompiledContract,\n      compiledClassHash,\n    };\n  }\n\n  public async buildAccountDeployPayload(\n    {\n      classHash,\n      addressSalt = 0,\n      constructorCalldata = [],\n      contractAddress: providedContractAddress,\n    }: DeployAccountContractPayload,\n    details: InvocationsSignerDetails\n  ): Promise<DeployAccountContractTransaction> {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress =\n      providedContractAddress ??\n      calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n\n    const signature = !details.skipValidate\n      ? await this.signer.signDeployAccountTransaction({\n          ...details,\n          ...v3Details(details),\n          classHash,\n          contractAddress,\n          addressSalt,\n          constructorCalldata: compiledCalldata,\n        })\n      : [];\n\n    return {\n      ...v3Details(details),\n      classHash,\n      addressSalt,\n      constructorCalldata: compiledCalldata,\n      signature,\n    };\n  }\n\n  public buildUDCContractPayload(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[]\n  ): Call[] {\n    const calls = [].concat(payload as []).map((it) => {\n      const {\n        classHash,\n        salt = '0',\n        unique = true,\n        constructorCalldata = [],\n      } = it as UniversalDeployerContractPayload;\n      const compiledConstructorCallData = CallData.compile(constructorCalldata);\n\n      return {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          salt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData,\n        ],\n      };\n    });\n    return calls;\n  }\n\n  public async accountInvocationsFactory(\n    invocations: Invocations,\n    details: AccountInvocationsFactoryDetails\n  ) {\n    const { nonce, blockIdentifier, skipValidate = true } = details;\n    const safeNonce = await this.getNonceSafe(nonce);\n    const chainId = await this.getChainId();\n    const versions = details.versions.map((it) => toTransactionVersion(it));\n\n    // BULK ACTION FROM NEW ACCOUNT START WITH DEPLOY_ACCOUNT\n    const tx0Payload: any = 'payload' in invocations[0] ? invocations[0].payload : invocations[0];\n    const cairoVersion =\n      invocations[0].type === TransactionType.DEPLOY_ACCOUNT\n        ? await this.getCairoVersion(tx0Payload.classHash)\n        : await this.getCairoVersion();\n\n    return Promise.all(\n      ([] as Invocations).concat(invocations).map(async (transaction, index: number) => {\n        const txPayload: any = 'payload' in transaction ? transaction.payload : transaction;\n        const signerDetails = {\n          ...v3Details(details),\n          walletAddress: this.address,\n          nonce: toBigInt(Number(safeNonce) + index),\n          maxFee: ZERO,\n          chainId,\n          cairoVersion,\n          version: '' as ETransactionVersion,\n          skipValidate,\n        };\n        const common = {\n          type: transaction.type,\n          nonce: toBigInt(Number(safeNonce) + index),\n          blockIdentifier,\n          version: '' as ETransactionVersion,\n        };\n\n        if (transaction.type === TransactionType.INVOKE) {\n          // 1 or 3\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n\n          const payload = await this.buildInvocation(\n            ([] as Call[]).concat(txPayload),\n            signerDetails\n          );\n          return {\n            ...common,\n            ...payload,\n          };\n        }\n        if (transaction.type === TransactionType.DEPLOY) {\n          // 1 or 3\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n\n          const calls = this.buildUDCContractPayload(txPayload);\n          const payload = await this.buildInvocation(calls, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            type: TransactionType.INVOKE,\n          };\n        }\n        if (transaction.type === TransactionType.DECLARE) {\n          // 1 (Cairo0) or 2 or 3\n          const versionX = !isSierra(txPayload.contract) ? versions[0] : versions[1];\n          signerDetails.version = versionX;\n          common.version = versionX;\n\n          const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload,\n          };\n        }\n        if (transaction.type === TransactionType.DEPLOY_ACCOUNT) {\n          // 1 or 3\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n\n          const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload,\n          };\n        }\n        throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n      })\n    ) as Promise<AccountInvocations>;\n  }\n\n  public async getStarkName(\n    address: BigNumberish = this.address, // default to the wallet address\n    StarknetIdContract?: string\n  ): Promise<string> {\n    return super.getStarkName(address, StarknetIdContract);\n  }\n}\n","import { ProviderInterface } from '../provider';\nimport { SignerInterface } from '../signer';\nimport {\n  Abi,\n  AllowArray,\n  BigNumberish,\n  BlockIdentifier,\n  CairoVersion,\n  Call,\n  DeclareAndDeployContractPayload,\n  DeclareContractPayload,\n  DeclareContractResponse,\n  DeclareDeployUDCResponse,\n  DeployAccountContractPayload,\n  DeployContractResponse,\n  DeployContractUDCResponse,\n  EstimateFee,\n  EstimateFeeAction,\n  EstimateFeeDetails,\n  EstimateFeeResponse,\n  EstimateFeeResponseBulk,\n  Invocations,\n  InvocationsDetails,\n  InvokeFunctionResponse,\n  MultiDeployContractResponse,\n  Nonce,\n  Signature,\n  SimulateTransactionDetails,\n  SimulateTransactionResponse,\n  TypedData,\n  UniversalDeployerContractPayload,\n} from '../types';\n\nexport abstract class AccountInterface extends ProviderInterface {\n  public abstract address: string;\n\n  public abstract signer: SignerInterface;\n\n  public abstract cairoVersion: CairoVersion;\n\n  /**\n   * Estimate Fee for executing an INVOKE transaction on starknet\n   *\n   * @param calls the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata? - (defaults to []) the calldata\n   *\n   * @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce? = 0\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   *\n   * @returns response from estimate_fee\n   */\n  public abstract estimateInvokeFee(\n    calls: AllowArray<Call>,\n    estimateFeeDetails?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimate Fee for executing a DECLARE transaction on starknet\n   *\n   * @param contractPayload the payload object containing:\n   * - contract - the compiled contract to be declared\n   * - casm? - compiled cairo assembly. Cairo1(casm or compiledClassHash are required)\n   * - classHash? - the class hash of the compiled contract. Precalculate for faster execution.\n   * - compiledClassHash?: class hash of the cairo assembly. Cairo1(casm or compiledClassHash are required)\n   *\n   * @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce? = 0\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   *\n   * @returns response from estimate_fee\n   */\n  public abstract estimateDeclareFee(\n    contractPayload: DeclareContractPayload,\n    estimateFeeDetails?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimate Fee for executing a DEPLOY_ACCOUNT transaction on starknet\n   *\n   * @param contractPayload -\n   * - classHash - the class hash of the compiled contract.\n   * - constructorCalldata? - constructor data;\n   * - contractAddress? - future account contract address. Precalculate for faster execution.\n   * - addressSalt? - salt used for calculation of the contractAddress. Required if contractAddress is provided.\n   *\n   * @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce? = 0\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   *\n   * @returns response from estimate_fee\n   */\n  public abstract estimateAccountDeployFee(\n    contractPayload: DeployAccountContractPayload,\n    estimateFeeDetails?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimate Fee for executing a UDC DEPLOY transaction on starknet\n   * This is different from the normal DEPLOY transaction as it goes through the Universal Deployer Contract (UDC)\n   \n  * @param deployContractPayload array or singular\n   * - classHash: computed class hash of compiled contract\n   * - salt: address salt\n   * - unique: bool if true ensure unique salt\n   * - constructorCalldata: constructor calldata\n   * \n   * @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce?\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   */\n  public abstract estimateDeployFee(\n    deployContractPayload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    estimateFeeDetails?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimate Fee for executing a list of transactions on starknet\n   * Contract must be deployed for fee estimation to be possible\n   *\n   * @param invocations array of transaction object containing :\n   * - type - the type of transaction : 'DECLARE' | (multi)'DEPLOY' | (multi)'INVOKE_FUNCTION' | 'DEPLOY_ACCOUNT'\n   * - payload - the payload of the transaction\n   *\n   *  @param details -\n   * - blockIdentifier?\n   * - nonce?\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   *\n   * @returns response from estimate_fee\n   */\n  public abstract estimateFeeBulk(\n    invocations: Invocations,\n    details?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponseBulk>;\n\n  /**\n   * Gets Suggested Max Fee based on the transaction type\n   *\n   * @param  {EstimateFeeAction} estimateFeeAction\n   * @param  {EstimateFeeDetails} details\n   * @returns EstimateFee (...response, resourceBounds, suggestedMaxFee)\n   */\n  public abstract getSuggestedFee(\n    estimateFeeAction: EstimateFeeAction,\n    details: EstimateFeeDetails\n  ): Promise<EstimateFee>;\n\n  /**\n   * Simulates an array of transaction and returns an array of transaction trace and estimated fee.\n   *\n   * @param invocations Invocations containing:\n   * - type - transaction type: DECLARE, (multi)DEPLOY, DEPLOY_ACCOUNT, (multi)INVOKE_FUNCTION\n   * @param details SimulateTransactionDetails\n   *\n   * @returns response from simulate_transaction\n   */\n  public abstract simulateTransaction(\n    invocations: Invocations,\n    details?: SimulateTransactionDetails\n  ): Promise<SimulateTransactionResponse>;\n\n  /**\n   * Invoke execute function in account contract\n   *\n   * @param transactions the invocation object or an array of them, containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param {InvocationsDetails} transactionsDetail Additional optional parameters for the transaction\n   *\n   * @returns response from addTransaction\n   */\n  public abstract execute(\n    transactions: AllowArray<Call>,\n    transactionsDetail?: InvocationsDetails\n  ): Promise<InvokeFunctionResponse>;\n  /**\n   * @deprecated\n   * @param transactions the invocation object or an array of them, containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param abis (optional) the abi of the contract for better displaying\n   * @param {InvocationsDetails} transactionsDetail Additional optional parameters for the transaction\n   * * @returns response from addTransaction\n   */\n  public abstract execute(\n    transactions: AllowArray<Call>,\n    abis?: Abi[],\n    transactionsDetail?: InvocationsDetails\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Declares a given compiled contract (json) to starknet\n   *\n   * @param contractPayload transaction payload to be deployed containing:\n   * - contract: compiled contract code\n   * - (optional) classHash: computed class hash of compiled contract. Pre-compute it for faster execution.\n   * - (required for Cairo1 without compiledClassHash) casm: CompiledContract | string;\n   * - (optional for Cairo1 with casm) compiledClassHash: compiled class hash from casm. Pre-compute it for faster execution.\n   * @param transactionsDetail - InvocationsDetails\n   *\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract declare(\n    contractPayload: DeclareContractPayload,\n    transactionsDetail?: InvocationsDetails\n  ): Promise<DeclareContractResponse>;\n\n  /**\n   * Deploys a declared contract to starknet - using Universal Deployer Contract (UDC)\n   * support multicall\n   *\n   * @param payload -\n   * - classHash: computed class hash of compiled contract\n   * - [constructorCalldata] contract constructor calldata\n   * - [salt=pseudorandom] deploy address salt\n   * - [unique=true] ensure unique salt\n   * @param details - InvocationsDetails\n   *\n   * @returns\n   * - contract_address[]\n   * - transaction_hash\n   */\n  public abstract deploy(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details?: InvocationsDetails\n  ): Promise<MultiDeployContractResponse>;\n\n  /**\n   * Simplify deploy simulating old DeployContract with same response + UDC specific response\n   * Internal wait for L2 transaction, support multicall\n   *\n   * @param payload -\n   * - classHash: computed class hash of compiled contract\n   * - [constructorCalldata] contract constructor calldata\n   * - [salt=pseudorandom] deploy address salt\n   * - [unique=true] ensure unique salt\n   * @param details - InvocationsDetails\n   *\n   * @returns\n   *  - contract_address\n   *  - transaction_hash\n   *  - address\n   *  - deployer\n   *  - unique\n   *  - classHash\n   *  - calldata_len\n   *  - calldata\n   *  - salt\n   */\n  public abstract deployContract(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details?: InvocationsDetails\n  ): Promise<DeployContractUDCResponse>;\n\n  /**\n   * Declares and Deploy a given compiled contract (json) to starknet using UDC\n   * Internal wait for L2 transaction, do not support multicall\n   * Method will pass even if contract is already declared (internal using DeclareIfNot)\n   *\n   * @param payload\n   * - contract: compiled contract code\n   * - [casm=cairo1]: CairoAssembly | undefined;\n   * - [compiledClassHash]: string | undefined;\n   * - [classHash]: computed class hash of compiled contract\n   * - [constructorCalldata] contract constructor calldata\n   * - [salt=pseudorandom] deploy address salt\n   * - [unique=true] ensure unique salt\n   * @param details - InvocationsDetails\n   *\n   * @returns\n   * - declare\n   *    - transaction_hash\n   * - deploy\n   *    - contract_address\n   *    - transaction_hash\n   *    - address\n   *    - deployer\n   *    - unique\n   *    - classHash\n   *    - calldata_len\n   *    - calldata\n   *    - salt\n   */\n  public abstract declareAndDeploy(\n    payload: DeclareAndDeployContractPayload,\n    details?: InvocationsDetails\n  ): Promise<DeclareDeployUDCResponse>;\n\n  /**\n   * Deploy the account on Starknet\n   *\n   * @param contractPayload transaction payload to be deployed containing:\n   * - classHash: computed class hash of compiled contract\n   * - optional constructor calldata\n   * - optional address salt\n   * - optional contractAddress\n   * @param transactionsDetail - InvocationsDetails\n   *\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract deployAccount(\n    contractPayload: DeployAccountContractPayload,\n    transactionsDetail?: InvocationsDetails\n  ): Promise<DeployContractResponse>;\n\n  /**\n   * Signs a TypedData object for off-chain usage with the Starknet private key and returns the signature\n   * This adds a message prefix so it can't be interchanged with transactions\n   *\n   * @param typedData - TypedData object to be signed\n   * @returns the signature of the TypedData object\n   * @throws {Error} if typedData is not a valid TypedData\n   */\n  public abstract signMessage(typedData: TypedData): Promise<Signature>;\n\n  /**\n   * Hash a TypedData object with Pedersen hash and return the hash\n   * This adds a message prefix so it can't be interchanged with transactions\n   *\n   * @param typedData - TypedData object to be hashed\n   * @returns the hash of the TypedData object\n   * @throws {Error} if typedData is not a valid TypedData\n   */\n  public abstract hashMessage(typedData: TypedData): Promise<string>;\n\n  /**\n   * Verify a signature of a TypedData object\n   *\n   * @param typedData - TypedData object to be verified\n   * @param signature - signature of the TypedData object\n   * @returns true if the signature is valid, false otherwise\n   * @throws {Error} if typedData is not a valid TypedData or the signature is not a valid signature\n   */\n  public abstract verifyMessage(typedData: TypedData, signature: Signature): Promise<boolean>;\n\n  /**\n   * Verify a signature of a given hash\n   * @warning This method is not recommended, use verifyMessage instead\n   *\n   * @param hash - hash to be verified\n   * @param signature - signature of the hash\n   * @returns true if the signature is valid, false otherwise\n   * @throws {Error} if the signature is not a valid signature\n   */\n  public abstract verifyMessageHash(hash: BigNumberish, signature: Signature): Promise<boolean>;\n\n  /**\n   * Gets the nonce of the account with respect to a specific block\n   *\n   * @param  {BlockIdentifier} blockIdentifier - optional blockIdentifier. Defaults to 'pending'\n   * @returns nonce of the account\n   */\n  public abstract getNonce(blockIdentifier?: BlockIdentifier): Promise<Nonce>;\n}\n","import {\n  type WatchAssetParameters,\n  type AccountChangeEventHandler,\n  type AddDeclareTransactionParameters,\n  type AddInvokeTransactionParameters,\n  type AddStarknetChainParameters,\n  type NetworkChangeEventHandler,\n  type ChainId,\n  type StarknetWindowObject,\n  type TypedData,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  type SPEC,\n} from 'starknet-types-07';\n\n/**\n * Request Permission for wallet account, return addresses that are allowed by user\n * @param {boolean} [silent_mode=false] false: request user interaction allowance. true: return only pre-allowed\n * @returns allowed accounts addresses\n */\nexport function requestAccounts(swo: StarknetWindowObject, silent_mode = false) {\n  return swo.request({\n    type: 'wallet_requestAccounts',\n    params: {\n      silent_mode,\n    },\n  });\n}\n\n/**\n * Request Permission for wallet account\n * @returns allowed accounts addresses\n */\nexport function getPermissions(swo: StarknetWindowObject) {\n  return swo.request({ type: 'wallet_getPermissions' });\n}\n\n/**\n * Request adding ERC20 Token to Wallet List\n * @param asset WatchAssetParameters\n * @returns boolean\n */\nexport function watchAsset(swo: StarknetWindowObject, asset: WatchAssetParameters) {\n  return swo.request({\n    type: 'wallet_watchAsset',\n    params: asset,\n  });\n}\n\n/**\n * Request adding custom Starknet chain\n * @param chain AddStarknetChainParameters\n * @returns boolean\n */\nexport function addStarknetChain(swo: StarknetWindowObject, chain: AddStarknetChainParameters) {\n  // TODO: This should set custom RPC endpoint ?\n  return swo.request({\n    type: 'wallet_addStarknetChain',\n    params: chain,\n  });\n}\n\n/**\n * Request Wallet Network change\n * @param chainId StarknetChainId\n * @returns boolean\n */\nexport function switchStarknetChain(swo: StarknetWindowObject, chainId: ChainId) {\n  return swo.request({\n    type: 'wallet_switchStarknetChain',\n    params: {\n      chainId,\n    },\n  });\n}\n\n/**\n * Request the current chain ID from the wallet.\n * @returns The current Starknet chain ID.\n */\nexport function requestChainId(swo: StarknetWindowObject) {\n  return swo.request({ type: 'wallet_requestChainId' });\n}\n\n/**\n * Get deployment data for a contract.\n * @returns The deployment data result.\n */\nexport function deploymentData(swo: StarknetWindowObject) {\n  return swo.request({ type: 'wallet_deploymentData' }); // TODO: test\n}\n\n/**\n * Add an invoke transaction to the wallet.\n * @param params The parameters required for the invoke transaction.\n * @returns The result of adding the invoke transaction.\n */\nexport function addInvokeTransaction(\n  swo: StarknetWindowObject,\n  params: AddInvokeTransactionParameters\n) {\n  return swo.request({\n    type: 'wallet_addInvokeTransaction',\n    params,\n  });\n}\n\n/**\n * Add a declare transaction to the wallet.\n * @param params The parameters required for the declare transaction.\n * @returns The result of adding the declare transaction.\n */\nexport function addDeclareTransaction(\n  swo: StarknetWindowObject,\n  params: AddDeclareTransactionParameters\n) {\n  return swo.request({\n    type: 'wallet_addDeclareTransaction',\n    params,\n  });\n}\n\n/**\n * Sign typed data using the wallet.\n * @param swo the starknet (wallet) window object to request the signature.\n * @param typedData The typed data to sign.\n * @returns An array of signatures as strings.\n */\nexport function signMessage(swo: StarknetWindowObject, typedData: TypedData) {\n  return swo.request({\n    type: 'wallet_signTypedData',\n    params: typedData,\n  });\n}\n\n/**\n * Get the list of supported specifications.\n * @returns An array of supported specification strings.\n */\nexport function supportedSpecs(swo: StarknetWindowObject) {\n  return swo.request({ type: 'wallet_supportedSpecs' });\n}\n\n/**\n * Attaches an event handler function to the \"accountsChanged\" event of a StarknetWindowObject.\n * When the accounts are changed, the specified callback function will be called.\n *\n * @param {StarknetWindowObject} swo - The StarknetWindowObject to attach the event handler to.\n * @param {AccountChangeEventHandler} callback - The function to be called when the accounts are changed.\n *                                              It will receive the changed accounts as a parameter.\n * @returns {void}\n */\nexport function onAccountChange(\n  swo: StarknetWindowObject,\n  callback: AccountChangeEventHandler\n): void {\n  swo.on('accountsChanged', callback);\n}\n\n/**\n * Register a callback function to be called when the network is changed.\n *\n * @param {StarknetWindowObject} swo - The StarknetWindowObject instance.\n * @param {NetworkChangeEventHandler} callback - The callback function to be called when the network is changed.\n * @return {void}\n */\nexport function onNetworkChanged(\n  swo: StarknetWindowObject,\n  callback: NetworkChangeEventHandler\n): void {\n  swo.on('networkChanged', callback);\n}\n","import {\n  type AccountChangeEventHandler,\n  type AddStarknetChainParameters,\n  type NetworkChangeEventHandler,\n  type WatchAssetParameters,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  type SPEC,\n} from 'starknet-types-07';\n\nimport { Account, AccountInterface } from '../account';\nimport { ProviderInterface } from '../provider';\nimport {\n  AllowArray,\n  CairoVersion,\n  Call,\n  CompiledSierra,\n  DeclareContractPayload,\n  MultiDeployContractResponse,\n  ProviderOptions,\n  TypedData,\n  UniversalDeployerContractPayload,\n} from '../types';\nimport { extractContractHashes } from '../utils/contract';\nimport { stringify } from '../utils/json';\nimport { buildUDCCall } from '../utils/transaction';\nimport {\n  addDeclareTransaction,\n  addInvokeTransaction,\n  addStarknetChain,\n  getPermissions,\n  onAccountChange,\n  onNetworkChanged,\n  requestAccounts,\n  signMessage,\n  switchStarknetChain,\n  watchAsset,\n} from './connect';\nimport { StarknetWalletProvider } from './types';\nimport { StarknetChainId } from '../constants';\n\n// Represent 'Selected Active' Account inside Connected Wallet\nexport class WalletAccount extends Account implements AccountInterface {\n  public address: string = '';\n\n  public walletProvider: StarknetWalletProvider;\n\n  constructor(\n    providerOrOptions: ProviderOptions | ProviderInterface,\n    walletProvider: StarknetWalletProvider,\n    cairoVersion?: CairoVersion\n  ) {\n    super(providerOrOptions, '', '', cairoVersion); // At this point unknown address\n    this.walletProvider = walletProvider;\n\n    // Update Address on change\n    this.walletProvider.on('accountsChanged', (res) => {\n      if (!res) return;\n      this.address = res[0].toLowerCase();\n    });\n\n    // Update Channel chainId on Network change\n    this.walletProvider.on('networkChanged', (res) => {\n      if (!res) return;\n      // Determine is it better to set chainId or replace channel with new one\n      // At the moment channel is stateless but it could change\n      this.channel.setChainId(res as StarknetChainId);\n    });\n\n    // Get and Set Address !!! Post constructor initial empty string\n    walletProvider\n      .request({\n        type: 'wallet_requestAccounts',\n        params: {\n          silent_mode: false,\n        },\n      })\n      .then((res) => {\n        this.address = res[0].toLowerCase();\n      });\n  }\n\n  /**\n   * WALLET EVENTS\n   */\n  public onAccountChange(callback: AccountChangeEventHandler) {\n    onAccountChange(this.walletProvider, callback);\n  }\n\n  public onNetworkChanged(callback: NetworkChangeEventHandler) {\n    onNetworkChanged(this.walletProvider, callback);\n  }\n\n  /**\n   * WALLET SPECIFIC METHODS\n   */\n  public requestAccounts(silentMode = false) {\n    return requestAccounts(this.walletProvider, silentMode);\n  }\n\n  public getPermissions() {\n    return getPermissions(this.walletProvider);\n  }\n\n  public switchStarknetChain(chainId: StarknetChainId) {\n    return switchStarknetChain(this.walletProvider, chainId);\n  }\n\n  public watchAsset(asset: WatchAssetParameters) {\n    return watchAsset(this.walletProvider, asset);\n  }\n\n  public addStarknetChain(chain: AddStarknetChainParameters) {\n    return addStarknetChain(this.walletProvider, chain);\n  }\n\n  /**\n   * ACCOUNT METHODS\n   */\n  override execute(calls: AllowArray<Call>) {\n    const txCalls = [].concat(calls as any).map((it) => {\n      const { contractAddress, entrypoint, calldata } = it;\n      return {\n        contract_address: contractAddress,\n        entry_point: entrypoint,\n        calldata,\n      };\n    });\n\n    const params = {\n      calls: txCalls,\n    };\n\n    return addInvokeTransaction(this.walletProvider, params);\n  }\n\n  override declare(payload: DeclareContractPayload) {\n    const declareContractPayload = extractContractHashes(payload);\n\n    // DISCUSS: HOTFIX: Adapt Abi format\n    const pContract = payload.contract as CompiledSierra;\n    const cairo1Contract = {\n      ...pContract,\n      abi: stringify(pContract.abi),\n    };\n\n    // Check FIx\n    if (!declareContractPayload.compiledClassHash) {\n      throw Error('compiledClassHash is required');\n    }\n\n    const params = {\n      compiled_class_hash: declareContractPayload.compiledClassHash,\n      contract_class: cairo1Contract,\n    };\n\n    return addDeclareTransaction(this.walletProvider, params);\n  }\n\n  override async deploy(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[]\n  ): Promise<MultiDeployContractResponse> {\n    const { calls, addresses } = buildUDCCall(payload, this.address);\n    const invokeResponse = await this.execute(calls);\n\n    return {\n      ...invokeResponse,\n      contract_address: addresses,\n    };\n  }\n\n  override signMessage(typedData: TypedData) {\n    return signMessage(this.walletProvider, typedData);\n  }\n\n  // TODO: MISSING ESTIMATES\n}\n","import type { Abi as AbiKanabi, TypedContract as AbiWanTypedContract } from 'abi-wan-kanabi';\n\nimport { AccountInterface } from '../account';\nimport { ProviderInterface, defaultProvider } from '../provider';\nimport {\n  Abi,\n  AbiEvents,\n  ArgsOrCalldata,\n  ArgsOrCalldataWithOptions,\n  AsyncContractFunction,\n  Call,\n  CallOptions,\n  Calldata,\n  ContractFunction,\n  ContractOptions,\n  EstimateFeeResponse,\n  FunctionAbi,\n  InvokeFunctionResponse,\n  InvokeOptions,\n  InvokeTransactionReceiptResponse,\n  ParsedEvents,\n  RawArgs,\n  Result,\n  AbiStruct,\n  ValidateType,\n} from '../types';\nimport assert from '../utils/assert';\nimport { CallData, cairo } from '../utils/calldata';\nimport { createAbiParser } from '../utils/calldata/parser';\nimport { getAbiEvents, parseEvents as parseRawEvents } from '../utils/events/index';\nimport { cleanHex } from '../utils/num';\nimport { ContractInterface } from './interface';\nimport type { GetTransactionReceiptResponse } from '../utils/transactionReceipt';\n\nexport type TypedContractV2<TAbi extends AbiKanabi> = AbiWanTypedContract<TAbi> & Contract;\n\nexport const splitArgsAndOptions = (args: ArgsOrCalldataWithOptions) => {\n  const options = [\n    'blockIdentifier',\n    'parseRequest',\n    'parseResponse',\n    'formatResponse',\n    'maxFee',\n    'nonce',\n    'signature',\n    'addressSalt',\n  ];\n  const lastArg = args[args.length - 1];\n  if (typeof lastArg === 'object' && options.some((x) => x in lastArg)) {\n    return { args: args as ArgsOrCalldata, options: args.pop() as ContractOptions };\n  }\n  return { args: args as ArgsOrCalldata };\n};\n\n/**\n * Adds call methods to the contract\n */\nfunction buildCall(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {\n  return async function (...args: ArgsOrCalldataWithOptions): Promise<any> {\n    const params = splitArgsAndOptions(args);\n    return contract.call(functionAbi.name, params.args, {\n      parseRequest: true,\n      parseResponse: true,\n      ...params.options,\n    });\n  };\n}\n\n/**\n * Adds invoke methods to the contract\n */\nfunction buildInvoke(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {\n  return async function (...args: Array<any>): Promise<any> {\n    const params = splitArgsAndOptions(args);\n    return contract.invoke(functionAbi.name, params.args, {\n      parseRequest: true,\n      ...params.options,\n    });\n  };\n}\n\n/**\n * Adds call/invoke methods to the contract\n */\nfunction buildDefault(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {\n  if (functionAbi.stateMutability === 'view' || functionAbi.state_mutability === 'view') {\n    return buildCall(contract, functionAbi);\n  }\n  return buildInvoke(contract, functionAbi);\n}\n\n/**\n * Adds populate for methods to the contract\n */\nfunction buildPopulate(contract: Contract, functionAbi: FunctionAbi): ContractFunction {\n  return function (...args: Array<any>): any {\n    return contract.populate(functionAbi.name, args);\n  };\n}\n\n/**\n * Adds estimateFee for methods to the contract\n */\nfunction buildEstimate(contract: Contract, functionAbi: FunctionAbi): ContractFunction {\n  return function (...args: Array<any>): any {\n    return contract.estimate(functionAbi.name, args);\n  };\n}\n\nexport function getCalldata(args: RawArgs, callback: Function): Calldata {\n  // Check if Calldata in args or args[0] else compile\n  if (Array.isArray(args) && '__compiled__' in args) return args as Calldata;\n  if (Array.isArray(args) && Array.isArray(args[0]) && '__compiled__' in args[0])\n    return args[0] as Calldata;\n  return callback();\n}\n\nexport class Contract implements ContractInterface {\n  abi: Abi;\n\n  address: string;\n\n  providerOrAccount: ProviderInterface | AccountInterface;\n\n  deployTransactionHash?: string;\n\n  protected readonly structs: { [name: string]: AbiStruct };\n\n  protected readonly events: AbiEvents;\n\n  readonly functions!: { [name: string]: AsyncContractFunction };\n\n  readonly callStatic!: { [name: string]: AsyncContractFunction };\n\n  readonly populateTransaction!: { [name: string]: ContractFunction };\n\n  readonly estimateFee!: { [name: string]: ContractFunction };\n\n  readonly [key: string]: AsyncContractFunction | any;\n\n  private callData: CallData;\n\n  /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */\n  constructor(\n    abi: Abi,\n    address: string,\n    providerOrAccount: ProviderInterface | AccountInterface = defaultProvider\n  ) {\n    this.address = address && address.toLowerCase();\n    this.providerOrAccount = providerOrAccount;\n    this.callData = new CallData(abi);\n    this.structs = CallData.getAbiStruct(abi);\n    this.events = getAbiEvents(abi);\n    const parser = createAbiParser(abi);\n    this.abi = parser.getLegacyFormat();\n\n    const options = { enumerable: true, value: {}, writable: false };\n    Object.defineProperties(this, {\n      functions: { enumerable: true, value: {}, writable: false },\n      callStatic: { enumerable: true, value: {}, writable: false },\n      populateTransaction: { enumerable: true, value: {}, writable: false },\n      estimateFee: { enumerable: true, value: {}, writable: false },\n    });\n    this.abi.forEach((abiElement) => {\n      if (abiElement.type !== 'function') return;\n      const signature = abiElement.name;\n      if (!this[signature]) {\n        Object.defineProperty(this, signature, {\n          ...options,\n          value: buildDefault(this, abiElement),\n        });\n      }\n      if (!this.functions[signature]) {\n        Object.defineProperty(this.functions, signature, {\n          ...options,\n          value: buildDefault(this, abiElement),\n        });\n      }\n      if (!this.callStatic[signature]) {\n        Object.defineProperty(this.callStatic, signature, {\n          ...options,\n          value: buildCall(this, abiElement),\n        });\n      }\n      if (!this.populateTransaction[signature]) {\n        Object.defineProperty(this.populateTransaction, signature, {\n          ...options,\n          value: buildPopulate(this, abiElement),\n        });\n      }\n      if (!this.estimateFee[signature]) {\n        Object.defineProperty(this.estimateFee, signature, {\n          ...options,\n          value: buildEstimate(this, abiElement),\n        });\n      }\n    });\n  }\n\n  public attach(address: string): void {\n    this.address = address;\n  }\n\n  public connect(providerOrAccount: ProviderInterface | AccountInterface) {\n    this.providerOrAccount = providerOrAccount;\n  }\n\n  public async deployed(): Promise<Contract> {\n    if (this.deployTransactionHash) {\n      await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n      this.deployTransactionHash = undefined;\n    }\n    return this;\n  }\n\n  public async call(\n    method: string,\n    args: ArgsOrCalldata = [],\n    {\n      parseRequest = true,\n      parseResponse = true,\n      formatResponse = undefined,\n      blockIdentifier = undefined,\n    }: CallOptions = {}\n  ): Promise<Result> {\n    assert(this.address !== null, 'contract is not connected to an address');\n\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(ValidateType.CALL, method, args);\n        return this.callData.compile(method, args);\n      }\n      // eslint-disable-next-line no-console\n      console.warn('Call skipped parsing but provided rawArgs, possible malfunction request');\n      return args;\n    });\n\n    return this.providerOrAccount\n      .callContract(\n        {\n          contractAddress: this.address,\n          calldata,\n          entrypoint: method,\n        },\n        blockIdentifier\n      )\n      .then((it) => {\n        if (!parseResponse) {\n          return it;\n        }\n        if (formatResponse) {\n          return this.callData.format(method, it, formatResponse);\n        }\n        return this.callData.parse(method, it);\n      });\n  }\n\n  public invoke(\n    method: string,\n    args: ArgsOrCalldata = [],\n    { parseRequest = true, maxFee, nonce, signature }: InvokeOptions = {}\n  ): Promise<InvokeFunctionResponse> {\n    assert(this.address !== null, 'contract is not connected to an address');\n\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(ValidateType.INVOKE, method, args);\n        return this.callData.compile(method, args);\n      }\n      // eslint-disable-next-line no-console\n      console.warn('Invoke skipped parsing but provided rawArgs, possible malfunction request');\n      return args;\n    });\n\n    const invocation = {\n      contractAddress: this.address,\n      calldata,\n      entrypoint: method,\n    };\n    if ('execute' in this.providerOrAccount) {\n      return this.providerOrAccount.execute(invocation, undefined, {\n        maxFee,\n        nonce,\n      });\n    }\n\n    if (!nonce) throw new Error(`Nonce is required when invoking a function without an account`);\n    // eslint-disable-next-line no-console\n    console.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n\n    return this.providerOrAccount.invokeFunction(\n      {\n        ...invocation,\n        signature,\n      },\n      {\n        nonce,\n      }\n    );\n  }\n\n  public async estimate(method: string, args: ArgsOrCalldata = []): Promise<EstimateFeeResponse> {\n    assert(this.address !== null, 'contract is not connected to an address');\n\n    if (!getCalldata(args, () => false)) {\n      this.callData.validate(ValidateType.INVOKE, method, args);\n    }\n\n    const invocation = this.populate(method, args);\n    if ('estimateInvokeFee' in this.providerOrAccount) {\n      return this.providerOrAccount.estimateInvokeFee(invocation);\n    }\n    throw Error('Contract must be connected to the account contract to estimate');\n  }\n\n  public populate(method: string, args: RawArgs = []): Call {\n    const calldata: Calldata = getCalldata(args, () => this.callData.compile(method, args));\n    return {\n      contractAddress: this.address,\n      entrypoint: method,\n      calldata,\n    };\n  }\n\n  public parseEvents(receipt: GetTransactionReceiptResponse): ParsedEvents {\n    return parseRawEvents(\n      (receipt as InvokeTransactionReceiptResponse).events?.filter(\n        (event) => cleanHex(event.from_address) === cleanHex(this.address),\n        []\n      ) || [],\n      this.events,\n      this.structs,\n      CallData.getAbiEnum(this.abi)\n    );\n  }\n\n  public isCairo1(): boolean {\n    return cairo.isCairo1Abi(this.abi);\n  }\n\n  public async getVersion() {\n    return this.providerOrAccount.getContractVersion(this.address);\n  }\n\n  public typedv2<TAbi extends AbiKanabi>(tAbi: TAbi): TypedContractV2<TAbi> {\n    return this as unknown as TypedContractV2<typeof tAbi>;\n  }\n}\n","import type { Abi as AbiKanabi, TypedContract as AbiWanTypedContract } from 'abi-wan-kanabi';\n\nimport { AccountInterface } from '../account';\nimport { ProviderInterface } from '../provider';\nimport {\n  Abi,\n  ArgsOrCalldata,\n  AsyncContractFunction,\n  BigNumberish,\n  BlockIdentifier,\n  CallOptions,\n  Calldata,\n  ContractFunction,\n  ContractVersion,\n  EstimateFeeResponse,\n  Invocation,\n  InvokeFunctionResponse,\n  InvokeOptions,\n  ParsedEvents,\n  RawArgs,\n  Result,\n  Uint256,\n} from '../types';\nimport { CairoCustomEnum } from '../utils/calldata/enum/CairoCustomEnum';\nimport { CairoOption } from '../utils/calldata/enum/CairoOption';\nimport { CairoResult } from '../utils/calldata/enum/CairoResult';\nimport type { GetTransactionReceiptResponse } from '../utils/transactionReceipt';\n\ndeclare module 'abi-wan-kanabi' {\n  export interface Config<OptionT = any, ResultT = any, ErrorT = any> {\n    FeltType: BigNumberish;\n    U256Type: number | bigint | Uint256;\n    U512Type: BigNumberish;\n    Secp256k1PointType: BigNumberish;\n    Option: CairoOption<OptionT>;\n    Tuple: Record<number, BigNumberish | object | boolean>;\n    Result: CairoResult<ResultT, ErrorT>;\n    Enum: CairoCustomEnum;\n    Calldata: RawArgs | Calldata;\n    CallOptions: CallOptions;\n    InvokeOptions: InvokeOptions;\n    InvokeFunctionResponse: InvokeFunctionResponse;\n  }\n}\n\ntype TypedContractV2<TAbi extends AbiKanabi> = AbiWanTypedContract<TAbi> & ContractInterface;\n\nexport abstract class ContractInterface {\n  public abstract abi: Abi;\n\n  public abstract address: string;\n\n  public abstract providerOrAccount: ProviderInterface | AccountInterface;\n\n  public abstract deployTransactionHash?: string;\n\n  readonly functions!: { [name: string]: AsyncContractFunction };\n\n  readonly callStatic!: { [name: string]: AsyncContractFunction };\n\n  readonly populateTransaction!: { [name: string]: ContractFunction };\n\n  readonly estimateFee!: { [name: string]: ContractFunction };\n\n  readonly [key: string]: AsyncContractFunction | any;\n\n  /**\n   * Saves the address of the contract deployed on network that will be used for interaction\n   *\n   * @param address - address of the contract\n   */\n  public abstract attach(address: string): void;\n\n  /**\n   * Attaches to new Provider or Account\n   *\n   * @param providerOrAccount - new Provider or Account to attach to\n   */\n  public abstract connect(providerOrAccount: ProviderInterface | AccountInterface): void;\n\n  /**\n   * Resolves when contract is deployed on the network or when no deployment transaction is found\n   *\n   * @returns Promise that resolves when contract is deployed on the network or when no deployment transaction is found\n   * @throws When deployment fails\n   */\n  public abstract deployed(): Promise<ContractInterface>;\n\n  /**\n   * Calls a method on a contract\n   *\n   * @param method name of the method\n   * @param args Array of the arguments for the call\n   * @param options optional blockIdentifier\n   * @returns Result of the call as an array with key value pars\n   */\n  public abstract call(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: CallOptions\n  ): Promise<Result>;\n\n  /**\n   * Invokes a method on a contract\n   *\n   * @param method name of the method\n   * @param args Array of the arguments for the invoke or Calldata\n   * @param options\n   * @returns Add Transaction Response\n   */\n  public abstract invoke(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: InvokeOptions\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Estimates a method on a contract\n   *\n   * @param method name of the method\n   * @param args Array of the arguments for the call or Calldata\n   * @param options optional blockIdentifier\n   */\n  public abstract estimate(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: {\n      blockIdentifier?: BlockIdentifier;\n    }\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Calls a method on a contract\n   *\n   * @param method name of the method\n   * @param args Array of the arguments for the call or Calldata\n   * @returns Invocation object\n   */\n  public abstract populate(method: string, args?: ArgsOrCalldata): Invocation;\n\n  /**\n   * Parse contract events of a GetTransactionReceiptResponse received from waitForTransaction. Based on contract's abi\n   *\n   * @param receipt transaction receipt\n   * @returns Events parsed\n   */\n  public abstract parseEvents(receipt: GetTransactionReceiptResponse): ParsedEvents;\n\n  /**\n   * tells if the contract comes from a Cairo 1 contract\n   *\n   * @returns TRUE if the contract comes from a Cairo1 contract\n   * @example\n   * ```typescript\n   * const isCairo1: boolean = myContract.isCairo1();\n   * ```\n   */\n  public abstract isCairo1(): boolean;\n\n  /**\n   * Retrieves the version of the contract (cairo version & compiler version)\n   */\n  public abstract getVersion(): Promise<ContractVersion>;\n\n  /**\n   * Returns a typed instance of ContractV2 based on the supplied ABI.\n   *\n   * @param {TAbi} tAbi - The ABI (Abstract Binary Interface) of the ContractV2.\n   * @return {TypedContractV2<TAbi>} - A typed instance of ContractV2.\n   */\n  public abstract typedv2<TAbi extends AbiKanabi>(tAbi: TAbi): TypedContractV2<TAbi>;\n}\n","import { AccountInterface } from '../account';\nimport {\n  Abi,\n  ArgsOrCalldataWithOptions,\n  CairoAssembly,\n  CompiledContract,\n  ValidateType,\n} from '../types';\nimport assert from '../utils/assert';\nimport { CallData } from '../utils/calldata';\nimport { Contract, getCalldata, splitArgsAndOptions } from './default';\n\nexport type ContractFactoryParams = {\n  compiledContract: CompiledContract;\n  account: any;\n  casm?: CairoAssembly;\n  classHash?: string;\n  compiledClassHash?: string;\n  abi?: Abi;\n};\n\nexport class ContractFactory {\n  compiledContract: CompiledContract;\n\n  account: AccountInterface;\n\n  abi: Abi;\n\n  classHash?: string;\n\n  casm?: CairoAssembly;\n\n  compiledClassHash?: string;\n\n  private CallData: CallData;\n\n  /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */\n  constructor(params: ContractFactoryParams) {\n    this.compiledContract = params.compiledContract;\n    this.account = params.account;\n    this.casm = params.casm;\n    this.abi = params.abi ?? params.compiledContract.abi;\n    this.classHash = params.classHash;\n    this.compiledClassHash = params.compiledClassHash;\n    this.CallData = new CallData(this.abi);\n  }\n\n  /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */\n  public async deploy(...args: ArgsOrCalldataWithOptions): Promise<Contract> {\n    const { args: param, options = { parseRequest: true } } = splitArgsAndOptions(args);\n\n    const constructorCalldata = getCalldata(param, () => {\n      if (options.parseRequest) {\n        this.CallData.validate(ValidateType.DEPLOY, 'constructor', param);\n        return this.CallData.compile('constructor', param);\n      }\n      // eslint-disable-next-line no-console\n      console.warn('Call skipped parsing but provided rawArgs, possible malfunction request');\n      return param;\n    });\n\n    const {\n      deploy: { contract_address, transaction_hash },\n    } = await this.account.declareAndDeploy({\n      contract: this.compiledContract,\n      casm: this.casm,\n      classHash: this.classHash,\n      compiledClassHash: this.compiledClassHash,\n      constructorCalldata,\n      salt: options.addressSalt,\n    });\n    assert(Boolean(contract_address), 'Deployment of the contract failed');\n\n    const contractInstance = new Contract(\n      this.compiledContract.abi,\n      contract_address!,\n      this.account\n    );\n    contractInstance.deployTransactionHash = transaction_hash;\n\n    return contractInstance;\n  }\n\n  /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */\n  connect(account: AccountInterface): ContractFactory {\n    this.account = account;\n    return this;\n  }\n\n  /**\n   * Attaches current abi and account to the new address\n   */\n  attach(address: string): Contract {\n    return new Contract(this.abi, address, this.account);\n  }\n\n  // ethers.js' getDeployTransaction can't be supported as it requires the account or signer to return a signed transaction which is not possible with the current implementation\n}\n","import {\n  BlockWithTxHashes,\n  FeeEstimate,\n  CallContractResponse,\n  DeclareContractResponse,\n  DeployContractResponse,\n  EstimateFeeResponse,\n  GetBlockResponse,\n  GetTransactionResponse,\n  InvokeFunctionResponse,\n  SimulateTransactionResponse,\n} from '../../types';\nimport type { GetTransactionReceiptResponse } from '../transactionReceipt';\n\nexport abstract class ResponseParser {\n  abstract parseGetBlockResponse(res: BlockWithTxHashes): GetBlockResponse;\n\n  abstract parseGetTransactionResponse(res: any): GetTransactionResponse;\n\n  abstract parseGetTransactionReceiptResponse(res: any): GetTransactionReceiptResponse;\n\n  abstract parseFeeEstimateResponse(res: FeeEstimate[]): EstimateFeeResponse;\n\n  abstract parseCallContractResponse(res: any): CallContractResponse;\n\n  abstract parseInvokeFunctionResponse(res: any): InvokeFunctionResponse;\n\n  abstract parseDeployContractResponse(res: any): DeployContractResponse;\n\n  abstract parseDeclareContractResponse(res: any): DeclareContractResponse;\n\n  abstract parseSimulateTransactionResponse(res: any): SimulateTransactionResponse;\n}\n","/* eslint-disable no-bitwise */\nimport { hexToBytes } from '@noble/curves/abstract/utils';\n\nimport { ADDR_BOUND, ZERO } from '../constants';\nimport { BigNumberish } from '../types';\nimport { addHexPrefix, removeHexPrefix } from './encode';\nimport { keccakBn } from './hash';\nimport { assertInRange, toHex } from './num';\n\n/**\n * Format a hex number to '0x' and 64 characters, adding leading zeros if necessary.\n *\n * @param {BigNumberish} address\n * @returns {string} Hex string : 0x followed by 64 characters. No upper case characters in the response.\n * @example\n * ```typescript\n * const address = \"0x90591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf\";\n * const result = addAddressPadding(address);\n * // result = \"0x0000090591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf\"\n * ```\n */\nexport function addAddressPadding(address: BigNumberish): string {\n  const hex = toHex(addHexPrefix(address.toString()));\n  const padded = removeHexPrefix(hex).padStart(64, '0');\n  return addHexPrefix(padded);\n}\n\n/**\n * Check the validity of a Starknet address, and format it as a hex number : '0x' and 64 characters, adding leading zeros if necessary.\n *\n * @param {BigNumberish} address\n * @returns {string} Hex string : 0x followed by 64 characters. No upper case characters in the response.\n * @throws address argument must be a valid address inside the address range bound\n * @example\n * ```typescript\n * const address = \"0x90591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf\";\n * const result = validateAndParseAddress(address);\n * // result = \"0x0000090591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf\"\n * ```\n */\nexport function validateAndParseAddress(address: BigNumberish): string {\n  const result = addAddressPadding(address);\n\n  if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error('Invalid Address Format');\n  }\n\n  assertInRange(result, ZERO, ADDR_BOUND - 1n, 'Starknet Address');\n\n  return result;\n}\n\n/**\n * Convert an address to her checksum representation which uses a specific pattern of uppercase and lowercase letters within\n * a given address to reduce the risk of errors introduced from typing an address or cut and paste issues.\n * @param {BigNumberish} address\n * @returns {string} Hex string : 0x followed by 64 characters. Mix of uppercase and lowercase\n * @example\n * ```typescript\n * const address = \"0x90591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf\";\n * const result = getChecksumAddress(address);\n * // result = \"0x0000090591D9fA3EfC87067d95a643f8455E0b8190eb8Cb7bFd39e4fb7571fDF\"\n * ```\n */\n// from https://github.com/ethers-io/ethers.js/blob/fc1e006575d59792fa97b4efb9ea2f8cca1944cf/packages/address/src.ts/index.ts#L12\nexport function getChecksumAddress(address: BigNumberish): string {\n  const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split('');\n  const hex = removeHexPrefix(keccakBn(address));\n  const hashed = hexToBytes(hex.padStart(64, '0'));\n\n  for (let i = 0; i < chars.length; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n\n  return addHexPrefix(chars.join(''));\n}\n\n/**\n * If the casing of an address is mixed, it is a Checksum Address, which uses a specific pattern of uppercase and lowercase letters within\n * a given address to reduce the risk of errors introduced from typing an address or cut and paste issues.\n *\n * @param address string\n * @returns true if the ChecksumAddress is valid\n * @example\n * ```typescript\n * const address = \"0x0000090591D9fA3EfC87067d95a643f8455E0b8190eb8Cb7bFd39e4fb7571fDF\";\n * const result = validateChecksumAddress(address);\n * // result = true\n * ```\n */\nexport function validateChecksumAddress(address: string): boolean {\n  return getChecksumAddress(address) === address;\n}\n","import urljoin from 'url-join';\n\n/**\n * Inspired from https://github.com/segmentio/is-url\n */\n\n/**\n * RegExps.\n * A URL must match #1 and then at least one of #2/#3.\n * Use two levels of REs to avoid REDOS.\n */\nconst protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\n\nconst localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nconst nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\n\n/**\n * Loosely validate a URL `string`.\n *\n * @param {string} s - The URL to check for\n * @return {boolean} `true` if url is valid, `false` otherwise\n * @example\n * ```typescript\n * const s = \"https://starknetjs.com/docs\";\n * const result = isUrl(s);\n * // result == true\n */\nexport function isUrl(s?: string): boolean {\n  if (!s) {\n    return false;\n  }\n\n  if (typeof s !== 'string') {\n    return false;\n  }\n\n  const match = s.match(protocolAndDomainRE);\n  if (!match) {\n    return false;\n  }\n\n  const everythingAfterProtocol = match[1];\n  if (!everythingAfterProtocol) {\n    return false;\n  }\n\n  if (\n    localhostDomainRE.test(everythingAfterProtocol) ||\n    nonLocalhostDomainRE.test(everythingAfterProtocol)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Builds a URL using the provided base URL, default path, and optional URL or path.\n *\n * @param {string} baseUrl - The base URL of the URL being built.\n * @param {string} defaultPath - The default path to use if no URL or path is provided.\n * @param {string} [urlOrPath] - The optional URL or path to append to the base URL.\n * @return {string} The built URL.\n * @example\n * ```typescript\n * const baseUrl = \"https://starknetjs.com\";\n * const defaultPath = \"/\";\n * const urlOrPath = \"/docs\";\n * const result = buildUrl(baseUrl, defaultPath, urlOrPath);\n *\n * result = \"https://starknetjs.com/docs\"\n */\nexport function buildUrl(baseUrl: string, defaultPath: string, urlOrPath?: string) {\n  return isUrl(urlOrPath) ? urlOrPath! : urljoin(baseUrl, urlOrPath ?? defaultPath);\n}\n"],"mappings":"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","names":["RpcProvider","RpcChannel","ETransactionType","ESimulationFlag","ETransactionStatus","ETransactionFinalityStatus","ETransactionExecutionStatus","EBlockTag","EDataAvailabilityMode","EDAMode","ETransactionVersion","ETransactionVersion2","ETransactionVersion3","BaseUrl","NetworkName","StarknetChainId","TransactionHashPrefix","FeeMarginPercentage","import_utils","ValidateType","Uint","Literal","EntryPointType","TransactionType","TransactionStatus","TransactionFinalityStatus","TransactionExecutionStatus","BlockStatus","BlockTag","number","hexToBytesNoble","CairoOptionVariant","CairoResultVariant","listTypeVariant","parsedParameter","parseBaseTypes","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","calculateInvokeTransactionHash","computeHashOnElements","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","calculateTransactionHashCommon","import_starknet","calculateTransactionHashCommon","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","calculateInvokeTransactionHash","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","import_starknet","parse","stringify","computeHashOnElements","json","stringify","parse","import_starknet","stringify","base64","parse","parse","makeFetchCookie","isomorphicFetch","stringify","parse","stringify","RpcChannel","defaultOptions","RpcChannel","stringify","RpcChannel","StarknetIdContract","StarknetIdIdentityContract","StarknetIdVerifierContract","StarknetIdPfpContract","StarknetIdPopContract","StarknetIdContract","StarknetIdIdentityContract","StarknetIdVerifierContract","StarknetIdPfpContract","StarknetIdPopContract","StarknetIdMulticallContract","RpcProvider","calculateInvokeTransactionHash","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","import_secp256k1","uint256","calculateInvokeTransactionHash","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","RpcProvider","StarknetIdContract","stringify","import_utils","urljoin"]}